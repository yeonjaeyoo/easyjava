전자 메일 => 이메일?

이메일 통신은 지난 몇 십년 동안 정보 교환의 주요한 방식이 됐다.

하지 않을까? => 하지 않는가?

소개

안녕, 여러분. 좋은 하루 보내고 있길 희망한다.

email => 이메일

유스 케이스의 도움을 받아 => 사용 사례의 도움으로

이해할 것이다. => 살펴볼 것이다.

그럼 무엇을 기다리는가?

전자메일 => 이메일

그들은 => 이메일은

과거에는, 이메일이 통신이 성공하기 위해서는 발송자와 수신자가 온라인 상태여야 했다.

말이 안 된다고 생각하지?

점포 및 철학? => 가게 앞을 내다보는 철학을 공부하기 시작했다.

나중에 편리하게 => 나중에 편하게 확인할 수 있다.

이메일 메시지는 ASCII전용 문자로 시작했고, 나중에 풍부한 텍스트 및 첨부파일을 위한 MIME(Multipurpose Internet Mail Extensions)로 확장됐다.

프로토콜의 관점에서 보면, 이메일은 처음에 컴퓨터를 통해 메시지를 보내기 위해 FTP(File Transfer Protocol)로 작업했지만, 아시다 시피 SMTP(Simple Mail Transfer Protocol)는 이메일 작업에 가장 널리 사용되는 프로토콜이다.

중요표시시작

시작하는 데 => 설정을 시작하는 데

Gmail 웹 클라이언트에 적용되는 예제를 살펴보면, 여러분이 직접 이메일 서버를 설정하지 않고도 코드 예제를 신속하게 시도하고 파이썬을 사용하여 이메일 작업을 자동화할 수 있다는 것을 이해할 수 있다.
Gmail을 예제로 사용하고 있지만, 이러한 일부 정보들은 이메일 전송을 위한 SMTP와 이메일 검색을 위한 IMAP을 지원하는 다른 이메일 서버와도 연동된다.

Page 2.

중요표시시작

파이썬을 사용하여 이메일로 작업하면 메시지를 작성하는 데 도움이 되는 모듈 그리고 이메일을 전송할 수 있는 모듈, 메시지를 검색하고 업데이트하는 데 도움이 되는 모듈이 필요하다.

준비하기

선호하는 pip 도구로 smtplib를 설치할 수 있다.

실행방법

1.

조각을 => X

설정 파일에는 이메일 주소, 패스워드 및 이메일을 전송해야 하는 이메일 주소와 같은 로그인 상세 내역이 있다.

2.

환경 파일 => 설정 파일

작성해보자. => 작성하자.

Page 3.

4.

예외 => 예외(exceptions)

예외는 다음과 같다.

5.

예외(Exception)는 서버에 로그인하는 것이 좋다고 하지만 Gmail은 여러분이 메시지를 전송하는 것을 블록했다.

안정성이 => 보안성이

그래 => 예

6.

다음 스크린샷과 같이 이 설정을 설정할 수 있는 Less secure apps 페이지로 이동한다.

7.

이제 Gmail 웹 클라이언트에서 로그아웃 했다가 다시 로그인하여 이 설정이 계정에 적용되도록 한다. 이 과정이 정상적으로 진행된 경우 Google에서 Access for less secure apps이 설정됐다는 이메일을 받는다. 구글의 확인 이메일은 이 스크린샷과 유사하다.

8.

시원해 => 좋아. 유의하라, 

메시지 내용은 => 메시지 콘텐츠는 코드에 추가한 것과 같다.

사용자가 => 여러분이 전송한 것이지만, 제목이 없으므로 좋지않다.

작동원리

코드 조각을 => 코드를

Page 4.

일단 서버 객체 server가 생기면

비밀번호 => 패스워드

server.starttls() => server.starttls();

더 알아보기

기본 전자 메일을 보내는 방법을 => 기본적인 이메일 전송 방법을

이 레시피가 우리를 시작하게 하는 동안, 다음 레시피에서 자세히 조사할 것이 더 있다. 그것들을 살펴보자.

이메일 암호화

내용을 => 콘텐츠를

준비하기

레서피 => 레시피

기본 => 기본적인

작동하나? => 작동할까?

1.

코드 조각을 => 코드를

2.

부문으로 => 세그먼트로

Page 5.

3.

서버 객체에서 => server 객체에서

작동원리

이메일 암호화는 이메일 메시지가 의도한 당사자가 아닌 다른 사람이 읽지 못하도록 보호하는 것을 의미한다.

여기에는 인증도 포함될 수 있다.

하지만, STARTTLS(SMTP 상위 계층)의 출현과 메시지 제출을 위한 포트 587의 사용으로, Gmail과 같은 이메일 클라이언트는 이메일 전송에 STARTTLS와 포트 587을 사용한다.

Gmail에도 인증이 구현된다.

확장자 => 확장명

server.ehlo( => server.ehlo()를 전송할 때

extension => 용어 통일. 확장? 확장명? 확장자?

마지막으로 server.quit()를 사용하여 SMTP세션을 종료했으며, 세번째 스크린 샷에 표시된 것처럼 closing connection으로 응답한다.

더 알아보기

2018.02.26

잠시 시간을 내어 이해해본다. 

보내는 것에서 => 전송하는 것에서

걱정하지마. => 걱정하지말자.

MIME로 이메일 메시지 꾸미기

처음 몇 가지 레시피는 간단하고 오래된 평문으로 이메일을 전송했다.

Page 6.

MIME 인터넷 표준은 비 ASCII 문자, 멀티파트(multipart) 메시지 및 이미지를 사용하여 메시지를 작성하도록 도와준다.

첨부 파일 => 첨부파일?

실행방법

3.

자, 이제 누구에게 이메일을 전송할 것인지에 대한 세부 사항을 알게됐다.

보내자. => 전송하자.

작동원리

앞의 예제에서는 SMTP서버에 로그인하기 위해 fromaddress 및 password를 받은 설정 파일과 이메일 메시지를 전송할 toaddress를 가져왔다.

모르는 사람을 위해, MIME 멀티파트 메시지는 하나의 이메일에 있는 HTML과 텍스트 콘텐츠 모두를 의미한다.

multipart => 멀티파트

내용을 => 콘텐츠를

내용은 => 콘텐츠는

multipart 메시지에 => 멀티파트 메시지에

메시지와 수신자 상세 내역이 있으면 SMTP.sendmail() 메소드를 사용하여 평소대로 이메일을 전송한다.

첨부 파일과 이메일 메시지

Page 7.

실행방법

1. 그 내용은 => 그 콘텐츠는

3.

받은 편지함 => 받은편지함

작동원리

multipart => 멀티파트

다른 새로운 => 새

파일 핸들 첨부 파일을 => 파일 핸들 attachment를

내용을 => 콘텐츠를

추가한다. => 추가되어야 한다.

multipart => 멀티파트(multipart)

Page 9.

좋아, 그래서 완전한 MIME 메시지와 그 메시지를 누구에게 보낼지에 대한 세부 사항을 가진다.

첨부 파일이 있는 => 첨부 파일이 포함된

성취하고자 했던 것을 수행했다.

받은편지함 연결

것에 대해 이야기했다. => 것을 살펴봤다.

그러나 경우에 따라 받은편지함을 스캔하여 수신되는 메시지를 읽을 수도 있다.

준비하기

기본 파이썬 설치에서 => 기본 파이썬 설치로

실행방법

1.

환경 파일을 => 설정 파일을

코드는 다음과 같다.

2.

Gmail => 지메일

받은 편지함 => 받은편지함

이제 모든 라벨에서 Inbox를 선택하려는 경우에도 이를 달성할 수 있다.

이전 코드의 출력은 다음 스크린샷에 표시된다. 라벨을 여러개 생성했는데도 라벨이 더 적은 스크린 샷을 가져왔다.(확인)

Page 10.

작동원리

5장을 시작하면서 살펴본 바와 같이, 이메일로 작업할 수 있는 세가지 주요 프로토콜이 있다. 이메일을 전송하기 위해 SMTP를 많이 사용했지만 이메일을 읽는 동안 POP 혹은 IMAP를 사용하여 이메일 서버에서 메시지를 검색할 수 있다. 단계적으로 그 코드를 살펴볼 것이다.

Gmail 서버는 => 지메일 서버는

생성자~  => 생성자~ ;

내부적으로 평문(clear text) 소켓을 사용하는 IMAP4클래스의 사용을 배제한다.

받은 편지함 => 받은 편지함

제 경우 => 이 경우

레이블 목록 => 라벨 목록

닫는다. => 종료한다.

그래! 그것은 좋고 쉽다.

더 알아보기

그래서, 이 레시피에서 받은편지함에 연결하는 방법을 다뤘지만, 아마도 메시지를 읽고, 표시하고, 그것에 대해 흥미로운 행동을 하고 싶어할 것이다. 다음 레시피에서 어떻게 메시지에 대한 작업을 하는지 살펴보자.

이메일 메시지 가져오기 및 읽기

이 레시피에서는 특정 제목의 이메일을 검색하여 미리 정의된 조건과 일치하는 최신 메시지를 받은 편지함에서 가져온다.

실행방법

환경 파일을 => 설정 파일을

Page 11.

3.

코드 조각의 출력은 => 코드의 출력은

작동원리

코드 조각에서 => 코드에서

환경 파일의 => 설정 파일의

그런 다음 그곳에서 검색 작업을 수행할 수 있도록 INBOX를 선택한다.

제목이 포함된 => 제목인

기준과 일치하는 가장 최근의 이메일 객체를 전달하고, RFC 822 형식의 이메일 본문을 원하는 RFC822를 전달한다.

fetch()를 통해 얻은 메시지를 출력하면, 검색과 일치하는 최신 이메일의 이메일 본문의 콘텐츠를 받게된다.

지금, 여러분은 이메일의 콘텐츠를 기억하는가?

글쎄, 이메일 첨부 파일을 보여 주는 데 사용된 이전의 레시피의 중의 하나에서 전송한 동일한 이메일 메시지다.

더 알아보기

받은편지함에 표시하고 싶은 메시지를 포함하여 더 세분화된 작업이 많이 있다. 다음 레시피에서 살펴보자. 

이메일 메시지 표시

검색이나 읽기 같은 간단한 작업을 하는 동안 그렇게 많은 세부 정보를 처리해야할까?

준비하기

pip 명령을 => pip 커멘드를

터미널을 통해 => 터미널로

gmail API를 사용하여 이메일을 검색하고 읽는 방법을 살펴보자.

gmail 모듈로 시작하게 할 것이다.

다음 코드는 2016년 7월 22일 이후 수신된 이메일을 검색한다.

이 후 가장 최근의 메시지를 가져왔다.

일단 메시지를 가져오면, 그냥 이메일 본문을 읽어본다.

Page 12.

너무 쉽지 않았는가? 그런데, gmail 모듈이 imaplib 위에 쓰여 있지만 더 나은 API가 있으니, 이 모듈을 이용해서 환상적인 작업을 하자.

실행방법

1.

받은 편지함을 열고 특정 조건과 일치하는 읽지 않은 메시지를 찾아 메시지를 읽은 것으로 표시한다.

받은 메일함 => 받은 편지함

이 프로그램을 실행하기 전에, https://glassdoor.com에서 제가 읽지 않은 이메일을 한통 받았다. 제 받은 편지함에 이렇게 나와 있다.

코드를 실행한 후에, 그것은 이 이메일이 noreply@glassdoor.com의 읽지 않은 메시지의 기준과 일치한다는 것을 확인했고, 내 메시지를 읽은 것으로 표시했다.

지메일은 읽기 메시지를 볼드체를 해제하고 그것이 내 받은 편지함에서 일어난 일이다.(확인)

2.

메일함 => 편지함?

Page 13.

3. 

이제, 이 모든 것을 read로 표시하고 한 가지 라벨 AMAZON 아래에 배치하고 싶다.

있니? => 있을까?

작동원리

Gmail => 지메일

이제 이 객체를 사용하여 undread하고 noreply@glassdoor.in에 의해 전송된 이메일을 검색하기 시작하고 이 기준과 일치하는 모든 메일 객체가 mails에 저장된다.(확인)

나중에 최신 레코드를 fetch() 메소드로 가져와서 read() 메소드로 읽은 메일로 표시한다.

아주 쉽게 할 수 있다, 멋지다.

더 알아보기

중요하게 => 중요한 것으로

받은 편지함 =? 받은 메일함? 통합

받은 편지함의 이메일 메시지 삭제

Page 14.

중요표시시작

따라서 메시지를 삭제할 때 서버 구현에 따라 이메일 서버에 계속 저장할 수 있도록 메시지를 받은 편지함에서 숨김 상태로 표시하기만 하면 된다.

중요표시종료

준비하기

이 레시피에 => 이 레시피는

실행방법

1.

환경 파일을 => 설정 파일을 활용하여

가져와 => 가져와서

작동원리

환경 파일 => 설정 파일

로그인 자격 증명 => 용어 확인

그런 다음 받은 메일함에 연결하고 junk@xyz.com.에서 들어오는 이메일을 검색한다.

반복 처리하고 => 반복하여

정크 메일 => 정크로

더 알아보기

그래서 이제 이메일 메시지를 전송, 첨부 추가, 그것들을 가져와서 읽는 방법을 알고 있다.

레이블을 => 라벨을

이 지식으로 무장하여, 약간의 문제가 있는 켈리를 위해 무언가를 할 수 있을까?

Page 15.

그녀의 지원 엔지니어 대부분은 결국 고객들이 이미 웹 사이트에서 이용 가능한 정보를 찾고 있는 수준 1지원 요청에 응답한다.

고객들은 결국 자신을 찾아 보지 않고도 지원을 위해 이메일을 전송하게 된다.

고객은 웹 사이트에 정보를 직접 가져오지 않고 기다리기만 하면되며, 지원 엔지니어는 수동으로 웹 사이트의 FAQ(Frequently Asked Questions) 절에 대한 포인터를 고객에게 보내준다.

켈리(Kelly)는 이 방식을 개선하기 위한 기회로 간주하며, 이 흐름을 자동화하여 지원에 소요되는 시간을 단축하고자 한다.

준비하기

물론, 이는 해결해야 할 더 큰 문제이지만 적어도 흐름을 자동화하는 데 도움이 되는 것을 할 수 있다.
지원 팀이 전자 우편으로 새 티켓을 받을 때마다, 티켓 수령을 승인하는 티켓에 자동적으로 응답할 수 있고, 또한 회사 웹 사이트의 FAQ 절로 링크를 전송할 수 있다.
이렇게 하면 고객은 FAQ 절에서 필요한 정보를 찾아볼 수 있다.
또한 자동 응답 이메일로 이미 고객 질의를 해결했을 뿐만 아니라 신속하게 이를 해결할 수도 있기 때문에 지원 엔지니어에 대한 부하도 감소한다.
자, 이제 실제로 무엇이 필요할까? 지원 받은편지함을 모니터링하고, 새로운 고객 문의 사항이 있으면 살펴본 다음, 템플릿 이메일로 자동 응답해야 한다.

실행방법

1. 

해결책으로 바로 넘어가자.

파이썬 파일을 생성하고 다음과 같은 코드를 복사한다.

지원 흐름 => 지원 플로우?

Page 16.

2.

실제로 고객이 지원 엔지니어에게 요청하는 새로운 이메일을 기다리고 있다.

3. 이제 고객 지원에 이메일을 전송하면 파이썬 프로그램으로 자동 응답을 수신할 것이다.

중요표시시작

이 경우 지원 받은편지함은 내 이메일 주소이지만 고객 요청이 이 계정으로 전달되도록 회사 이메일 계정을 쉽게 설정할 수 있다.

작동원리

while 루프가 읽지 않은 이메일을 발견하는 동안 이메일을 가져오고 fr 속성을 가져온다.

Page 17.

받는다. => 수신한다.

기술 지원 엔지니어가 => 지원 엔지니어가

그녀는 고객 지원 흐름이 어느 정도 자동화된다는 것을 이해하고 있으며, 곧 생산성 향상을 기대하고 있다.

대단해. 여러분이 이메일로 할 수 있는 다른 많은 것들이 있다. 이메일 첨부 파일을 다운로드 하겠는가? 한번 시도해 볼까?

6장.

보스 => 사장님

더 이상 걱정할 필요가 없다.

소개

데이터 보고, 작업 관리 상태 혹은 아이디어 제시와 관련하여 PowerPoint 프레젠테이션은 가장 적합한 방법 중 하나다.

비즈니스와 관련한친구 몇 명에게 물어보자.

전문가들은 즉, 사고 프로세스(thought process)가 PowerPoint 프레젠테이션 슬라이드(즉, PPT)를 중심으로 구성되어 있다는 의미의 프레젠테이션에서 거의 모든 것을 생각한다.

PowerPoint => 파워포인트

이미지 호스팅 => 이미지 및 차트 표시 등의

중요표시시작

파워포인트 프레젠테이션과 관련하여 수행할 수 있는 모든 주요 작업을 다룰 때 더 많은 작업을 수행할 수 있는 가능성이 항상 존재한다.
파이선과 함께하면서 여러가지 기능을 배우는 것을 적극 추천한다.

Windows의 => python ~ 대신 Windows의 ~ 사용하여

파워포인트 프레젠테이션 읽기

파워포인트 프레젠테이션 경험으로 PPT파일은 슬라이드가 포함되어 있으며, 각 슬라이드에는 청중에게 보여주어야 할 세부 정보가 포함된 것을 알고있다.

실행방법

1.

얻는다. => 얻을 것이다.

그것은 두개의 슬라이드로 이루어지고 책의 저자에 대한 정보를 담고 있다.

2.

제목 항목은 => 제목은

그것은 다른 레이아웃을 가지고 슬라이드 제목은 저자의 네 가지 소원과 This is circle of life 콘텐츠가 있는 원형 모양이 포함된 He wishes to이다.

3.

코드 조각의 => 코드의

4.

슬라이드는 slide 객체의 파이썬 목록으로 표시되고, for 루프로 반복될 수 있다.

5.

코드 조각은 => 코드는

코드 조각의 => 코드의

6.

좋아, 멋지다. 한 단계 더 깊이 들어가서 slides 객체의 몇가지 속성을 살펴보자. 다음 코드는 slide 객체의 몇가지 속성을 출력한다.

7.

인쇄한다. => 출력한다.

8.

예를 들어 첫 번째 슬라이드에는 제목과 부제 등 두개의 텍스트 자리 표시자가 있다. 두 번째 슬라이드에서는 자리 표시자 두 개가 있지만 원형 모양도 있다. 다음 코드가 이 정보를 출력한다.

코드 조각의 => 코드의

자동 모양이 => AUTO SHAPE ?

9.

우리가 => X

세계에서 => 의

작동원리

이 레시피는 전체 프리젠테이션을 읽고 두 슬라이드의 콘텐츠를 얻었다.

파일인 ~ 객체를 => 파일의 객체인 prs를

메소드를 사용하여 => 메소드로

접속할 => 엑세스할

그런 다음 slides 객체를 사용하여 slides.shapes으로 두 슬라이드 모두에서 사용 가능한 모든 도형을 가져올 수 있다.

paragraph 객체의 runs 속성에는 실제 텍스트 데이터 목록이 포함되며, 이 목록은 배열, text_runs에 저장된다.

더 알아보기

우리는 => X

이 모든 것이 좋지만, 새로운 PPTX 파일을 생성하고 싶다, 그렇지? 또한 프레젠테이션 생성을 자동화하기를 희망하는가? 그래서 이제 파이썬을 사용해서 이 작업을 수행하는 방법을 살펴보자.

프리젠테이션 생성 및 수정, 슬라이드 추가

Page 5.

이 절에서는 레시피에 => 이 절의 레시피는

물론 슬라이드에 내용을 => 슬라이드에 콘텐츠를

실행방법

1. 

Yo! Python로 => Yo! Python이 쓰여진
생성하 데 => 생성하는 데
서브 타이틀 => 부제?
또한 슬라이드 레이아웃이 Title Slide인지 확인한다.

2. 

PowerPoint => 파워포인트

내용을 => 콘텐츠를

<그림>

3.

슬라이드 1은 제목 텍스트 Hello!로 수정되고 레이아웃, 제목 및 콘텐츠가 있는 새 슬라이드는 텍스트 This is a paragraph가 추가된다.

Page 6.

작동원리

앞의 코드에서 세 가지를 달성했다.

제목 텍스트와 부제 텍스트를 => 제목과 부제를

다음과 같은 방법으로 이것을 달성했다.

1. presentation 객체 => 프레젠테이션 객체

그런 다음 prs 객체는 add_slide() 메소드를 사용하여 새 슬라이드를 추가했다.

3. 부제목 => subtitle?

내용은 => 콘텐츠는

다음에 => 다음으로

얻은 것이다. => 달성한 것이다.

2. 도형 => 모양

업데이트 됐다 => 수정됐다.

3. 

레이아웃 1 => Layout 1
제목 및 내용 => Title and Content
내용이 => 콘텐츠가

더 알아보기

좋아! 그래서 처음부터 새로운 프리젠테이션을 생성하고, 기존 템플릿을 수정하고, 새로운 콘텐츠를 추가하고, 프리젠테이션을 생성하고, 마지막으로 다른 종류의 레이아웃과 글머리 데이터로 프리젠테이션을 생성하는 방법을 다뤘다.

레이아웃, 자리 표시자 및 텍스트 상자를 사용한 재생

실행방법

1. 이제 더 나아가서 다양한 유형의 슬라이드 레이아웃과 글머리 기호 콘텐츠를 사용한다. 다음의 코드는 우리가 필요로 하는 것을 수행한다.

2. 텍스트상자 => 텍스트박스?

작동원리

내용 => 콘텐츠

그 위에 무엇을 했는지 살펴보자.

1.

코드에서 prs.slide_layouts[3]를 사용하여 프레젠테이션 객체 prs를 전달하고 두개의 컨텐츠 레이아웃이 있는 슬라이드를 추가했다.
두 개의 콘텐츠 레이아웃에도 제목 텍스트가 있으며, 이 텍스트는 shapes.title 속성을 사용하여 Adding a Two Content Slide로 업데이트 됐다.

2.

자리 표시자(placeholder)는 콘텐츠를 추가할 수 있는 미리 포맷된 컨테이너이다.

왼쪽에 하나, 그리고 오른쪽에 하나, 두개의 콘텐츠 슬라이드에 두개의 자리 표시자가 있다.

왼쪽을 shapes.placeholders[1]로 목표로하고, shapes.placeholders[1].text_frame의 참조로 텍스트 프레임에 첫번째 라인 This is line 1. 을 추가했다.

3.

그런 다음 text_frame에 add_paragraph() 메소드로 단락을 추가하여 글머리 기호 라인을 추가하고 레벨 1에서 텍스트 Again a line 2…, 레벨 2에서 And this is line 3…를 추가했다.

4.

기본적으로 모든 도형이 텍스트를 포함하는 것은 아니지만 shape.has_text_frame 속성을 사용해 도형이 텍스트를 지원하는지 확인하는 것이 좋다.

이 레시피에서 모양이 텍스트 콘텐츠를 처리할 수 있는 자리표시자를 포함하는 것을 알고 있다.

행을 => 라인을

마찬가지로, level 속성을 사용하여  bulleted fashion에서 다음 라인을 추가하기 위해 add_paragraph() 메소드를 사용했다.

스크린샷을 살펴보면 슬라이드의 왼쪽 텍스트 프레임에 추가된 텍스트에 글머리 기호 보기(bulleted look)가 표시된다.

사람들은 텍스트박스를 사용하여 점을 강조하고 텍스트박스의 크기 조정 및 이동 기능을 효과적으로 사용한다.

텍스트박스 => 텍스트상자?

이것이 레시피에서 한 것이다.

2.

다음으로 적절한 차수(dimensions)의 텍스트박스를 생성했다.
왼쪽 및 위쪽 좌표에 Inches(2)를 사용하고, 각각 Inches(5)와 Inches(1)로 너비와 높이를 관리했다.
텍스트박스 객체를 사용하여 text_frame 속성이 있는 텍스트 프레임 객체 tf를 추가했다.

5.

그 다음에 add_paragraph() 메소드로 단락을 추가하고 이 단락에 새 텍스트를 추가하고 텍스트를 굵게(bold), 기울임(italics), 크기를 30으로 증가하게 만들었다.

6.

결국 => 마지막으로

또한 슬라이드 데크(deck)에 필요한 차원의 텍스트상자를 추가하는 것을 다뤘다.

Page 9.

다양한 모양과 표 추가

다른 모양 => 다양한 모양

왜 기다릴까? 신속하게 행동을 개시하자.

실행방법

1.

button => 버튼

채운다. => 채울 것이다.

새로운 스크린샷 => 새로운 프레젠테이션

2.

다시, 표는 프레젠테이션에서 데이터를 표시하고 정보에 입각한 결정을 내리는 데 사용된다.

발표자들(프리젠테이션을 담당하는 사람)은 종종 표로 특정 프로젝트에 대한 사실을 제시하고 청중에게 토론이나 피드백을 구한다.

프레젠테이션에 표를 추가하는 것은 파이썬으로 간단하다. 다음 코드를 살펴본다.

코드 조각을 => 코드를

작동원리

코드 조각에서는 => 코드에서는

1.

메소드 도움으로 => 메소드로

Page 11.

2.

열거 => 열거형(enumeration)

=> 즉, MSO~

선택한다. => 가져온다.

텍스트 상자의 경우와 같이 add_shapes() 메소드도 Inches()메소드로 정의된 도형(모양?)의 크기가 필요하다.

3.

색을 => 색상을

밝기를 => 밝기도

4.

두 가지 모양 => 모든 모양

결국 => 마지막으로

테이블을 => 표를

2. 

모양 => 도형?

테이블을 => 표를

add_table() 메소드는 입력으로 다수의 행과 열을 예상하는 동시에 표의 크기를 예측한다.

예를 들어, 행을 4로 설정하고, 열을 3으로 설정하고 표의 크기를 좌표 Inches(2) 및 Inches(2) 및 Inches(6), Inches(8) 중에서 왼쪽으로 설정했는데 이것은 표가 왼쪽에서 2인치, 슬라이드 상단에서 2인치 아래에 위치해 있고, 표 너비는 6인치이며, 높이는 1.2인치(15.3 cmx3.1cm) 이다.

3.

표는 세개의 열로 정의했다. 각 열의 너비(width)는 2인치로 설정됐다.

머리글의 => 머리글(column headings)의

여기서 행 값은 항상 0이며, 이것은 첫번째 행 혹은 제목 행을 나타내고, 열은 0에서 2까지, 즉 세 개의 열을 나타낸다.

4.

이 예제에서는 학생 이름 및 학생 ID와 같은 정보를 담고 있는 사전정의된 딕셔너리인 students을 사용했다.

업데이트하며 => 수정하며

모든 학생 정보를 살펴보고 표의 셀을 수정하여 표에 적절한 정보를 채운다. 따라서 스크린샷에 표시된 것처럼 표는 모든 학생 데이터로 채워진다.

5.

결국 => 마지막으로

더 알아보기

좋다. 파이썬을 사용하여 다른 프레젠테이션을 할 수 있을까? 아니면 여러분 중 몇명은 이미 내가 그래픽을 사용하여 차트 혹은 사진에 대해 이야기하기를 기대하고 있지 않을까? 그래, 잘 다루겠다. 자, 그럼 그래픽적으로 살펴보자.

그림과 차트를 이용한 시각화

사람들은 사진이 천 마디 말을 한다고 하는데, 그 안에 많은 사진과 그래프가 있는 프리젠테이션을 본 적이 있을 것이라고 생각한다.
그들이 거기에 온 것은 이유가 있다.
한번의 슬라이드로 최대한 많은 정보를 전달할 수 있다. 차트와 그림 둘 다 이러한 힘을 가지고 있으며, 이에 대해 알지 못한 채, 이 장은 불완전하게 남아있다. 따라서 시작하자.

Page 12.

준비하기

1.

코드 조각은 => 코드는

2018.03.19

2.

거품 차트 => 버블 차트(bubble chart)

pie chart => 원형 차트(pie chart)

작동원리

코드 조각에서 => 코드에서

좋지 않은가? => 좋지 않을까?

1.

예상대로 add_picture()는 이미지를 프레젠테이션에 추가해야하는 위치와 다른 메소드와 마찬가지로 그림의 좌표와 크기를 예상한다.

맨 위에서 => 상단에서

사진 => 그림

너비 => ?

높이 =? ?

위쪽에서 => 상단에서

왼쪽에서 2인치, 상단에서 5 인치, 높이 2인치 및 너비가 이미지 너비와 같도록 구성됐다.

3.

결국 => 마지막으로

1.

추가했고 제목 텍스트를 ~로 설정했다.

2.

그런 다음 ChartData()로 클래스 객체를 생성했고, chart_data로 불렀다.

3.

추가했나? => 추가했을까?

그래, 여러분이 추측했다.

add_chart() 메소드는 인자의 하나로 차트 유형을 예상하며, 다른 방식과 마찬가지로 배열을 필요로 한다.

속성 has ~ format 및 데이터 라벨을

하지만 실제 사용 사례를 해결하기 위해 이 지식을 적용하는 것보다 더 재미 있는 것은 없다.

Page 14.

Alex => 알렉스(Alex)

주별 판매 보고서 자동화

inc => 주식회사

판매 매니져 => 영업 책임자

sales managers => 영업 관리자

판매원이 => 영업 관리자가

알렉스는 부하 직원들의 성공 여부를 판단하고 이를 매주 영업 부사장에게 보고할 책임이 있다.

알렉스의 사장은 두가지 일에 가장 관심이 많다. 그것은 사업 계좌에서 창출되는 수입과 영업 관리자들의 실적이다.

판매 VP => 영업 부사장

알렉스가 영업 관리자에게서 얻는 자료는 종종 엑셀 시트에 있다.

데이터는 너무 동적이어서 고객이 회의 직전에 비용을 지불했는지 여부에 따라 마지막 순간까지 변한다.

있나? => 있을까?

준비하기

Excel => 엑셀

1.

내용을 => 콘텐츠를

첫번째 슬라이드에서 서로 다른 계정의 매출액(revenue?)을 보여 주는 원형 차트를 만들어 백분율을 기반으로 비교한다.

4.

판매 관리자 => 영업 관리자

bar chart => 막대형 차트?

Python => 파이썬

그렇게 한다. => 한다.

명령을 => 커맨드를

<<중요표시시작>>

집합이 => API가

실행방법

Page 15.

2.

코드 조각을 => 코드를

Page 16.

3.

매주 => 주간?

이제 앞의 코드를 실행하면, 알렉스가 주간 판매 보고서에서 필요로 하는 모든 차트와 데이터를 가지고 파워포인트 프레젠테이션을 얻는다.

전자메일 => 이메일

두번째 슬라이드는 원형 차트로 계정 간의 수익 분포를 보여준다.

판매 관리자의 => 영업 관리자의

bar chart => 막대형 차트?

작동원리

위의 예제에서, 모든 판매 데이터를 포함하고 있는 엑셀 시트의 리더(reader) 객체인 Sales_Data.xlsx를 생성하는 것으로 시작했다.

기억하는지 모르겠지만, 샘플 프레젠테이션의 타이틀(제목?) 슬라이드에는 텍스트가 없다.

코드 조각에서 => 코드에서

제목 슬라이드 => 타이틀 슬라이드?

업데이트 했다. => 수정했다.

placeholders => 플레이스홀더

Excel => 엑셀

Price과 Quantity이라는 두 개의 열을 가지고 있는데, 그것은 판매된 노트북이나 소프트웨어 라이센스의 양과 단위당 가격을 나타낸다.

단지 총 매출액(total revenue figure)만을 필요로 하지는 않는다.

코드를 살펴보면, 데이터 프레임을 Account로 그룹화해서 total 데이터(수량 * 가격)를 합산하고, 알렉스가 모든 계정의 매출액을 전체 매출액의 백분율로 비교하기 쉽도록 원형 차트를 작성했다.

합계하고 => 합하고

플로팅 했다. => 나타냈다.

다시 말해, 차트가 파워포인트(PowerPoint)가 아닌 pandas에서만 사용할 수 있는 경우에는 유용하지 않으므로, 이 차트를 result.png의 PNG 파일 형식으로 저장한다.

마지막으로, add_picture() 메소드를 사용하여 이 그림 파일을 프리젠테이션에 추가했고, 그림이 잘 보이고 보기에 좋도록 사진의 좌표(coordinates)와 크기(size)를 관리했다.

알렉스는 또한 모든 영업 관리자들의 실적을 도표화할 필요가 있다.

그러나 이러한 문제에 대해 영업 관리자별로 데이터를 그룹화하고 각각의 데이터에 적용되는 총 매출액을 얻었다.

bar chart => 막대 차트?

6장의 레시피와 예제, 그리고 살펴봤던 사용 사례들로 즐거웠기를 희망한다.

여러분의 프레젠테이션을 자동화하기 위해서 여러분의 손이 근질거렸을 것이다.

언제 여러분의 책상에 들려서 작품을 감상하면 어떨까?

7장

Page 10.

7.

내용 => 콘텐츠

구성 => 설정?

올리는 => 포스팅하는

Page 12.

8.

전 세계의 적합한 청중을 대상으로 적합한 콘텐츠를 적시에 제공하는 자동 트윗이다. 만세!

작동원리

코드 조각에는 => 코드에는

tweet_config.py로 트윗의 콘텐츠와 일정을 지정하는데 사용되는 구성 딕셔너리를 포함한다.

구성을 보고 => 구성을 살펴보고

메시지가 있는지 여부를 => 메시지 여부를

반복 1(iteration 1)

현재 시간대의 => 시간대의

그것은 호주의 시간대인 시드니에서 8월 27일 13시 25분에 정확하게 트윗이 예정되어 있는 것을 발견한다.

게시 => 포스트?
시간이 일치해요, 그것은 트윗을 게시했다.

물론, 여기서 인용된 예제는 매우 조잡한 것이다.

하지만, 이것은 자동적으로 일정이 잡힌 트윗에 대한 요점을 일깨워 줄 수 있는 예제다.

이제 조이는 자고 있을 때만 트윗을 할 수 있는 것이 아니라, 다른 시간대와 다른 콘텐츠에 대한 트윗을 예약할 수도 있다.

당신은 => 여러분은

그래서 여러분이 올리는 모든 트윗이 페이스북에 올라오도록 계정에 맞게 앱을 구성한다.

Webhook 소개

Page 17.

2018.03.26

커스텀 이벤트이므로 액션이 정의되지 않았다.

Webhook => 웹훅

이 웹훅은 이벤트 user.signup에 대해 구성되었으며, 대상 URL은 http://localhost:8000/hook/으로 설정됐다.

첫번째 뷰 이벤트는 해당 사용자 및 이벤트에 대한 웹훅과 페이로드 전송을 담당했다.

전자 메일 => 이메일

더 알아보기

이 절에서는 API를 사용하는 웹 상의 다른 형태의 통합인 폴링과 웹훅을 살펴봤다. 

이전 레시피에서, 일반적인 방법으로 개념을 설명하기를 원하기 때문에 사용자 등록에 유용한 커스텀 이벤트를 다뤘다.

짧았으므로 => 간단해서

유스 케이스를 => 사용 사례를

우리가 그를 => 올리버를

웹훅의 리드 관리 자동화

그는 => 올리버는

주요 책임은 => 주요 업무는

전자 메일 => 이메일

CRM에 새 서명자의 리드 레코드 추가

이전에는 사이트에 가입하는 사람이 많지 않아 이 두 가지 작업을 수동으로 수행하기가 쉬웠다.

하지만 이 웹사이트의 인기가 증가함에 따라, 올리버는 매일 가입자 수의 급증을 목격하기 시작했다.

의심할 여지 없이, 올리버는 이것을 쉽게 자동화될 수 있는 매우 시간 소모적인 활동으로 생각한다.

전자 메일과 => 이메일과

Webhooks는 => 웹훅은

유스 케이스를 => 사용 사례를

어떻게 자동화할 수 있는지 => 자동화 할 수 있는 방법을

실행방법

Zapier => 재피어(Zapier)

터미널에서 Django 프로젝트의 루트 디렉터리로 이동하고 파이썬 manage.py 쉘 커맨드를 실행하여 DB 쉘에 로그인한다.

전자 메일 주소로 => 이메일 주소로

user => X

업데이트 한다. => 수정한다.

커맨드 세트를 => 커맨드를

Page 18.

2.

계정을 생성한 후 Choose App을 하기 위해 MAKE A ZAP!을 클릭하고, BUILT-IN APPS 절에서 Webhooks를 클릭한다.(확인)

3.

왼쪽의 => 왼쪽에서

TRIGGER 및 ACTION

4.

이 후 => 다음으로

사용자지정 => 커스텀

대상 URL로 사용된다.

6. 

Zapier => 재피어(Zapier)

8.

Send Email을 클릭하고 Zapier가 액세스하도록 허용하기 위해 이메일 계정을 활성화한다.

Page 19.

9.

우리의 => X

전자 메일 주소 => 이메일 주소

추가 => 대상 URL에 데이터를 게시하여 트리거를 이미 테스트한 경우, 이메일 템플릿의 모든 필드 오른쪽 맨 위에 옵션 집합이 표시될 것이다.

다음 두 개의 스크린샷에 To 필드에 Data Email, Subject 필드에 Welcome Data Username! 그리고 이메일 본문으로 Signup made our day!를 가진다.

필요한 ~ 구성했다.=> 삭제

10.

수신한 => 수신된

사용자이름 => 사용자 이름?

페이로드에서 => 페이로드의

전자 메일 템플릿은 => 이메일 템플릿은

전자 메일의 => 이메일의

11.

행동을 => 액션을

12.

이제 이메일을 확인하면, 재피어(Zapier)로부터 테스트 이메일을 수신했을 것이다.

전자 메일의 내용은 => 이메일의 콘텐츠는

Oliver => 올리버?

signee => ?

전자 메일 => 이메일

자동화한다. => 자동화할 것이다.

작동원리

Zapier => 재피어(Zapier)

Webhooks => 웹훅

Gmail => 지메일(Gmail)

Trello => 트렐로(Trello)

Slack => 슬랙(Slack)

방금 트리거로 웹훅을 생성하여 지메일(Gmail)의 액션으로 그것을 따랐다.

작업을 확인하고 => 액션을 확인하고

전자 메일을 => 이메일을

재피어는 또한 페이로드에서 데이터를 얻어 사용자의 이메일 주소로 이메일을 전송할 수 있을 만큼 똑똑하다.

공원에서 산책한다.

이렇게 하지 않았다면 이러한 모든 앱 및 작성 코드를 통해 제공되는 API를 이해하게 되고 제품 혹은 서비스의 핵심이 아닐 수 있는 활동이다.

자, 여러분!

이 자동화 부분이 재미있었기를 바라며, 조직에서 이 기능을 구현할 수 있을 것이라고 확신한다.

8장.

오, 봇이라고? 정말이니? 즐거움을 위해 봇을 만드는 것을 배울 것인가 아니면 비즈니스 사용 사례를 위해 봇을 만드는 것을 배울 것인가?

소개

웹사이트는 기업들이 영역을 확대하도록 도왔을 뿐만 아니라, 제품을 판매하는 것을 더 저렴하게(렌탈같은 고정 비용이 없다.) 만들었다.

결합되어보다 => 결합되어 보다

현재의 경영진들은 단지 잠재 고객들과 이야기를 나누고 제품을 사도록 안내하며 변화를 증가시킬 수 있다.

인공 지능(AI, artificial intelligence)

자유형 => 자유 형태

쿼리에 => 질의에

봇은 무엇인가?

더 자주하지 말고 => 대개

알고 있습니다. => 안다.

그럼 진짜 질문은 피자 헛 웹사이트에서 그것을 찾는데 왜 고통을 감수해야 할까?

Facebook => 페이스북

Facebook Messenger => 페이스북 메신져

챠트봇 => 챗봇

업데이트 => 수정

확인한다. => 살펴본다.

네, 사용 사례를 이해하지만, 챗봇이 정확히 무엇인가?

연구 활동을하고 => 연구 활동을 진행중이고

Page 2.

봇으 어떻게 작동하는가?




















