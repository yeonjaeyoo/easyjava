3. 네트워크 NIO 지원

3장에서는 자바의 NEW IO(NIO) 패키지의 버퍼 및 채널 클래스를 살펴볼 것이다. NIO는 JAVA IO API와 네트워크 API의 일부분에 대한 대안이다. NIO는 광범위하고 복잡한 주제이지만, 우리의 관심은 네트워크 애플리케이션에 대한 지원을 제공하는 방법이다.

다음과 같은 여러 주제를 살펴볼 것이다.

- 버퍼(buffer), 채널(channel) 및 셀렉터(selector) 사이의 자연스러운 관계
- 클라이언트/서버를 구축할 수 NIO 기술의 사용
- 여러 클라이언트를 처리하는 과정
- 비동기 소켓 채널을 지원
- 기본 버퍼 작업

NIO 패키지는 효율적인 네트워크 애플리케이션을 구축하기 위해 광범위한 지원을 제공한다.

자바 NIO

자바 NIO는 세 가지 핵심 클래스를 사용한다.

-버퍼: 읽거나 채널에 기록된 정보를 보유한다.
-채널: 이것은 데이터 소스(source)/싱크(sink)를 위한  비동기 읽기(read)/쓰기(write) 작업을 지원하는 스트림과 같은 기술이다.
-셀렉터: 이것은 싱글 스레드에서 다중 채널을 처리할 수 있는 메커니즘(mechanism)이다.

Page 58.

개념적으로, 버퍼와 채널은 데이터를 처리하기 위해 함께 작동한다. 다음 그림에 보여주는 바와 같이, 데이터는 버퍼 및 채널 간의 어느 방향으로 이동될 수 있다.

<그림>

버퍼는 데이터를 처리하기 위해 내부적으로 사용되는 반면, 채널은 일부 외부 데이터 소스에 연결된다. 채널과 버퍼는 여러 타입이 있다. 이들 중의 일부는 다음 표에 나열되어 있다.

다음은 채널에 대한 표이다.

채널 클래스 / 목적

FileChannel / 파일에 연결한다.
DatagramChannel / 데이타그램 소켓을 지원한다.
SocketChannel / 스트리밍 소켓을 지원한다.
ServerSocketChannel / 소켓 요청을 수신한다.
NetworkChannel / 네트워크 소켓을 지원한다.
AsynchronousSocketChannel / 비동기 스트리밍 소켓을 지원한다.

다음은 버퍼의 테이블이다.

버퍼 클래스 / 데이터 타입
<표 삽입>

2016.04.11

애플리케이션이 싱글 스레드를 사용하여 처리할 수 있는 많은 로우 트래픽 연결을 사용하는 경우 Selector 클래스는 유용하다. 이것은 각각의 접속을 위한 스레드를 생성하는 것보다 더 효율적이다. 이것은 또한 7장, '네트워크 확장성'에서 논의되는 애플리케이션이 더 확장하기 위해 사용되는 기술이다. 

Page 59.

3장에서는, 채널과 버퍼 간의 상호 작용을 설명하기 위해 클라이언트/서버 애플리케이션을 만들 것입니다. 이것은 단순한 타임 서버, 가변 길이의 메시지를 입증하는 채팅 서버, 서버는 하나의 다중 클라이언트를 처리하는 기술 및 비동기 서버를 예시하는 a parts server를 포함한다. 우리는 또한 대량 전송 및 뷰를 포함한 특별한 버퍼 기술을 검토할 것이다.

버퍼의 개요와 채널과 작동하는 방법에 대한 설명을 시작할 것이다.

버퍼 소개

버퍼는 채널로 이동되고 있기 때문에 일시적으로 데이터를 보유한다. 버퍼가 생성되면, 고정된 크기 혹은 용량으로 생성된다. 일부 혹은 모든 버퍼 메모리는 버퍼의 데이터를 관리할 수 있는 여러 Buffer 클래스 필드(field)로 이용될 수 있다.

Buffer 클래스는 추상적이다. 그러나 Buffer 클래스는 포함하는 버퍼를 조작하는 데 사용되는 기본적인 메소드를 가지고 있다.

-용량(capacity): 버퍼의 요소(element)의 수를 반환한다.
-제한(limit): 액세스 할 수 없는 버퍼의 최초의 인덱스를 반환한다.
-위치(position): 읽거나 사용할 수 있는 다음 요소의 인덱스를 반환한다.

요소는 버퍼 타입에 따라 달라진다.

mark 메소드와 reset 메소드는 버퍼 내의 위치를 제어할 수 있다. mark 메소드는 특정 위치에 버퍼 마크를 설정할 것이다. reset 메소드는 이전에 표시된 위치로 마크의 위치를 복원한다. 다음 코드는 다양한 버퍼 용어 간의 관계를 보여준다.

0 <= mark <= position <= limit <= capacity

버퍼는 직접 혹은 간접적 일 수 있다. 직접 버퍼(direct buffer)는 가능하면 네이티브 IO 메소드를 사용하려고 시도할 것이다. 직접 버퍼의 생성은 더 비싸지만 더 큰 메모리에서 더 큰 버퍼를 더 효율적으로 수행되는 경향이있다. allocateDirect 메소드는 직접 버퍼를 생성하기 위해 사용되고 버퍼의 사이즈를 지정하는 정수(integer)를 수용할 수 있다. allocate 메소드는 정수 크기 인수를 허용하지만, 간접 버퍼(non-direct buffer)를 생성한다.

간접 버퍼는 대부분의 작업에 대한 직접 버퍼로 효율적이지 않다. 그러나 간접 버퍼에 사용되는 메모리는 JVM 가비지 컬렉터에 의해 개선될 것이다. 반면에 직접 메모리 버퍼는 외부 JVM 통제가 될 지도 모른다. 이것은 메모리의 관리를 간접 버퍼와 함께 더 예측가능하게 한다.

Page 60.

채널 및 버퍼 간에 데이터를 전송하기 위해 사용되는 몇 가지 메소드가 있다. 다음 중 하나로서 분류될 수 있다.

- 절대적 혹은 상대적
- 대량 전송
- 기본 데이터 타입 사용
- 뷰(view) 지원
- 바이트 버퍼의 압축, 복제, 분해

많은 Buffer 클래스의 메소드는 인보케이션 체인(invocation chaining)을 지원한다. get 형태의 메서드는 버퍼로부터 정보를 검색하는 동안(?반면에), put 형태의 메소드는 데이터를 버퍼에 전송할 것이다. 예제에서는 광범위하게 get 메소드와 put 메소드를 사용할 것이다. 이러한 메소드는 한 번에 하나의 바이트를 전송할 것이다.

2016.04.14

이것들의 get과 put 메소드는 버퍼 내에서 현재 위치와 연관이 있다. 특정 버퍼 요소를 분리하기 위한 버퍼에 대한 인덱스를 사용하는 여러 절대 메소드가 있다.

대량의 데이터는 연속적인 데이터 블록으로 전송한다. 이러한 get과 put 메소드는 데이터를 저장하기 위해 자신의 인자의 하나로서 바이트의 배열을 사용한다. 대량 데이터 전송(Bulk data transfer) 절에서 논의된다.

Buffer 클래스 내의 모든 데이터가 동일한 타입일 때, Float 같은 특정 데이터 타입을 이용하여 데이터에 대한 편리한 접속을 가능하게하는 뷰(view)가 생성 될 수 있다. 뷰 절을 사용하여 이 버퍼를 논의할 것이다.

압축(Compacting), 복제(duplicating), 슬라이스 타입 조작(slicing type operations)이 지원된다.

2016.04.15

압축 작업은 이미 처리된 데이터를 제거하기 위해 버퍼의 내용을 이동한다. 슬라이싱(slicing)은 원시 버퍼의 전부 혹은 일부에 기초하는 새로운 버퍼를 생성하는 동안, 중복(Duplication)은 버퍼의 사본을 만들 것이다. 하나의 버퍼의 변경 사항은 다른 버퍼에 적용된다. 그러나, 각 버퍼의 위치(position), 제한(limit), 시장 가치(mark values)는 독립적이다.

버퍼의 생성으로 시작하는 작업에서 버퍼를 확인하자.

시간 서버와 채널 사용

1장, '네트워크 프로그래밍 시작하기'에서 소개된 시간 서버와 클라이언트는 버퍼와 채널의 사용을 보여주기 위해 여기에 구현될 것이다. 이러한 애플리케이션은 간단하지만, 버퍼와 채널을 함께 사용할 수 있는 방법을 보여준다. 먼저 서버를 생성하여 시작하고 그 후 서버를 사용하는 클라이언트를 생성한다.

Page 61.

타임 서버 생성

다음 코드는 타임 서버에서 사용하는 ServerSocketChannelTimeServer 클래스의 초기 선언이다. ServerSocketChannel 클래스의 open 메소드는 ServerSocketChannel 인스턴스를 생성한다. socket 메소드는 채널에서 사용하는 ServerSocket 인스턴스를 탐색한다. bind 메소드는 포트 5000으로 서버 소켓을 연결한다. ServerSocketChannel 클래스는 close 메소드가 있지만, try-with-resources 블록을 사용하는 것이 더 쉽다.

<소스>

서버는 클라이언트에서 요청을 수신할 때까지 accept 메소드 블록이 발생하는 곳의 무한 루프에 입력될 것이다. 이 경우, SocketChannel 인스턴스가 반환된다.

<소스>

인스턴스가 null이 아니라고 가정하면, 현재 일자와 시간을 포함하는 스트링(string)이 생성된다.

<소스>

Page 62.

ByteBuffer 인스턴스는 64 바이트의 크기로 생성된다. 대부분의 메시지 길이보다 더 긴 크기이다. put 메소드는 버퍼에 데이터를 이동한다. 이것은 대량 데이터 전송 동작이다. 버퍼 크기가 충분하지 않으면, BufferOverflowException 예외가 발생한다.

<소스>

채널의 쓰기 작업에 사용할 수 있도록 flip 메소드를 호출해야 한다. 이것은 설정의 효과를 갖는다. 제한(limit)은 현재의 위치와 위치의 값을 0으로 설정된다.(the limit is set to the current position and the position to zero.) while 루프는 각 바이트를 작성하기 위해 사용되며 hasRemaining 메소드에 의해 결정된 바와 같이 더이상 사용할 바이트가 없을 때 종료한다. 마지막 동작은 클라이언트에 전송되는 메시지를 표시하는 것이다.

<소스>

서버가 시작되면, 다음과 유사한 출력을 표시한다.

Time Server started
Waiting for request ...

바로 클라이언트를 생성할 준비가 됐다.

타임 클라이언트 생성

클라이언트는 다음에 정의된 SocketChannelTimeClient 클래스에서 구현된다. 예제를 단순화하기 위해, 클라이언트는 서버와 같은 머신으로 가정한다. SocketAddress 인스턴스는 IP 주소 127.0.0.1를 사용하여 생성되고, 포트는 5000으로 연결된다. SocketChannel 클래스의 open 메소드는 try-with-resources 블록 내에서 서버의 응답을 처리하기 위해 사용되는 SocketChannel 인스턴스를 반환한다.

<소스>

2016.04.18

Page 64.

채팅 서버

서버를 시작한다. 서버는 다음에 정의된 ChatServer 클래스에 정의되어 있다. ServerSocketChannel 인스턴스는 생성되고 포트 5000에 바인딩된다. 그것은 while 루프의 본문에 사용될 것이다. 실행 변수는 서버의 실행시간을 제어한다. 필요에 따라 예외(Exceptions)가 발생한다. 이전의 서버로서, 클라이언트가 서버에 연결될 때까지 서버는 accept 메소드로 블록될 것이다.

<소스>

Page 65.

이 채팅/서버 애플리케이션에서는 통신이 제한된다. 접속이 이루어지면, 서버는 사용자에게 클라이언트에 송신하기 위한 메시지를 표시한다. 이 메시지가 수신될 때까지 클라이언트가 대기하고, 이 응답에 대하여 사용자에게 메시지가 표시된다. 응답은 다시 서버로 전송된다. 이 시퀀스는 채널/버퍼의 상호 작용에 초점을 맞추기 위한 상호 작용을 단순화하기 위해 제한된다.

연결이되면, 서버는 결과에 대한 메시지를 표시한 후 다음과 같이 루프로 들어간다. 사용자는 메시지를 입력하라고 표시된다. sendFixedLengthMessage 메서드가 호출된다. 사용자가 quit를 입력하면, 종료 메시지를 서버로 전송하고 서버는 종료된다. 그렇지 않으면, 메시지는 서버에 전송하고, 서버는 클라이언트가 응답하기 위해 기다리기 위한 receiveFixedLengthMessage 메소드에서 블록된다.

<소스>

서버가 시작되면 다음과 같은 출력을 보여준다.

Chat Server started
Waiting for request ...

서버를 생성함으로서, 클라이언트 애플리케이션을 살펴보자.

Page 66.

채팅 클라이언트

클라이언트 애플리케이션은 다음에 정의된 ChatClient 클래스를 사용한다. 그 구조는 이전의 클라이언트 애플리케이션과 유사하다. 로컬호스트(127.0.0.1)는 포트 번호 5000과 함께 사용된다. 연결이 완료되면, 프로그램은 무한 루프로 진입하고 서버가 메시지를 전송하도록 기다린다.

<소스>

서버는 메시지를 보낼 때까지. 루프 내에서 프로그램은 receiveFixedLengthMessage 메소드에서 블록한다. 메시지는 표시되고, 사용자에게 서버로 재 전송되는 메시지가 표시된다. 메시지에 quit가 입력되면, sendFixedLengthMessage 메소드를 사용하여 서버에 전송하고, 애플리케이션은 종료된다. 그렇지 않으면 메시지는 서버로 전송되고, 프로그램은 그 외 메시지를 기다린다.

<소스>

Page 67.

클라이언트와 서버가 생성하고, 상호 작용하는 방법을 살펴본다.

서버/클라이언트 상호 작용

서버가 시작하면, 클라이언트 애플리케이션을 시작한다.

다음과 같은 클라이언트의 출력을 보여줄 것이다.

Connected to Chat Server
Waiting for message from the server ...

서버 출력은 이 연결을 반영한다.

Chat Server started
Waiting for request ...
Connected to Client
>

Hello를 입력한다. 

