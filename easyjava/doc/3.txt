3. 네트워크 NIO 지원

3장에서는 자바의 NEW IO(NIO) 패키지의 버퍼 및 채널 클래스를 살펴볼 것이다. NIO는 JAVA IO API와 네트워크 API의 일부분에 대한 대안이다. NIO는 광범위하고 복잡한 주제이지만, 우리의 관심은 네트워크 애플리케이션에 대한 지원을 제공하는 방법이다.

다음과 같은 여러 주제를 살펴볼 것이다.

- 버퍼(buffer), 채널(channel) 및 셀렉터(selector) 사이의 자연스러운 관계
- 클라이언트/서버를 구축할 수 NIO 기술의 사용
- 여러 클라이언트를 처리하는 과정
- 비동기 소켓 채널을 지원
- 기본 버퍼 작업

NIO 패키지는 효율적인 네트워크 애플리케이션을 구축하기 위해 광범위한 지원을 제공한다.

자바 NIO

자바 NIO는 세 가지 핵심 클래스를 사용한다.

-버퍼: 읽거나 채널에 기록된 정보를 보유한다.
-채널: 이것은 데이터 소스(source)/싱크(sink)를 위한  비동기 읽기(read)/쓰기(write) 작업을 지원하는 스트림과 같은 기술이다.
-셀렉터: 이것은 싱글 스레드에서 다중 채널을 처리할 수 있는 메커니즘(mechanism)이다.

Page 58.

개념적으로, 버퍼와 채널은 데이터를 처리하기 위해 함께 작동한다. 다음 그림에 보여주는 바와 같이, 데이터는 버퍼 및 채널 간의 어느 방향으로 이동될 수 있다.

<그림>

버퍼는 데이터를 처리하기 위해 내부적으로 사용되는 반면, 채널은 일부 외부 데이터 소스에 연결된다. 채널과 버퍼는 여러 타입이 있다. 이들 중의 일부는 다음 표에 나열되어 있다.

다음은 채널에 대한 표이다.

채널 클래스 / 목적

FileChannel / 파일에 연결한다.
DatagramChannel / 데이타그램 소켓을 지원한다.
SocketChannel / 스트리밍 소켓을 지원한다.
ServerSocketChannel / 소켓 요청을 수신한다.
NetworkChannel / 네트워크 소켓을 지원한다.
AsynchronousSocketChannel / 비동기 스트리밍 소켓을 지원한다.

다음은 버퍼의 테이블이다.

버퍼 클래스 / 데이터 타입
<표 삽입>

2016.04.11

애플리케이션이 싱글 스레드를 사용하여 처리할 수 있는 많은 로우 트래픽 연결을 사용하는 경우 Selector 클래스는 유용하다. 이것은 각각의 접속을 위한 스레드를 생성하는 것보다 더 효율적이다. 이것은 또한 7장, '네트워크 확장성'에서 논의되는 애플리케이션이 더 확장하기 위해 사용되는 기술이다. 

Page 59.

3장에서는, 채널과 버퍼 간의 상호 작용을 설명하기 위해 클라이언트/서버 애플리케이션을 만들 것입니다. 이것은 단순한 타임 서버, 가변 길이의 메시지를 입증하는 채팅 서버, 서버는 하나의 다중 클라이언트를 처리하는 기술 및 비동기 서버를 예시하는 a parts server를 포함한다. 우리는 또한 대량 전송 및 뷰를 포함한 특별한 버퍼 기술을 검토할 것이다.

버퍼의 개요와 채널과 작동하는 방법에 대한 설명을 시작할 것이다.

버퍼 소개

버퍼는 채널로 이동되고 있기 때문에 일시적으로 데이터를 보유한다. 버퍼가 생성되면, 고정된 크기 혹은 용량으로 생성된다. 일부 혹은 모든 버퍼 메모리는 버퍼의 데이터를 관리할 수 있는 여러 Buffer 클래스 필드(field)로 이용될 수 있다.

Buffer 클래스는 추상적이다. 그러나 Buffer 클래스는 포함하는 버퍼를 조작하는 데 사용되는 기본적인 메소드를 가지고 있다.

-용량(capacity): 버퍼의 요소(element)의 수를 반환한다.
-제한(limit): 액세스 할 수 없는 버퍼의 최초의 인덱스를 반환한다.
-위치(position): 읽거나 사용할 수 있는 다음 요소의 인덱스를 반환한다.

요소는 버퍼 타입에 따라 달라진다.

mark 메소드와 reset 메소드는 버퍼 내의 위치를 제어할 수 있다. mark 메소드는 특정 위치에 버퍼 마크를 설정할 것이다. reset 메소드는 이전에 표시된 위치로 마크의 위치를 복원한다. 다음 코드는 다양한 버퍼 용어 간의 관계를 보여준다.

0 <= mark <= position <= limit <= capacity

버퍼는 직접 혹은 간접적 일 수 있다. 직접 버퍼(direct buffer)는 가능하면 네이티브 IO 메소드를 사용하려고 시도할 것이다. 직접 버퍼의 생성은 더 비싸지만 더 큰 메모리에서 더 큰 버퍼를 더 효율적으로 수행되는 경향이있다. allocateDirect 메소드는 직접 버퍼를 생성하기 위해 사용되고 버퍼의 사이즈를 지정하는 정수(integer)를 수용할 수 있다. allocate 메소드는 정수 크기 인수를 허용하지만, 간접 버퍼(non-direct buffer)를 생성한다.

간접 버퍼는 대부분의 작업에 대한 직접 버퍼로 효율적이지 않다. 그러나 간접 버퍼에 사용되는 메모리는 JVM 가비지 컬렉터에 의해 개선될 것이다. 반면에 직접 메모리 버퍼는 외부 JVM 통제가 될 지도 모른다. 이것은 메모리의 관리를 간접 버퍼와 함께 더 예측가능하게 한다.

Page 60.

채널 및 버퍼 간에 데이터를 전송하기 위해 사용되는 몇 가지 메소드가 있다. 다음 중 하나로서 분류될 수 있다.

- 절대적 혹은 상대적
- 대량 전송
- 기본 데이터 타입 사용
- 뷰(view) 지원
- 바이트 버퍼의 압축, 복제, 분해

많은 Buffer 클래스의 메소드는 인보케이션 체인(invocation chaining)을 지원한다. get 형태의 메서드는 버퍼로부터 정보를 검색하는 동안(?반면에), put 형태의 메소드는 데이터를 버퍼에 전송할 것이다. 예제에서는 광범위하게 get 메소드와 put 메소드를 사용할 것이다. 이러한 메소드는 한 번에 하나의 바이트를 전송할 것이다.


