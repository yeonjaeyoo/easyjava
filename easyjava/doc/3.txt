3. 네트워크 NIO 지원

3장에서는 자바의 NEW IO(NIO) 패키지의 버퍼 및 채널 클래스를 살펴볼 것이다. NIO는 JAVA IO API와 네트워크 API의 일부분에 대한 대안이다. NIO는 광범위하고 복잡한 주제이지만, 우리의 관심은 네트워크 애플리케이션에 대한 지원을 제공하는 방법이다.

다음과 같은 여러 주제를 살펴볼 것이다.

- 버퍼(buffer), 채널(channel) 및 셀렉터(selector) 사이의 자연스러운 관계
- 클라이언트/서버를 구축할 수 NIO 기술의 사용
- 여러 클라이언트를 처리하는 과정
- 비동기 소켓 채널을 지원
- 기본 버퍼 작업

NIO 패키지는 효율적인 네트워크 애플리케이션을 구축하기 위해 광범위한 지원을 제공한다.

자바 NIO

자바 NIO는 세 가지 핵심 클래스를 사용한다.

-버퍼: 읽거나 채널에 기록된 정보를 보유한다.
-채널: 이것은 데이터 소스(source)/싱크(sink)를 위한  비동기 읽기(read)/쓰기(write) 작업을 지원하는 스트림과 같은 기술이다.
-셀렉터: 이것은 싱글 스레드에서 다중 채널을 처리할 수 있는 메커니즘(mechanism)이다.

Page 58.

개념적으로, 버퍼와 채널은 데이터를 처리하기 위해 함께 작동한다. 다음 그림에 보여주는 바와 같이, 데이터는 버퍼 및 채널 간의 어느 방향으로 이동될 수 있다.

<그림>

버퍼는 데이터를 처리하기 위해 내부적으로 사용되는 반면, 채널은 일부 외부 데이터 소스에 연결된다. 채널과 버퍼는 여러 타입이 있다. 이들 중의 일부는 다음 표에 나열되어 있다.

다음은 채널에 대한 표이다.

채널 클래스 / 목적

FileChannel / 파일에 연결한다.
DatagramChannel / 데이타그램 소켓을 지원한다.
SocketChannel / 스트리밍 소켓을 지원한다.
ServerSocketChannel / 소켓 요청을 수신한다.
NetworkChannel / 네트워크 소켓을 지원한다.
AsynchronousSocketChannel / 비동기 스트리밍 소켓을 지원한다.

다음은 버퍼의 테이블이다.

버퍼 클래스 / 데이터 타입
<표 삽입>

2016.04.11

애플리케이션이 싱글 스레드를 사용하여 처리할 수 있는 많은 로우 트래픽 연결을 사용하는 경우 Selector 클래스는 유용하다. 이것은 각각의 접속을 위한 스레드를 생성하는 것보다 더 효율적이다. 이것은 또한 7장, '네트워크 확장성'에서 논의되는 애플리케이션이 더 확장하기 위해 사용되는 기술이다. 

Page 59.

3장에서는, 채널과 버퍼 간의 상호 작용을 설명하기 위해 클라이언트/서버 애플리케이션을 만들 것입니다. 이것은 단순한 타임 서버, 가변 길이의 메시지를 입증하는 채팅 서버, 서버는 하나의 다중 클라이언트를 처리하는 기술 및 비동기 서버를 예시하는 a parts server를 포함한다. 우리는 또한 대량 전송 및 뷰를 포함한 특별한 버퍼 기술을 검토할 것이다.

버퍼의 개요와 채널과 작동하는 방법에 대한 설명을 시작할 것이다.

버퍼 소개

버퍼는 채널로 이동되고 있기 때문에 일시적으로 데이터를 보유한다. 버퍼가 생성되면, 고정된 크기 혹은 용량으로 생성된다. 일부 혹은 모든 버퍼 메모리는 버퍼의 데이터를 관리할 수 있는 여러 Buffer 클래스 필드(field)로 이용될 수 있다.

Buffer 클래스는 추상적이다. 그러나 Buffer 클래스는 포함하는 버퍼를 조작하는 데 사용되는 기본적인 메소드를 가지고 있다.

-용량(capacity): 버퍼의 요소(element)의 수를 반환한다.
-제한(limit): 액세스 할 수 없는 버퍼의 최초의 인덱스를 반환한다.
-위치(position): 읽거나 사용할 수 있는 다음 요소의 인덱스를 반환한다.

요소는 버퍼 타입에 따라 달라진다.

mark 메소드와 reset 메소드는 버퍼 내의 위치를 제어할 수 있다. mark 메소드는 특정 위치에 버퍼 마크를 설정할 것이다. reset 메소드는 이전에 표시된 위치로 마크의 위치를 복원한다. 다음 코드는 다양한 버퍼 용어 간의 관계를 보여준다.

0 <= mark <= position <= limit <= capacity

버퍼는 직접 혹은 간접적 일 수 있다. 직접 버퍼(direct buffer)는 가능하면 네이티브 IO 메소드를 사용하려고 시도할 것이다. 직접 버퍼의 생성은 더 비싸지만 더 큰 메모리에서 더 큰 버퍼를 더 효율적으로 수행되는 경향이있다. allocateDirect 메소드는 직접 버퍼를 생성하기 위해 사용되고 버퍼의 사이즈를 지정하는 정수(integer)를 수용할 수 있다. allocate 메소드는 정수 크기 인수를 허용하지만, 간접 버퍼(non-direct buffer)를 생성한다.

간접 버퍼는 대부분의 작업에 대한 직접 버퍼로 효율적이지 않다. 그러나 간접 버퍼에 사용되는 메모리는 JVM 가비지 컬렉터에 의해 개선될 것이다. 반면에 직접 메모리 버퍼는 외부 JVM 통제가 될 지도 모른다. 이것은 메모리의 관리를 간접 버퍼와 함께 더 예측가능하게 한다.

Page 60.

채널 및 버퍼 간에 데이터를 전송하기 위해 사용되는 몇 가지 메소드가 있다. 다음 중 하나로서 분류될 수 있다.

- 절대적 혹은 상대적
- 대량 전송
- 기본 데이터 타입 사용
- 뷰(view) 지원
- 바이트 버퍼의 압축, 복제, 분해

많은 Buffer 클래스의 메소드는 인보케이션 체인(invocation chaining)을 지원한다. get 형태의 메서드는 버퍼로부터 정보를 검색하는 동안(?반면에), put 형태의 메소드는 데이터를 버퍼에 전송할 것이다. 예제에서는 광범위하게 get 메소드와 put 메소드를 사용할 것이다. 이러한 메소드는 한 번에 하나의 바이트를 전송할 것이다.

2016.04.14

이것들의 get과 put 메소드는 버퍼 내에서 현재 위치와 연관이 있다. 특정 버퍼 요소를 분리하기 위한 버퍼에 대한 인덱스를 사용하는 여러 절대 메소드가 있다.

대량의 데이터는 연속적인 데이터 블록으로 전송한다. 이러한 get과 put 메소드는 데이터를 저장하기 위해 자신의 인자의 하나로서 바이트의 배열을 사용한다. 대량 데이터 전송(Bulk data transfer) 절에서 논의된다.

Buffer 클래스 내의 모든 데이터가 동일한 타입일 때, Float 같은 특정 데이터 타입을 이용하여 데이터에 대한 편리한 접속을 가능하게하는 뷰(view)가 생성 될 수 있다. 뷰 절을 사용하여 이 버퍼를 논의할 것이다.

압축(Compacting), 복제(duplicating), 슬라이스 타입 조작(slicing type operations)이 지원된다.

2016.04.15

압축 작업은 이미 처리된 데이터를 제거하기 위해 버퍼의 내용을 이동한다. 슬라이싱(slicing)은 원시 버퍼의 전부 혹은 일부에 기초하는 새로운 버퍼를 생성하는 동안, 중복(Duplication)은 버퍼의 사본을 만들 것이다. 하나의 버퍼의 변경 사항은 다른 버퍼에 적용된다. 그러나, 각 버퍼의 위치(position), 제한(limit), 시장 가치(mark values)는 독립적이다.

버퍼의 생성으로 시작하는 작업에서 버퍼를 확인하자.

시간 서버와 채널 사용

1장, '네트워크 프로그래밍 시작하기'에서 소개된 시간 서버와 클라이언트는 버퍼와 채널의 사용을 보여주기 위해 여기에 구현될 것이다. 이러한 애플리케이션은 간단하지만, 버퍼와 채널을 함께 사용할 수 있는 방법을 보여준다. 먼저 서버를 생성하여 시작하고 그 후 서버를 사용하는 클라이언트를 생성한다.

Page 61.

타임 서버 생성

다음 코드는 타임 서버에서 사용하는 ServerSocketChannelTimeServer 클래스의 초기 선언이다. ServerSocketChannel 클래스의 open 메소드는 ServerSocketChannel 인스턴스를 생성한다. socket 메소드는 채널에서 사용하는 ServerSocket 인스턴스를 탐색한다. bind 메소드는 포트 5000으로 서버 소켓을 연결한다. ServerSocketChannel 클래스는 close 메소드가 있지만, try-with-resources 블록을 사용하는 것이 더 쉽다.

<소스>

서버는 클라이언트에서 요청을 수신할 때까지 accept 메소드 블록이 발생하는 곳의 무한 루프에 입력될 것이다. 이 경우, SocketChannel 인스턴스가 반환된다.

<소스>

인스턴스가 null이 아니라고 가정하면, 현재 일자와 시간을 포함하는 스트링(string)이 생성된다.

<소스>

Page 62.

ByteBuffer 인스턴스는 64 바이트의 크기로 생성된다. 대부분의 메시지 길이보다 더 긴 크기이다. put 메소드는 버퍼에 데이터를 이동한다. 이것은 대량 데이터 전송 동작이다. 버퍼 크기가 충분하지 않으면, BufferOverflowException 예외가 발생한다.

<소스>

채널의 쓰기 작업에 사용할 수 있도록 flip 메소드를 호출해야 한다. 이것은 설정의 효과를 갖는다. 제한(limit)은 현재의 위치와 위치의 값을 0으로 설정된다.(the limit is set to the current position and the position to zero.) while 루프는 각 바이트를 작성하기 위해 사용되며 hasRemaining 메소드에 의해 결정된 바와 같이 더이상 사용할 바이트가 없을 때 종료한다. 마지막 동작은 클라이언트에 전송되는 메시지를 표시하는 것이다.

<소스>

서버가 시작되면, 다음과 유사한 출력을 표시한다.

Time Server started
Waiting for request ...

바로 클라이언트를 생성할 준비가 됐다.

타임 클라이언트 생성

클라이언트는 다음에 정의된 SocketChannelTimeClient 클래스에서 구현된다. 예제를 단순화하기 위해, 클라이언트는 서버와 같은 머신으로 가정한다. SocketAddress 인스턴스는 IP 주소 127.0.0.1를 사용하여 생성되고, 포트는 5000으로 연결된다. SocketChannel 클래스의 open 메소드는 try-with-resources 블록 내에서 서버의 응답을 처리하기 위해 사용되는 SocketChannel 인스턴스를 반환한다.

<소스>

2016.04.18

Page 64.

채팅 서버

서버를 시작한다. 서버는 다음에 정의된 ChatServer 클래스에 정의되어 있다. ServerSocketChannel 인스턴스는 생성되고 포트 5000에 바인딩된다. 그것은 while 루프의 본문에 사용될 것이다. 실행 변수는 서버의 실행시간을 제어한다. 필요에 따라 예외(Exceptions)가 발생한다. 이전의 서버로서, 클라이언트가 서버에 연결될 때까지 서버는 accept 메소드로 블록될 것이다.

<소스>

Page 65.

이 채팅/서버 애플리케이션에서는 통신이 제한된다. 접속이 이루어지면, 서버는 사용자에게 클라이언트에 송신하기 위한 메시지를 표시한다. 이 메시지가 수신될 때까지 클라이언트가 대기하고, 이 응답에 대하여 사용자에게 메시지가 표시된다. 응답은 다시 서버로 전송된다. 이 시퀀스는 채널/버퍼의 상호 작용에 초점을 맞추기 위한 상호 작용을 단순화하기 위해 제한된다.

연결이되면, 서버는 결과에 대한 메시지를 표시한 후 다음과 같이 루프로 들어간다. 사용자는 메시지를 입력하라고 표시된다. sendFixedLengthMessage 메서드가 호출된다. 사용자가 quit를 입력하면, 종료 메시지를 서버로 전송하고 서버는 종료된다. 그렇지 않으면, 메시지는 서버에 전송하고, 서버는 클라이언트가 응답하기 위해 기다리기 위한 receiveFixedLengthMessage 메소드에서 블록된다.

<소스>

서버가 시작되면 다음과 같은 출력을 보여준다.

Chat Server started
Waiting for request ...

서버를 생성함으로서, 클라이언트 애플리케이션을 살펴보자.

Page 66.

채팅 클라이언트

클라이언트 애플리케이션은 다음에 정의된 ChatClient 클래스를 사용한다. 그 구조는 이전의 클라이언트 애플리케이션과 유사하다. 로컬호스트(127.0.0.1)는 포트 번호 5000과 함께 사용된다. 연결이 완료되면, 프로그램은 무한 루프로 진입하고 서버가 메시지를 전송하도록 기다린다.

<소스>

서버는 메시지를 보낼 때까지. 루프 내에서 프로그램은 receiveFixedLengthMessage 메소드에서 블록한다. 메시지는 표시되고, 사용자에게 서버로 재 전송되는 메시지가 표시된다. 메시지에 quit가 입력되면, sendFixedLengthMessage 메소드를 사용하여 서버에 전송하고, 애플리케이션은 종료된다. 그렇지 않으면 메시지는 서버로 전송되고, 프로그램은 그 외 메시지를 기다린다.

<소스>

Page 67.

클라이언트와 서버가 생성하고, 상호 작용하는 방법을 살펴본다.

서버/클라이언트 상호 작용

서버가 시작하면, 클라이언트 애플리케이션을 시작한다.

다음과 같은 클라이언트의 출력을 보여줄 것이다.

Connected to Chat Server
Waiting for message from the server ...

서버 출력은 이 연결을 반영한다.

Chat Server started
Waiting for request ...
Connected to Client
>

2016.04.19

Hello를 입력한다. 그러면 다음과 같은 출력을 확인할 것이다.

> Hello
Sent: Hello
Waiting for message from client ...

클라이언트는 지금 표시될 것이다.

Message: Hello
> 

Hi!라고 응답을 입력한다. 다음과 같이 클라이언트 출력이 표시될 것이다.

> Hi!
Sent: Hi!
Waiting for message from the server ...

Page 68.

서버는 표시된다.

Message: Hi!
> 

어느 한쪽이 quit 커맨드를 입력할 때까지이 과정을 계속할 수 있다. 그러나 64 바이트 버퍼 제한을 초과하는 메시지가 입력되면 BufferOverflowException 예외가 발생할 것이다. sendFixedLengthMessage 메소드를 sendMessage 메소드로 교체하고 receiveFixedLengthMessage 메소드를 receiveMessage 메소드로 교체하면 이 문제를 예방할 수 있다.

이러한 send 및 receive 작업하는 방법을 살펴 보자.

HelperMethods 클래스

HelperMethods 클래스는 다음과 같이 정의된다. 이전에 사용된 send 메소드와 receive 메소드를 소유한다. 이러한 메소드들은 쉽게 접속할 수 있도록 정적(static)으로 선언된다.

<소스>

고정된 길이의 메시지 메소드는 다음과 같다. 그들은 본질적으로 '채널을 사용한 타임 서버(Using channels with a time server)' 절에서 사용된 접근과 동일한 방법을 수행한다.

<소스>

Page 69.

가변 길이의 메시지 처리

가변 길이 메시지를 처리하는 기술은 이 절에서 설명한다. 가변 길이 메시지의 문제점은 메시지의 길이를 알 수 없다는 것이다. 버퍼가 완전히 차지 않을 때 메시지의 끝에 도달된 것으로 가정할 수 없다. 대부분의 메시지와 함께 참(true)일 수 있지만, 메시지 길이가 메시지 버퍼와 동일한 크기인 경우, 메시지의 끝을 놓칠 수있다.

메시지의 끝에 도달한 때를 결정하는 또 다른 방법은 메시지의 prefix로 메시지 길이를 전송하거나 메시지의 끝에 특별한 종료 문자를 추가한다. 여기서는 후자의 방법을 선택한다.

<<박스 시작>>
이 예제는 ASCII 문자에서 작동한다. 유니코드 문자가 대신 사용된다면, BufferOverflowException 예외가 발생될 것이다. CharBuffer 클래스는 캐릭터(character) 데이터에 사용되고 ByteBuffer 클래스와 유사한 기능을 제공한다. CharBuffer 클래스는 http://docs.oracle.com/javase/8/docs/api/java/nio/CharBuffer.html에 자세히 설명되어 있다.
<<박스 끝>>

0x00의 값은 메시지의 끝을 표시하기 위해 사용되었다. 그것은 인쇄되지 않고 종종 C 같은 언어에서 스트링은 내부적으로 종료하는 방법에 대응하도록 발생하기 때문에  우리는 그것이 사용자에 의해 실수로 쉽게 입력되지 않기 때문에 이 값을 선택했다.

sendMessage 메소드에서 전송되기 전에, put 메소드는 메시지의 끝에 종료 바이트를 추가한다. 버퍼 크기는 메시지 길이의 플러스 하나다.(The buffer size is the length of the message plus one.)

<소스>

2016.04.20 

Page 70.

receiveMessage 메소드에서, 수신된 각각의 바이트가 종료 바이트 있는지를 체크한다. 이 경우, 메시지는 반환된다. 우리가 메시지의 일부를 추출 한 후 clear 메소드는 ByteBuffer 변수에 적용된다. 이 메소드는 필수적이다. 그렇지 않으면, read 메소드는 0을 반환할 것이다. 이 메소드는 다시 0으로 버퍼 위치와 용량에 제한을 설정한다.

<소스>

이제 애플리케이션을 보여줄 준비가 됐다.

Page 71.

채팅 서버/클라이언트 애플리케이션 실행

처음 서버를 실행한다. 다음과 같이 출력이 표시된다.

Chat Server started
Waiting for request ...

다음으로, 클라이언트를 시작하면 다음과 같은 결과를 보여준다.

Connected to Chat Server
Waiting for message from the server ...

2016.04.21 

이러한 사용자는 서버와 클라이언트 간에 상호작용이 발생되고 현재 구현에 한계가 있다. 두 애플리케이션이 시작되었을 때, 클라이언트는 서버로부터의 메시지를 대기할 것이다. 다음과 같이 서버 창에 의해 반영된다.

Chat Server started
Waiting for request ...
Connected to Client
> 

메시지가 입력되면, 클라이언트에게 전송된다. Hello 메시지를 입력한다. 다음과 같이 클라이언트 창에서는 메시지를 표시하지 않을 것이다.

Connected to Chat Server
Waiting for message from the server ...
Message: Hello
> 

서버에서는 다음과 같은 결과가 나타날 것이다.

Sent: Hello
Waiting for message from client ...

이제 클라이언트에서 서버로 메시지를 보낼 수 있다. quit 메시지가 어느 애플리케이션에서 전송될 때까지 이 상황에서 메시지는 상호작용 할 수 있다.

Page 72.

다중 클라이언트 처리

스레드를 사용하여 다중 클라이언트를 처리할 수 있다. 이번 절에서, 간단한 부분 서버와 클라이언트 애플리케이션을 개발할 것이다. 서버는 각 클라이언트를 처리하는 별도의 스레드를 사용할 것이다. 이러한 기술은 구현하기는 것이 단순하지만, 항상 지나친 요청에는 적합하지 않을 것이다. 7장, '네트워크 확장성'에서는 멀티타스크를 대체하는 기술을 살펴볼 것이다.

2016.04.22

부품 서버는 PartsServer 클래스에서 구현되고, 클라이언트는 PartsClient 클래스에서 구현된다. ClientHandler 클래스의 새로운 인스턴스는 각 클라이언트에서 생성될 것이다. 이 핸들러는 일부의 가격에 대한 요청을 받아들일 것이다. 클라이언트는 핸들러에게 부분의 이름을 보낼 것이다. 핸들러는 PartsServer의 getPrice 메소드를 사용하여 부품의 가격을 찾을 것이다. 이 후 클라이언트에게 가격을 반환할 것이다.

부품 서버(parts server)

부품 서버는 부품에 대한 정보를 저장하기 위해 HashMap 변수를 사용한다. 일부의 이름은 키(key)로서 사용되며, 이 값은 Float 오브젝트로서 저장된다. PartsServer 클래스는 여기에 선언된다.


