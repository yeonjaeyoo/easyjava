3. 네트워크 NIO 지원

3장에서는 자바의 NEW IO(NIO) 패키지의 버퍼 및 채널 클래스를 살펴볼 것이다. NIO는 JAVA IO API와 네트워크 API의 일부분에 대한 대안이다. NIO는 광범위하고 복잡한 주제이지만, 우리의 관심은 네트워크 애플리케이션에 대한 지원을 제공하는 방법이다.

다음과 같은 여러 주제를 살펴볼 것이다.

- 버퍼(buffer), 채널(channel) 및 셀렉터(selector) 사이의 자연스러운 관계
- 클라이언트/서버를 구축할 수 NIO 기술의 사용
- 여러 클라이언트를 처리하는 과정
- 비동기 소켓 채널을 지원
- 기본 버퍼 작업

NIO 패키지는 효율적인 네트워크 애플리케이션을 구축하기 위해 광범위한 지원을 제공한다.

자바 NIO

자바 NIO는 세 가지 핵심 클래스를 사용한다.

-버퍼: 읽거나 채널에 기록된 정보를 보유한다.
-채널: 이것은 데이터 소스(source)/싱크(sink)를 위한  비동기 읽기(read)/쓰기(write) 작업을 지원하는 스트림과 같은 기술이다.
-셀렉터: 이것은 싱글 스레드에서 다중 채널을 처리할 수 있는 메커니즘(mechanism)이다.

Page 58.

개념적으로, 버퍼와 채널은 데이터를 처리하기 위해 함께 작동한다. 다음 그림에 보여주는 바와 같이, 데이터는 버퍼 및 채널 간의 어느 방향으로 이동될 수 있다.

<그림>

버퍼는 데이터를 처리하기 위해 내부적으로 사용되는 반면, 채널은 일부 외부 데이터 소스에 연결된다. 채널과 버퍼는 여러 타입이 있다. 이들 중의 일부는 다음 표에 나열되어 있다.

다음은 채널에 대한 표이다.

채널 클래스 / 목적

FileChannel / 파일에 연결한다.
DatagramChannel / 데이타그램 소켓을 지원한다.
SocketChannel / 스트리밍 소켓을 지원한다.
ServerSocketChannel / 소켓 요청을 수신한다.
NetworkChannel / 네트워크 소켓을 지원한다.
AsynchronousSocketChannel / 비동기 스트리밍 소켓을 지원한다.

다음은 버퍼의 테이블이다.

버퍼 클래스 / 데이터 타입
<표 삽입>

2016.04.11

애플리케이션이 싱글 스레드를 사용하여 처리할 수 있는 많은 로우 트래픽 연결을 사용하는 경우 Selector 클래스는 유용하다. 이것은 각각의 접속을 위한 스레드를 생성하는 것보다 더 효율적이다. 이것은 또한 7장, '네트워크 확장성'에서 논의되는 애플리케이션이 더 확장하기 위해 사용되는 기술이다. 

Page 59.

3장에서는, 채널과 버퍼 간의 상호 작용을 설명하기 위해 클라이언트/서버 애플리케이션을 만들 것입니다. 이것은 단순한 타임 서버, 가변 길이의 메시지를 입증하는 채팅 서버, 서버는 하나의 다중 클라이언트를 처리하는 기술 및 비동기 서버를 예시하는 a parts server를 포함한다. 우리는 또한 대량 전송 및 뷰를 포함한 특별한 버퍼 기술을 검토할 것이다.

버퍼의 개요와 채널과 작동하는 방법에 대한 설명을 시작할 것이다.

버퍼 소개

버퍼는 채널로 이동되고 있기 때문에 일시적으로 데이터를 보유한다. 버퍼가 생성되면, 고정된 크기 혹은 용량으로 생성된다. 일부 혹은 모든 버퍼 메모리는 버퍼의 데이터를 관리할 수 있는 여러 Buffer 클래스 필드(field)로 이용될 수 있다.

Buffer 클래스는 추상적이다. 그러나 Buffer 클래스는 포함하는 버퍼를 조작하는 데 사용되는 기본적인 메소드를 가지고 있다.

-용량(capacity): 버퍼의 요소(element)의 수를 반환한다.
-제한(limit): 액세스 할 수 없는 버퍼의 최초의 인덱스를 반환한다.
-위치(position): 읽거나 사용할 수 있는 다음 요소의 인덱스를 반환한다.

요소는 버퍼 타입에 따라 달라진다.

mark 메소드와 reset 메소드는 버퍼 내의 위치를 제어할 수 있다. mark 메소드는 특정 위치에 버퍼 마크를 설정할 것이다. reset 메소드는 이전에 표시된 위치로 마크의 위치를 복원한다. 다음 코드는 다양한 버퍼 용어 간의 관계를 보여준다.

0 <= mark <= position <= limit <= capacity

버퍼는 직접 혹은 간접적 일 수 있다. 직접 버퍼(direct buffer)는 가능하면 네이티브 IO 메소드를 사용하려고 시도할 것이다. 직접 버퍼의 생성은 더 비싸지만 더 큰 메모리에서 더 큰 버퍼를 더 효율적으로 수행되는 경향이있다. allocateDirect 메소드는 직접 버퍼를 생성하기 위해 사용되고 버퍼의 사이즈를 지정하는 정수(integer)를 수용할 수 있다. allocate 메소드는 정수 크기 인수를 허용하지만, 간접 버퍼(non-direct buffer)를 생성한다.

간접 버퍼는 대부분의 작업에 대한 직접 버퍼로 효율적이지 않다. 그러나 간접 버퍼에 사용되는 메모리는 JVM 가비지 컬렉터에 의해 개선될 것이다. 반면에 직접 메모리 버퍼는 외부 JVM 통제가 될 지도 모른다. 이것은 메모리의 관리를 간접 버퍼와 함께 더 예측가능하게 한다.

Page 60.

채널 및 버퍼 간에 데이터를 전송하기 위해 사용되는 몇 가지 메소드가 있다. 다음 중 하나로서 분류될 수 있다.

- 절대적 혹은 상대적
- 대량 전송
- 기본 데이터 타입 사용
- 뷰(view) 지원
- 바이트 버퍼의 압축, 복제, 분해

많은 Buffer 클래스의 메소드는 인보케이션 체인(invocation chaining)을 지원한다. get 형태의 메서드는 버퍼로부터 정보를 검색하는 동안(?반면에), put 형태의 메소드는 데이터를 버퍼에 전송할 것이다. 예제에서는 광범위하게 get 메소드와 put 메소드를 사용할 것이다. 이러한 메소드는 한 번에 하나의 바이트를 전송할 것이다.

2016.04.14

이것들의 get과 put 메소드는 버퍼 내에서 현재 위치와 연관이 있다. 특정 버퍼 요소를 분리하기 위한 버퍼에 대한 인덱스를 사용하는 여러 절대 메소드가 있다.

대량의 데이터는 연속적인 데이터 블록으로 전송한다. 이러한 get과 put 메소드는 데이터를 저장하기 위해 자신의 인자의 하나로서 바이트의 배열을 사용한다. 대량 데이터 전송(Bulk data transfer) 절에서 논의된다.

Buffer 클래스 내의 모든 데이터가 동일한 타입일 때, Float 같은 특정 데이터 타입을 이용하여 데이터에 대한 편리한 접속을 가능하게하는 뷰(view)가 생성 될 수 있다. 뷰 절을 사용하여 이 버퍼를 논의할 것이다.

압축(Compacting), 복제(duplicating), 슬라이스 타입 조작(slicing type operations)이 지원된다.

2016.04.15

압축 작업은 이미 처리된 데이터를 제거하기 위해 버퍼의 내용을 이동한다. 슬라이싱(slicing)은 원시 버퍼의 전부 혹은 일부에 기초하는 새로운 버퍼를 생성하는 동안, 중복(Duplication)은 버퍼의 사본을 만들 것이다. 하나의 버퍼의 변경 사항은 다른 버퍼에 적용된다. 그러나, 각 버퍼의 위치(position), 제한(limit), 시장 가치(mark values)는 독립적이다.

버퍼의 생성으로 시작하는 작업에서 버퍼를 확인하자.

시간 서버와 채널 사용

1장, '네트워크 프로그래밍 시작하기'에서 소개된 시간 서버와 클라이언트는 버퍼와 채널의 사용을 보여주기 위해 여기에 구현될 것이다. 이러한 애플리케이션은 간단하지만, 버퍼와 채널을 함께 사용할 수 있는 방법을 보여준다. 먼저 서버를 생성하여 시작하고 그 후 서버를 사용하는 클라이언트를 생성한다.

Page 61.

타임 서버 생성

다음 코드는 타임 서버에서 사용하는 ServerSocketChannelTimeServer 클래스의 초기 선언이다. ServerSocketChannel 클래스의 open 메소드는 ServerSocketChannel 인스턴스를 생성한다. socket 메소드는 채널에서 사용하는 ServerSocket 인스턴스를 탐색한다. bind 메소드는 포트 5000으로 서버 소켓을 연결한다. ServerSocketChannel 클래스는 close 메소드가 있지만, try-with-resources 블록을 사용하는 것이 더 쉽다.

<소스>

서버는 클라이언트에서 요청을 수신할 때까지 accept 메소드 블록이 발생하는 곳의 무한 루프에 입력될 것이다. 이 경우, SocketChannel 인스턴스가 반환된다.

<소스>

인스턴스가 null이 아니라고 가정하면, 현재 일자와 시간을 포함하는 스트링(string)이 생성된다.

<소스>

Page 62.

ByteBuffer 인스턴스는 64 바이트의 크기로 생성된다. 대부분의 메시지 길이보다 더 긴 크기이다. put 메소드는 버퍼에 데이터를 이동한다. 이것은 대량 데이터 전송 동작이다. 버퍼 크기가 충분하지 않으면, BufferOverflowException 예외가 발생한다.

<소스>

채널의 쓰기 작업에 사용할 수 있도록 flip 메소드를 호출해야 한다. 이것은 설정의 효과를 갖는다. 제한(limit)은 현재의 위치와 위치의 값을 0으로 설정된다.(the limit is set to the current position and the position to zero.) while 루프는 각 바이트를 작성하기 위해 사용되며 hasRemaining 메소드에 의해 결정된 바와 같이 더이상 사용할 바이트가 없을 때 종료한다. 마지막 동작은 클라이언트에 전송되는 메시지를 표시하는 것이다.

<소스>

서버가 시작되면, 다음과 유사한 출력을 표시한다.

Time Server started
Waiting for request ...

바로 클라이언트를 생성할 준비가 됐다.

타임 클라이언트 생성

클라이언트는 다음에 정의된 SocketChannelTimeClient 클래스에서 구현된다. 예제를 단순화하기 위해, 클라이언트는 서버와 같은 머신으로 가정한다. SocketAddress 인스턴스는 IP 주소 127.0.0.1를 사용하여 생성되고, 포트는 5000으로 연결된다. SocketChannel 클래스의 open 메소드는 try-with-resources 블록 내에서 서버의 응답을 처리하기 위해 사용되는 SocketChannel 인스턴스를 반환한다.

<소스>

2016.04.18

Page 64.

채팅 서버

서버를 시작한다. 서버는 다음에 정의된 ChatServer 클래스에 정의되어 있다. ServerSocketChannel 인스턴스는 생성되고 포트 5000에 바인딩된다. 그것은 while 루프의 본문에 사용될 것이다. 실행 변수는 서버의 실행시간을 제어한다. 필요에 따라 예외(Exceptions)가 발생한다. 이전의 서버로서, 클라이언트가 서버에 연결될 때까지 서버는 accept 메소드로 블록될 것이다.

<소스>

Page 65.

이 채팅/서버 애플리케이션에서는 통신이 제한된다. 접속이 이루어지면, 서버는 사용자에게 클라이언트에 송신하기 위한 메시지를 표시한다. 이 메시지가 수신될 때까지 클라이언트가 대기하고, 이 응답에 대하여 사용자에게 메시지가 표시된다. 응답은 다시 서버로 전송된다. 이 시퀀스는 채널/버퍼의 상호 작용에 초점을 맞추기 위한 상호 작용을 단순화하기 위해 제한된다.

연결이되면, 서버는 결과에 대한 메시지를 표시한 후 다음과 같이 루프로 들어간다. 사용자는 메시지를 입력하라고 표시된다. sendFixedLengthMessage 메서드가 호출된다. 사용자가 quit를 입력하면, 종료 메시지를 서버로 전송하고 서버는 종료된다. 그렇지 않으면, 메시지는 서버에 전송하고, 서버는 클라이언트가 응답하기 위해 기다리기 위한 receiveFixedLengthMessage 메소드에서 블록된다.

<소스>

서버가 시작되면 다음과 같은 출력을 보여준다.

Chat Server started
Waiting for request ...

서버를 생성함으로서, 클라이언트 애플리케이션을 살펴보자.

Page 66.

채팅 클라이언트

클라이언트 애플리케이션은 다음에 정의된 ChatClient 클래스를 사용한다. 그 구조는 이전의 클라이언트 애플리케이션과 유사하다. 로컬호스트(127.0.0.1)는 포트 번호 5000과 함께 사용된다. 연결이 완료되면, 프로그램은 무한 루프로 진입하고 서버가 메시지를 전송하도록 기다린다.

<소스>

서버는 메시지를 보낼 때까지. 루프 내에서 프로그램은 receiveFixedLengthMessage 메소드에서 블록한다. 메시지는 표시되고, 사용자에게 서버로 재 전송되는 메시지가 표시된다. 메시지에 quit가 입력되면, sendFixedLengthMessage 메소드를 사용하여 서버에 전송하고, 애플리케이션은 종료된다. 그렇지 않으면 메시지는 서버로 전송되고, 프로그램은 그 외 메시지를 기다린다.

<소스>

Page 67.

클라이언트와 서버가 생성하고, 상호 작용하는 방법을 살펴본다.

서버/클라이언트 상호 작용

서버가 시작하면, 클라이언트 애플리케이션을 시작한다.

다음과 같은 클라이언트의 출력을 보여줄 것이다.

Connected to Chat Server
Waiting for message from the server ...

서버 출력은 이 연결을 반영한다.

Chat Server started
Waiting for request ...
Connected to Client
>

2016.04.19

Hello를 입력한다. 그러면 다음과 같은 출력을 확인할 것이다.

> Hello
Sent: Hello
Waiting for message from client ...

클라이언트는 지금 표시될 것이다.

Message: Hello
> 

Hi!라고 응답을 입력한다. 다음과 같이 클라이언트 출력이 표시될 것이다.

> Hi!
Sent: Hi!
Waiting for message from the server ...

Page 68.

서버는 표시된다.

Message: Hi!
> 

어느 한쪽이 quit 커맨드를 입력할 때까지이 과정을 계속할 수 있다. 그러나 64 바이트 버퍼 제한을 초과하는 메시지가 입력되면 BufferOverflowException 예외가 발생할 것이다. sendFixedLengthMessage 메소드를 sendMessage 메소드로 교체하고 receiveFixedLengthMessage 메소드를 receiveMessage 메소드로 교체하면 이 문제를 예방할 수 있다.

이러한 send 및 receive 작업하는 방법을 살펴 보자.

HelperMethods 클래스

HelperMethods 클래스는 다음과 같이 정의된다. 이전에 사용된 send 메소드와 receive 메소드를 소유한다. 이러한 메소드들은 쉽게 접속할 수 있도록 정적(static)으로 선언된다.

<소스>

고정된 길이의 메시지 메소드는 다음과 같다. 그들은 본질적으로 '채널을 사용한 타임 서버(Using channels with a time server)' 절에서 사용된 접근과 동일한 방법을 수행한다.

<소스>

Page 69.

가변 길이의 메시지 처리

가변 길이 메시지를 처리하는 기술은 이 절에서 설명한다. 가변 길이 메시지의 문제점은 메시지의 길이를 알 수 없다는 것이다. 버퍼가 완전히 차지 않을 때 메시지의 끝에 도달된 것으로 가정할 수 없다. 대부분의 메시지와 함께 참(true)일 수 있지만, 메시지 길이가 메시지 버퍼와 동일한 크기인 경우, 메시지의 끝을 놓칠 수있다.

메시지의 끝에 도달한 때를 결정하는 또 다른 방법은 메시지의 prefix로 메시지 길이를 전송하거나 메시지의 끝에 특별한 종료 문자를 추가한다. 여기서는 후자의 방법을 선택한다.

<<박스 시작>>
이 예제는 ASCII 문자에서 작동한다. 유니코드 문자가 대신 사용된다면, BufferOverflowException 예외가 발생될 것이다. CharBuffer 클래스는 캐릭터(character) 데이터에 사용되고 ByteBuffer 클래스와 유사한 기능을 제공한다. CharBuffer 클래스는 http://docs.oracle.com/javase/8/docs/api/java/nio/CharBuffer.html에 자세히 설명되어 있다.
<<박스 끝>>

0x00의 값은 메시지의 끝을 표시하기 위해 사용되었다. 그것은 인쇄되지 않고 종종 C 같은 언어에서 스트링은 내부적으로 종료하는 방법에 대응하도록 발생하기 때문에  우리는 그것이 사용자에 의해 실수로 쉽게 입력되지 않기 때문에 이 값을 선택했다.

sendMessage 메소드에서 전송되기 전에, put 메소드는 메시지의 끝에 종료 바이트를 추가한다. 버퍼 크기는 메시지 길이의 플러스 하나다.(The buffer size is the length of the message plus one.)

<소스>

2016.04.20 

Page 70.

receiveMessage 메소드에서, 수신된 각각의 바이트가 종료 바이트 있는지를 체크한다. 이 경우, 메시지는 반환된다. 우리가 메시지의 일부를 추출 한 후 clear 메소드는 ByteBuffer 변수에 적용된다. 이 메소드는 필수적이다. 그렇지 않으면, read 메소드는 0을 반환할 것이다. 이 메소드는 다시 0으로 버퍼 위치와 용량에 제한을 설정한다.

<소스>

이제 애플리케이션을 보여줄 준비가 됐다.

Page 71.

채팅 서버/클라이언트 애플리케이션 실행

처음 서버를 실행한다. 다음과 같이 출력이 표시된다.

Chat Server started
Waiting for request ...

다음으로, 클라이언트를 시작하면 다음과 같은 결과를 보여준다.

Connected to Chat Server
Waiting for message from the server ...

2016.04.21 

이러한 사용자는 서버와 클라이언트 간에 상호작용이 발생되고 현재 구현에 한계가 있다. 두 애플리케이션이 시작되었을 때, 클라이언트는 서버로부터의 메시지를 대기할 것이다. 다음과 같이 서버 창에 의해 반영된다.

Chat Server started
Waiting for request ...
Connected to Client
> 

메시지가 입력되면, 클라이언트에게 전송된다. Hello 메시지를 입력한다. 다음과 같이 클라이언트 창에서는 메시지를 표시하지 않을 것이다.

Connected to Chat Server
Waiting for message from the server ...
Message: Hello
> 

서버에서는 다음과 같은 결과가 나타날 것이다.

Sent: Hello
Waiting for message from client ...

이제 클라이언트에서 서버로 메시지를 보낼 수 있다. quit 메시지가 어느 애플리케이션에서 전송될 때까지 이 상황에서 메시지는 상호작용 할 수 있다.

Page 72.

다중 클라이언트 처리

스레드를 사용하여 다중 클라이언트를 처리할 수 있다. 이번 절에서, 간단한 부분 서버와 클라이언트 애플리케이션을 개발할 것이다. 서버는 각 클라이언트를 처리하는 별도의 스레드를 사용할 것이다. 이러한 기술은 구현하기는 것이 단순하지만, 항상 지나친 요청에는 적합하지 않을 것이다. 7장, '네트워크 확장성'에서는 멀티타스크를 대체하는 기술을 살펴볼 것이다.

2016.04.22

부품 서버는 PartsServer 클래스에서 구현되고, 클라이언트는 PartsClient 클래스에서 구현된다. ClientHandler 클래스의 새로운 인스턴스는 각 클라이언트에서 생성될 것이다. 이 핸들러는 일부의 가격에 대한 요청을 받아들일 것이다. 클라이언트는 핸들러에게 부분의 이름을 보낼 것이다. 핸들러는 PartsServer의 getPrice 메소드를 사용하여 부품의 가격을 찾을 것이다. 이 후 클라이언트에게 가격을 반환할 것이다.

부품 서버(parts server)

부품 서버는 부품에 대한 정보를 저장하기 위해 HashMap 변수를 사용한다. 일부의 이름은 키(key)로서 사용되며, 이 값은 Float 오브젝트로서 저장된다. PartsServer 클래스는 여기에 선언된다.


2016.04.25

Page 74.

부품 클라이언트 핸들러

ClientHandler 클래스는 다음 코드에 정의된다. SocketChannel 인스턴스 변수는 클라이언트에 연결하는 데 사용된다. run 메소드에서 핸들러의 시작을 나타내는 메시지가 표시된다. 그것은 필수적이지 않지만, 서버, 클라이언트 및 핸들러가 상호 작용하는 방식을 보면 도움이 될 것이다. 무한 루프는 HelperMethods 클래스 절에서 확인한 부품의 이름을 얻기 위해 사용되는 receiveMessage 메소드가 있는 곳에서 입력된다. quit 메시지는 핸들러를 종료할 것이다. 그렇지 않으면,  sendMessage 메소드를 사용한 클라이언트에 반환되는 getPrice 메소드는 호출된다.

<소스>

클라이언트를 설명할 때 run 메소드의 출력을 확인할 것이다.

Page 75.

부품 클라이언트

PartsClient 클래스는 다음 코드 시퀀스에 정의된다. 서버에 대한 연결이 설정된다. 메시지는 클라이언트가 시작할 때를 나타내는 표시로, 서버 연결은 이루어진다. Scanner 클래스는 사용자로부터 입력을 얻기 위해 while 루프에서 사용된다.

<소스>

루프의 본문은 부품 이름에 대한 사용자 메시지가 표시된다. 이름을 중지하면, 클라이언트는 종료된다. 그렇지 않으면, sendMessage 메소드는 처리를 위해 핸들러에 이름을 보낼 것이다. 서버가 응답할 때까지 클라이언트는 receiveMessage 메소드 호출을 차단할 것이다. 이 부분의 가격은 표시된다.

<소스>

이제, 모두가 함께 동작하는 방법을 살펴보자.

Page 76.

부품 클라이언트/서버 실행

먼저 서버를 시작한다. 서버가 시작될 때 서버는 다음과 같은 출력을 나타낸다.

Part Server started
Waiting for client ...

이제, 클라이언트 애플리케이션을 시작한다. 다음과 같은 출력을 확인할 수 있다.

PartsClient Started
Connected to Parts Server
Enter part name: 

예를 들어 Hammer로, 부품 이름을 입력한다. 다음과 같이 클라이언트 출력은 이제 표시된다. The Sent: Hammer 출력은 sendMessage 메소드의 인위적인 결과고, 원하는 경우 sendMessage 메소드를 수정하여 제거할 수 있다.

PartsClient Started
Connected to Parts Server
Enter part name: Hammer
Sent: Hammer
The price is 12.55
Enter part name:

서버에서는 다음과 유사한 출력을 확인할 것이다. 새로운 클라이언트가 시작할 때마다 핸들러에 관한 정보를 표시하는 메시지가 보인다.

Part Server Started
Waiting for client ...
ClientHandler Started for java.nio.channels.SocketChannel[connected local=/127.0.0.1:5000 remote=/127.0.0.1:51132] Waiting for client ...
Sent: 12.55

Page 77.

클라이언트 측에서, 우리는 quit 커맨드를 입력할 때까지 가격을 계속 확인할 수 있다. 이 명령은 클라이언트를 종료한다. 다음과 같이 요청 가능한 하나의 순서는 다음과 같다.

PartsClient Started
Connected to Parts Server
Enter part name: Hammer
Sent: Hammer
The price is 12.55
Enter part name: Pliers
Sent: Pliers
The price is 4.65
Enter part name: saw
Sent: saw
The price is null
Enter part name: Saw
Sent: Saw
The price is 8.45
Enter part name: quit
Sent: quit
PartsClient Terminated

가격 정보를 찾는 다른 클라이언트가 있을 수 있으므로 서버는 실행을 계속할 것이다. 클라이언트 핸들러가 종료될 때 서버에 의해 다음과 유사한 출력이 표시된다.

ClientHandler Terminated for java.nio.channels.SocketChannel[connected local=/127.0.0.1:5000 remote=/127.0.0.1: 51132]

두 개 이상의 클라이언트를 시작하고 그들이 서버와 상호 작용하는 방법을 살펴보자. 7장, '네트워크 확장성'에서 애플리케이션을 보다 정교한 방법으로 조사할 것이다.

Page 78.

비동기 소켓 채널

비동기 통신은 요청을 하고 그 요청이 완료될 때까지 기다리지 않고 다른 작업을 진행한다. 이것은 논블로킹(non-blocking)이라고 부른다.

비동기 채널 동작을 지원하는 세 가지 클래스가 있다.

-AsynchronousSocketChannel: 소켓에 대한 간단한 비동기 채널이다.
-AsynchronousServerSocketChannel: 서버 소켓에 대한 비동기 채널이다.
-AsynchronousDatagramChannel: 데이터그램 지향 소켓(datagram-oriented socket)을 위한 채널이다.

2016.04.26

AsynchronousSocketChannel 클래스의 read/write 메소드는 비동기이다. AsynchronousServerSocketChannel 클래스는 AsynchronousSocketChannel 인스턴스를 반환하는 accept 메소드를 가진다. 이 메소드 또한 비동기다. 6장, UDP 및 멀티캐스트에서 AsynchronousDatagramChannel 클래스를 살펴볼 것이다.

비동기 I/O 작업을 처리하는 두 가지 방법이 있다.

-java.util.concurrent 패키지의 Future 인터페이스 사용
-CompletionHandler 인터페이스 사용

Future 인터페이스는 보류 결과를 나타낸다. 이것은 허용하는 실행 및 비 블록을 계속하는 애플리케이션에 대한 비동기 작업을 지원한다. 이 오브젝트를 사용하여 다음 메소드 중 하나를 사용할 수 있다.

-isDone 메소드
-완료될 때까지 블록을 하는 get 메소드

get 메소드는 타임아웃을 지원하는 하나의 버전으로 오버로드된다. 작업이 완료되면 CompletionHandler 인스턴스가 호출된다. 이것은 본질적으로 콜백이다. 우리는 여기에서 이 방법을 설명하지 않는다.

각각 AsynchronousServerSocketChannelServer 및 AsynchronousSocketChannelClient라고 하는 비동기 서버와 클라이언트를 개발할 것이다. 클라이언트/서버 애플리케이션에 제한이 있으며 단지 메시지를 클라이언트에서 서버로 전송될 수 있다. 이것은 애플리케이션의 비동기 측면을 살펴볼 수 있도록 한다.

Page 79.

비동기 서버 소켓 채널 서버 생성

AsynchronousServerSocketChannelServer 클래스는 다음 코드 시퀀스로 정의된다. 서버가 시작되었음을 알리는 메시지가 표시되고, AsynchronousServerSocketChannel클래스의 인스턴스가 생성되는 곳에서는 try-with-resources 블록은 입력되고, 실제 작업이 발생한다.

<소스>

bind 메소드는 로컬호스트와 포트 5000과 함께 AsynchronousServerSocketChannel 인스턴스를 나타내는 serverChannel 변수를 연결하는 데 사용된다.

<소스>

서버는 클라이언트에 연결하기위해 대기한다. Future 인스턴스는 acceptResult 변수에 의해 참조된다.

<소스>

Page 80.

또 다른 try 블록은 클라이언트 요청을 처리하는 데 사용된다. 그것은 클라이언트에 연결하는 AsynchronousSocketChannel 클래스의 인스턴스를 생성한다. 채널이 생성될 때까지 get 메소드는 블록(block)할 것이다.

<소스>

try 블록의 본문은 버퍼를 할당하고 버퍼를 채울 채널에서 읽는다. 버퍼가 채워되면, flip 메소드는 버퍼에 적용하여, 메시지가 처리되고 표시된다.

<소스>

버퍼가 준비가 되었는지 여부를 결정하는 세 가지 방법이 있다. 첫번째 기술은 다음과 같이, 버퍼가 준비 될 때까지 isDone 메소드를 사용한 결과 변수를 나타내는 Future 오브젝트를 사용한다.

<소스>

두 번째 기술은 버퍼가 준비 될 때까지 블록하는 get 메소드를 사용한다.

<소스>

세 번째 기술은 또한 get 메소드를 사용하지만 기다리는 시간을 결정하기 위해 타임아웃(timeout)을 사용했다. 이 예제에서는, 타임아웃 전 10초 대기한다.

<소스>

Page 81.

2016.04.27

get 메소드의 이 버전을 사용하는 경우, catch 블록은 TimeoutException 예외를 처리하기 위해 try 블록에 클로징하여 추가해야 한다.

서버가 시작되면, 다음과 같은 출력을 확인한다.

Asynchronous Server Started
Waiting for client to connect... 

이제, 클라이언트를 살펴 보자.

비동기 소켓 채널 클라이언트 생성

클라이언트는 다음 코드에 AsynchronousSocketChannelClient 클래스를 사용하여 구현된다. 클라이언트가 시작되었음을 나타내는 메시지는 AsynchronousSocketChannel 인스턴스를 생성하는 try 블록 다음에 표시된다.

<소스>

InetSocketAddress 인스턴스는 서버에서 사용하는 주소와 포트 번호를 지정하여 생성된다. 이 후 연결을 나타내는 Future 오브젝트는 생성된다. 연결이 될 때까지 get 메소드는 블록된다.

<소스>

Page 82.

연결이되면, 메시지는 표시된다. 사용자가 메시지를 입력하라는 곳에서는 무한 루프가 입력된다. wrap 메소드는 메시지 버퍼를 채운다. write 메소드는 AsynchronousSocketChannel 인스턴스에 메시지 작성을 시작하고 Future 오브젝트를 반환한다. isDone 메소드는 완료하는 데 쓰기 위해 대기하는 데 사용된다. 메시지가 quit이면, 클라이언트 애플리케이션은 종료된다.

<소스>

실제로 비동기 클라이언트/서버를 살펴 보자.

서버는 실행중으로 클라이언트 애플리케이션을 시작한다. 이것은 다음과 같은 출력을 생성한다.

Asynchronous Client Started
Client is started: true
Sending messages to server: > 

서버의 출력은 이제 다음과 같이 나타난다.

Asynchronous Server Started
Waiting for client to connect...
Messages from client: 

Page 84.
 
2016.04.28

너무 많이 전송하려고하지 않도록 주의해야한다. 그렇지 않으면 예외가 발생한다. 첫 번째 단계는 버퍼에 남아있는 공간의 크기를 결정하는 것이다. 다음과 같이, 남은 메소드는 이 작업을 수행한다. 여기에 도시된 바와 같이 벌크(bulk) put 문장(statement)은 상기 버퍼의 마지막 두 위치로 배열의 첫 번째 두 개의 요소를 전송한다.

<소스>

Page 85.

다시 버퍼와 그 내용을 표시하는 경우, 다음과 같은 출력을 확인할 것이다.

java.nio.HeapIntBuffer[pos=6 lim=6 cap=6]

12 51 79 54 12 51 

get 메소드는 대량 데이터 전송을 지원하기위해 오버로드된다. 다음과 같이 어떻게 작동하는지 설명하기 위해 displayBuffer 메소드를 수정할 수 있다. 정수 배열(integer array)은 버퍼의 내용과 같은 크기로 생성된다. rewind 메소드는 다시 0으로 버퍼의 위치를 이동한다. 벌크 GET 메소드는 실제로 그 내용을 표시하기 위한 for-each 루프 다음에 전송을 행한다.

<소스>

뷰 사용

뷰는 다른 버퍼로 데이터를 미러링한다. 어떤 버퍼에 대한 수정은 다른 버퍼에 영향을 미칠 것이다. 그러나 위치(position)와 제한(limit)은 독립적이다. 뷰는 duplicate 메소드 등 여러 가지 메소드로 생성할 수 있다. 다음 예제에서, 뷰는 문자열에 대해 벌크를 위한 getBytes 메소드를 사용하여 버퍼로 이루어진다. 뷰는 다음에 생성된다.

<소스>

한 버퍼의 수정은 다른 버퍼에 영향을 미칠 것을 보여주기 위해, 중복의 첫 번째 문자는 문자 'L'로 변경된다. 각 버퍼의 첫번째 바이트는 변경 확인이 표시된다.

<소스>

출력은 문자는 모두 버퍼에 변경되었음을 표시한다. slice 메소드는 뷰를 생성하지만, 원래의 버퍼의 부분만을 사용한다.

Page 86.

읽기 전용 버퍼 사용

기본적으로 버퍼는 읽기-쓰기를 한다. 그러나 그것은 읽기 전용 혹은 읽기-쓰기 할 수 있다. 읽기 전용 버퍼를 생성하려면, 버퍼 클래스의  asReadOnlyBuffer 메소드를 사용한다. 다음 시퀀스에서, 읽기 전용 버퍼가 생성된다.

<소스>

여기에 설명된 것처럼 버퍼가 읽기 전용인 경우, isReadOnly 메소드는 결정될 것이다.

<소스>

읽기 전용 버퍼는 원래 버퍼의 다른 뷰이다.버퍼에 대한 수정은 다른 버퍼에 반영된다.

소켓 옵션 제어

소켓 클래스의 내부적인 소켓 구현은 구성될 수 있다. 사용가능한 옵션은 소켓 타입에 따라 달라진다. 종종, 옵션을 지원하기 위해 사용되는 실제 메커니즘은 OS 명세에 따른다. 또한, 때로는 옵션은 단지 내부 구현에 힌트다.

다음에 표시된 각 소켓 클래스에서 사용가능한 옵션은 자바 API 문서에서 구성된다.

<표>
클래스 / 옵션 이름 / 설명

이것은 소켓 전송 버퍼의 크기이다.
이것은 소켓 수신 버퍼의 크기이다.
이것은 접속을 계속 유지한다.
이것은 주소를 재사용한다.
This lingers on close if data is present(when configured in blocking mode only)
이것은 Nagle 알고리즘을 사용하지 않도록한다.
소켓 수신 버퍼의 크기다.
이것은 주소를 재사용한다.

Page 87.

<표>

소켓 옵션은 setOption 메서드를 사용하여 구성된다. 다음 코드는 부품 서버 절에서 사용되는 서버 소켓 채널을 이용한 메소드를 설명한다.

serverSocketChannel.setOption(SO_RCVBUF, 64);

첫 번째 인수는 SocketOption<T> 인터페이스의 인스턴스이다. 이 인터페이스는 옵션에서 이름과 타입 메소드를 정의한다. StandardSocketOptions 클래스는 이 인터페이스를 구현한 일련의 옵션을 정의한다. 예를 들면, 다음과 같이 SO_RCVBUF 인스턴스가 정의된다.

public static final SocketOption<Integer> SO_RCVBUF;

추가, 구현-고유 옵션을 사용할 수 있다.(There may be additional, implementation-specific  options available.)

요약

3장에서는 NIO 채널 및 버퍼 클래스의 사용을 살펴보았다. 채널은 버퍼에서 외부 소스와 데이터를 전송을 연결한다. 네트워크를 통해 다른 소켓에 연결하는 채널 소켓을 살펴본다.

버퍼는 데이터의 임시 저장소이다. 버퍼를 사용하여 데이터를 순차적으로 혹은 랜덤하게 액세스할 수 있다. 이것은 많은 애플리케이션을 위한 좋은 선택을 만드는 많은 버퍼 동작이다.

SocketChannel, ServerSocketChannel, AsynchronousSocketChannel 클래스를 포함하는 여러 종류의 채널 소켓을 살펴봤다. ServerSocketChannel 클래스는 서버를 지원하며, 클라이언트가 접속을 요청할 때까지 블록을 위한 accept 메소드를 사용한다. 이 메소드는 클라이언트의 SocketChannel에 연결되고, SocketChannel 인스턴스를 반환한다. AsynchronousSocketChannel 및 AsynchronousSocketChannel 클래스는 두 개의 애플리케이션 간의 논블록킹을 가능하게하는 비동기 통신을 지원한다. DatagramChannel은 또한 지원되고, 6장, 'UDP 및 멀티캐스트'에서 다룰 것이다.

Page 88.

버퍼와 채널 클래스가 함께 작동하는 방법을 설명하고 여러 클라이언트/서버 애플리케이션에서의 사용을 보여준다. 또한 스레드를 사용하여 여러 클라이언트를 다룰 수 있는 간단한 방법을 살펴본다. 

대량 데이터 전송이 배열 및 버퍼 간에 수행하는 방법을 살펴봤다. 뷰와 읽기 전용 버퍼의 사용을 또한 살펴봤다. 기본 OS 소켓 지원을 구성할 수 있는 방법에 대한 소개와 함께 종료됐다. 다음 장에서, 다른 클라이언트/서버 애플리케이션을 지원하기 위해 이러한 많은 클래스와 기술을 사용한다.

Page 89.

클라이언트/서버 개발

4장에서는 주로 HTTP와 연관을 지향하는 클라이언트/서버 애플리케이션을 개발하는 과정을 살펴볼 것이다. HTTP는 중요한 프로토콜이고, 다수의 애플리케이션에 대한 기본 통신 매체로서 기능을 제공한다. 우리는 클라이언트에 요청된 프로토콜과 서버를 위한 다양한 버전의 프로토콜을 살펴본다.

특히, 살펴볼 것이다.

-HTTP 프로토콜의 특성을 점검한다.
-로우 레벨 소켓이 프로토콜을 지원할 수 있는 방법을 살펴본다.
-HTTP 서버를 생성하는 HttpURLConnect과 HTTPServer 클래스를 사용한다.
-다양한 오픈 소스 자바 HTTP 서버를 살펴본다.
-다양한 구성 문제와 쿠키 처리 방법을 살펴본다.

HTTP 서버는 광범위하게 사용되기 때문에 자바를 지원하는 방법을 잘 이해하는 것이 중요하다.

HTTP 프로토콜 구조

HTTP는 월드 와이드 웹(WWW)을 통해 리소스를 제공하는 데 사용되는 네트워크 프로토콜이다.

2016.05.03

Page 95.

클라이언트/서버 상호 작용 예제

다음 상호 작용은 요청을 전송하고 서버가 응답하는 클라이언트의 간단한 예제이다. 클라이언트 요청 메시지는 \index 경로에 대한 GET 메소드를 사용한다.

GET /index HTTP/1.0

User-Agent: Mozilla/5.0

서버는 요청을 처리할 수 있는 것을 측정하여, 다음 메시지로 응답할 것이다. Server, Content-Type 및 Content-Length 헤더가 사용된다. 빈(blank) 라인은 헤더와 HTML 메시지 본문을 구분한다.

<결과>

기타 헤더 라인은 포함될 수 있다.

HTTP 클라이언트/서버 애플리케이션을 위한 자바 소켓 지원

HTTP 클라이언트는 HTTP 서버와 연결한다. 클라이언트는 서버에 요청 메시지를 전송한다. 서버는 HTML 문서로 자주 응답 메시지를 재전송할 것이다. 초기 HTTP 버전에서, 응답이 전송된 후에 서버는 접속을 종료할 수 있다. 연결이 유지되지 않기 때문에 때때로 무상태(stateless) 프로토콜로 지칭된다.

HTTP/1.1은 지속적인 연결을 유지할 수 있다. 복수의 데이터가 서버와 클라이언트 간에 전송될 필요가 있을 때 개방하고 닫고 연결을 제거함으로써 성능을 개선한다.

HTTP 서버와 HTTP 클라이언트를 생성하는 방법을 살펴볼 것이다. 브라우저는 일반적으로 HTTP 클라이언트 역할을 하는 동안, 다른 애플리케이션은 웹 서버에 액세스 할 수 있다. 또한, HTTP 요청의 성질을 설명하는 것을 돕는다. 서버는 HTTP/1.0 규격의 하위 집합을 지원한다.

Page 96.

간단한 HTTP 서버 구축

HTTP/1.0 프로토콜을 지원하는 WebServer라는 클래스를 사용한다. 서버는 클라이언트를 처리하는 ClientHandler 클래스를 사용한다. 서버는 단지 GET 요청 처리하는 것을 제한된다. 그러나 필요한 기본 서버 요소를 설명하는 데 적절한 것이다. 다른 메소드의 지원은 쉽게 추가될 수 있다.

WebServer의 정의는 다음에 보여준다. ServerSocket 클래스는 서버 기반이다. 요청이 생성될 때까지 accept 메소드는 블록된다. 이러한 상황이 발생하면 ClientHandler 클래스를 기반으로 새 스레드가 시작된다.

<소스>

포트 80을 사용하는 경우 Mac 사용자는 오류가 발생할 수 있다. 대신 3000 혹은 8080 포트를 사용한다. 스레드가 동시에 프로세스 내에서 코드 시퀀스를 실행하고 있다. 자바에서 쓰레드는 Thread 클래스를 사용하여 생성된다. 생성자 인수는 Runnable 인터페이스를 구현하는 오브젝트다. 이 인터페이스는 단일의 메소드(run)로 구성된다. 스레드가 start 메소드를 사용하기 시작하면, 별도의 프로그램 스택은 새로운 스레드를 생성하고 run 메소드는 이 스택에서 실행된다. run 메소드가 종료되면, 스레드가 종료된다. 다음에 표시된 ClientHandler 클래스는, Runnable 인터페이스를 구현한다. 생성자는 클라이언트를 나타내는 소켓에 전달된다. 스레드가 시작되면, run 메소드가 실행된다. 메소드를 표시, 시작하고 메시지를 종료한다. 실제의 처리는 handleRequest 메소드로 수행된다.

<소스>

2016.05.04

Page 97.

<소스>

handleRequest 메소드는 서버와 통신하기 위해 입력 및 출력 스트림을 사용한다. 또한, 요청이 만들어진 것을 결정하고 요청을 처리한다.

다음 코드에서, 입력 및 출력 스트림이 생성되고 요청의 첫 번째 라인은 읽혀진다. StringTokenizer 클래스는 이 라인을 토큰하는 데 사용된다. nextToken 메소드가 호출될 때, 그것은 HTTP 메소드를 응답하기 위한 라인의 첫 번째 단어를 반환한다.

<소스>

tokenizer는 일련의 토큰을 텍스트로 분할하는 처리이다. 자주, 이 토큰은 간단한 단어이다. StringTokenizer 클래스의 생성자는 토큰화할 수 있는 텍스트는 통과된다. nextToken 메소드는 가능한 다음 토큰을 반환할 것이다.

Page 98.

다음 코드 시퀀스는 GET 메소드를 다룬다. 메시지는 GET 메소드가 처리되고 있음을 표시하기 위해 서버 측에 표시된다. 이 서버는 간단한 HTML 페이지를 반환한다. 페이지는 append 메소드는 유창한 스타일에 사용되는 StringBuilder 클래스를 사용하여 구축된다. sendResponse 메소드는 실제로 응답을 전송하기 위해 호출된다. 다른 메소드가 요청된 경우, 405 상태 코드가 반환된다.

<소스>

다른 메소드를 처리하기를 원한다면, 일련의 else-if은 추가된다. GET 메소드를 처리하기 위해, 최초 요청 라인의 나머지는 파싱해야한다. 다음 문은 처리할 수 있는 스트링을 줄 것이다.

String httpQueryString = tokenizer.nextToken();

이전 문장은 이 예제에서 필요하지 않고 코드에 포함되지 않는다. 그것은 단순히 HTTP 쿼리를 더 처리하는 하나의 가능한 방법을 제공한다.

응답을 생성한 후에, 다음과 같이 클라이언트에 보낼 sendResponse 메소드를 사용할 것이다. 이 메소드는 소켓, 상태 코드 및 응답 스트링을 통과한다. 출력 스트림은 생성된다.

<소스>

Page 99.

2016.05.09

Page 114.

서블릿은 데이터베이스 액세스, 퍼포먼스 관리, 보안 제공 같은 작업에 대한 지원을 제공하는 컨테이너에서 열린다. 간단한 서블릿은 구성하는 방법에 관해서는 당신에게 느낌을 주고 옆에서 보여준다.

doGet과 doPost 메소드는 각각 GET과 POST 유형의 메시지를 다룬다. 그러나 두 HTTP 메시지 간의 차이는 숨겨지므로 단지 하나만 필요하다. HttpServletRequest 클래스는 HTTP 요청을 나타내고, HttpServletResponse 클래스는 응답을 나타낸다. 이 클래스는 메시지에 대한 접속을 제공한다. 예를 들어, getWriter 메소드는 명확한 방식으로 HTML 응답을 기록할 수 있는 PrintWriter 클래스의 인스턴스를 반환한다.

<소스>

서블릿은 일반적으로 자바 EE SDK를 사용하여 개발한다. 이 API를 사용하여 개발하지 않으면 이전 예제는 제대로 컴파일되지 않는다.

대부분의 기술은 진화되고 서블릿은 숨겨져 있다. 수년에 걸쳐, 이것은 크게 직접 서블릿을 사용할 필요가 없는 JSP(JavaServer Pages)와 JSF(JavaServer Faces)를 포함한다.

자바를 위한 다수의 웹 서버가 있다. 이들의 일부 비교는 https://en.wikipedia.org/wiki/Comparison_of_application_servers#Java에서 확인할 수 있다.

Page 115.

서버 구성

서버의 구성은 구축하기 위해 사용된 기술에 의존한다. URLConnection 클래스의 구성을 살펴볼 것이다. 이 클래스는 연결 동작 방법을 제어하는 다수의 protected 필드를 가진다. 이 필드들은 해당 get 및 set 메소드를 사용하여 접속된다.

하나의 필드는 사용자 상호 작용을 다룬다. true로 설정되면, 사용자는 인증 대화 상자(authentication dialog box)에 대한 응답과 같은 상호 작용에 관여할 수 있다. 연결은 입력/출력에 사용될 수 있다. 연결은 입력 혹은 출력을 허용되지 않도록 구성될 수 있다.

데이터가 클라이언트와 서버 간에 전송되는 경우, 데이터는 캐시될 수 있다. UseCaches 변수는 캐시의 무시여부와 관련없이 결정한다. true로 설정하면, 캐시는 적절하게 사용된다. false의 경우, 캐싱이 수행되지 않는다.

오브젝트 검색의 발생여부에 따라서 ifModifiedSince 변수는 제어한다. 그것은 시대(1970 년 1 월 1 일 GMT) 이후의 밀리초로 시간을 나타내는 long 값이다.객체는 그 시간보다 좀 더 최근에 수정된 경우, 그것은 패치(fetch)된다.

다음 표는 URLConnection 클래스를 사용하여 연결된 접속을 구성하는 데 사용되는 메소드를 요약한다. 이러한 각각의 메소드는 상응하는 GET 메소드를 가지고 있다.

<표>

Tomcat과 같은 보다 정교한 서버는 구성되는 방법을 제어하기 위한 더 많은 옵션이 있다.

Page 116.

애플리케이션이 디플로이(deploy)될 때, 다수의 설정 옵션은 deployment.properties 파일에서 확인된다. 이러한 옵션의 대부분은 로우 레벨이고, JRE 관련이다. 옵션에 대한 설명은 https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/properties.html에서 확인한다. 21.2.5 캐시 및 옵션 패키지 저장소 절은 캐시의 구성에 관한 것이지만, 21.2.4 네트워크 절은 네트워크 옵션을 살펴본다.

HTTP 프록시는 클라이언트와 서버 간의 중개자 역할을 하는 서버이다. 프록시는 종종 네트워크 관리, 트래픽 모니터링, 네트워크 성능을 향상시키기 위해 사용된다. 일반적으로, 프록시의 사용 혹은 구성과 관련되지 않는다. 그러나 프록시를 구성 할 필요가 있다면, JVM 커맨드 라인을 사용하거나 코드 내에서 System 클래스의 getProperties 메소드를 사용하여 제어할 수 있다. 사용하는 프록시를 제어하고 필요한 경우 접속하기 위한 사용자와 암호를 지정할 수 있다. 이러한 기능에 대한 간단한 설명은 http://viralpatel.net/blogs/http-proxy-setting-java-setting-proxy-java/에서 확인된다.

쿠키 처리

쿠키는 사용자 선호도(preferences)로 서버에 대한 관심 정보를 나타내는 키/값 쌍을 포함하는 스트링이다. 그것은 브라우저로 서버에서 전송된다. 나중에 사용할 수 있도록 브라우저는 쿠키 파일을 저장한다. 쿠키는 등호(equal sign)와 다음 값에 따른 이름으로 구성된 스트링이다. 다음은 가능한 하나의 쿠키이다.

userID=Cookie Monster

쿠키는 여러 값을 가질 수 있다. 이 값은 세미콜론과 공백으로 구분된다. 

쿠키의 처리를 보여주기 위해 HTTPServer 클래스와 HttpURLConnection 클래스를 사용한다. MyHTTPServer 클래스 서버의 핸들러 클래스의 handle 메소드에서, 다른 헤더 뒤에 다음 코드를 추가한다.

responseHeaders.set("Set-cookie", "userID=Cookie Monster");

서버가 응답하면 해당 쿠키를 전송한다.

Page 117.

HttpURLConnectionExample 클래스의 getResponse 메소드에 있어서, try 블록의 시작 부분에 다음 코드를 추가한다. 스트링은 쿠키 텍스트가 포함되어 있다. 다중 substring과 IndexOf 메소드는 쿠키의 이름과 그 값을 추출하는 데 사용된다.

<소스>

서버가 응답을 송신하면, 쿠키를 포함한다. 클라이언트는 쿠키를 수신한다. 서버와 클라이언트에서는 쿠키를 표시하는 다음과 같은 출력을 볼 수 있다.

Set-cookie : [userID=Cookie Monster]

앞의 예제는 단순한 단일 값 쿠키를 처리한다. 다중 값을 처리하는 코드는 독자들에게 연습으로 남겨둔다.

요약

4장에서는 HTTP 클라이언트/서버 애플리케이션을 개발하는 데 사용할 수 있는 다양한 자바 접근 방법을 검토한다. HTTP를 사용한 통신은 일반적이다. 자바가 이 과정을 지원하는 방법을 이해하는 것은 소유할 수 있는 가치있는 기술이다. 

HTTP 메시지의 개요로 시작했다. 초기 요청 및 응답 라인의 형식을 조사하였다. 메시지에 대한 정보를 전달하는데 이용되는 헤더 라인을 조사했다. 옵션 메시지 본문은 HTTP 메시지가 나타날 수 있다. 이것은 종종 HTML 문서에서 본체를 받는 곳에 응답에서 더 일반적이다.

Page 118. 
