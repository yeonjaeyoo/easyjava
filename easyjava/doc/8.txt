8. 네트워크 보안

8장에서는 자바에서 애플리케이션 간의 통신 보안을 제공하는 지원을 살펴볼 것이다. 

다음과 같은 몇 가지 주제를 살펴본다.

-기본적인 암호화 프로세스
-키와 인증서를 저장하는 키스토어(keystore) 사용
-간단한 서버/클라이언트에서 암호화 추가
-TLS\SSL을 사용한 보안 클라이언트/서버 통신
-보안 해싱

보안

그들은 처음 발생하는 경우 위협이 될 수 있는 의미와 목적이 있는 많은 보안 관련 용어가 있다. 이러한 용어의 대부분은 네트워크 애플리케이션에 적용할 수 있다. 이러한 많은 용어에 대한 간략한 개요와 함께 시작한다. 8장 이후 절에서, 우리의 논의와 관련이 있는 것들에 대한 자세한 내용으로 이동한다.

대부분의 보안 관련 문제의 핵심은 암호화이다. 이 키 혹은 키 세트를 사용하여 암호화된 형태로 보호되야하는 정보를 변환하는 프로세스이다. 암호화 정보 수신기(The receiver of the encrypted information)는 정보를 복호화하고 원래의 형태로 되돌리기 위해 키 혹은 키 세트를 사용할 수 있다. 이 기술은 정보에 대한 인증받지 않은 접속을 예방할 수 있다.

대칭(symmetric) 및 비대칭 암호화 기술의 사용을 살펴볼 것이다. 대칭 암호화는 메시지를 암호화하고 복호화할 수 있는 단일 키를 사용한다. 비대칭 암호화는 키 쌍을 사용한다. 이 키는 주로 설명하는 키스토어라는 파일에 저장된다.

Page 202.

대칭 암호화는 일반적으로 빠른지만 안전한 방법으로 자신의 키를 공유하는 암호화된 데이터의 송신자와 수신자가 필요하다. 원격으로 떨어뜨른 파티, 이것은 문제가 될 수 있다.(수정해야함) 비대칭 암호화는 느리지만, 보는 바와 같이, 키의 공유를 단순화, 공개 키와 개인 키 쌍을 사용한다. 비대칭 암호화는 문서의 진위를 검증하는 수단을 제공하는 디지털 인증서에 대한 활성화 기술이다.

안전한 전자상거래는 일반적이고 매일 전 세계적으로 발생하는 온라인 거래를 위해 필수적이다. TLS(Transport Layer Security) 및 SSL(Secure Sockets Layer)은 인터넷을 통해 안전하고 신뢰할 수 있는 통신 프로토콜이다. 인터넷의 대부분 거래를 수행하는데 사용되는 HTTPS(Hyper Text Transfer Protocol Secure)를 위한 기초이다. 이 프로토콜은 다음을 지원한다.

2016.06.08

Page 203.

권한은 개인 혹은 시스템이 리소스에 접속할 수 있는지 결정하는 과정이다. 개인은 그들이 말하는 것이 누구인지 확인하는 한 가지이다.(수정) 사용자가 단지 허가된 자원에만 접속할 수 있도록 하는 또다른 일이다.

암호화는 진화하고 계속해서 향상될 것이다. 자바는 대칭 및 비대칭 암호화 기술을 지원한다. 프로세스는 일반적으로 키스토어에 저장되어 있는 키의 생성을 시작한다. 암호화 혹은 복호화 데이터가 필요한 애플리케이션은 적절한 키를 검색하는 키스토어에 접속할 것이다. 키스토어 자체가 훼손되거나 손상되지 않도록 보호할 필요가 있다.(수정)

해싱은 데이터를 취득하고 데이터를 나타내는 숫자를 반환하는 과정이다. 해쉬 알고리즘은 동작을 수행하고, 신속해야한다. 그러나 단지 해시 값이 주어지면 원래의 데이터를 도출하는 것은 불가능하지는 않지만, 매우 어렵다. 단방향 해시 함수(one-way hash function)라고 한다.

이 기술의 이점은 데이터는 리시버(receiver)에서 해시 값과 함께 전송될 수 있다는 것이다. 데이터는 암호화되지 않고, 해시 값은 비대칭 키 세트를 사용하여 암호화된다. 리시버는 이 후 수신된 데이터의 해시 값을 계산하기 위해 원래의 해시 알고리즘을 사용할 수 있다. 새로운 해시 값이 전송된 해시 값과 일치하는 경우, 리시버는 데이터가 수정되거나 전송시 손상되지 않았다는 것을 보장할 수 있다. 이것은 암호화될 필요가 없는 전송하는 데이터의 신뢰성 있는 수단을 제공하지만, 수정되지 않은 약간의 보증이 있다.(수정)

인증서는 이전 과정의 일부이며, 해시 함수 및 비대칭 키를 사용한다. 인증서 체인은 인증서가 체인의 루트를 신뢰할 수 있다는 가정이 유효한지 확인하는 수단을 제공한다.

암호화의 기초

이 절에서는 자바가 대칭 및 비대칭 암호화를 지원하는 방법을 검토할 것이다. 보는 바와 같이, 이러한 기술 모두에 사용할 수 있는 다양한 암호화 알고리즘이 있다.

Page 204.

대칭 암호화 기법(Symmetric encryption techniques)

대칭 암호화는 암호화하고 복호화하는 메시지를 위한 단일 키를 사용한다. 이 암호화의 타입은 블록 암호(block ciphers) 혹은 스트림 암호(stream ciphers)로 분류된다. 이러한 알고리즘에 대한 자세한 내용은 https://en.wikipedia.org/wiki/Symmetric-key_algorithm 에서 찾을 수 있다. 공급자(provider)는 암호화 알고리즘의 구현을 제공하고, 종종 그들 사이에서 선택한다.

자바가 지원하는 대칭 알고리즘은 비트에서 키 크기는 괄호로 둘러쌓여 다음과 같은 것을 포함한다. 

-AES(128)
-DES(56)
-DESede(168)
-HmacSHA1
-HmacSHA256

데이터의 다양한 길이는 암호화될 수 있다. 블록 암호 알고리즘(Block cipher algorithms)은 큰 데이터 블록을 처리하기 위해 사용된다. 다음에 열거된 것처럼 여러 가지 블록 암호 방식이있다. 이러한 모드가 여기서 작동하는 방법을 상세하게 표현하지 않지만, 자세한 내용은 https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation 에서 찾을 수 있다.

-ECB
-CBC
-CFB
-OFB
-PCBC

데이터를 암호화하거나 복호화하기 전에, 키가 필요하다.

키 생성

키를 생성하는 일반적인 방법은 KeyGenerator 클래스를 사용한다. 클래스에서 공용(public) 생성자는 없다고 하지만 오버로드된 getInstance 메소드는 KeyGenerator 인스턴스를 반환한다. 다음 예는 기본 공급자와 함께 AES 알고리즘을 사용한다. 이 메소드의 다른 버전은 공급자가 선택할 수 있다.

<소스>

Page 205.

generateKey 메소드는 다음 표시되는 SecretKey 인터페이스를 구현하는 오브젝트의 인스턴스를 반환한다. 대칭 암호화 및 복호화를 지원하기 위해 사용되는 키이다.

<소스>

키를 사용하여, 이제 데이터를 암호화 할 수 있다.

대칭 키를 이용한 암호화 텍스트

이 후 절에서 다음과 같은 암호화 메소드를 사용한다. 이 메소드는 암호화된 텍스트와 비밀 키가 전달된다. 평문(plain text)은 주로 암호화되지 않은 데이터를 참조하는 데 사용된다.

Cipher 클래스는 암호화 프로세스에 대한 프레임워크를 제공한다. getInstance 메소드는 AES 알고리즘을 사용하는 클래스의 인스턴스를 반환한다. Cipher 인스턴스는 Cipher를 사용하여 암호화를 위해 초기화된다. Cipher 인스턴스는 첫 번째 인자로 Cipher.ENCRYPT_MODE, 두 번째 인자로 비밀 키를 사용하여 암호화를 위해 초기화된다. doFinal 메소드는 평문 바이트 배열을 암호화하고 암호화된 바이트 배열을 반환한다. Base64 클래스의 getEncoder는 암호화된 바이트를 인코딩하는 인코더를 반환한다.

<소스>

암호화 바이트 배열을 인코딩하는 것은 나중에 사용할 수 있도록 문자열로 변환하는 데 사용된다. http://javarevisited.blogspot.sg/2012/03/why-character-array-isbetter-than.html에 설명된 것처럼 인코딩 스트링은 유용한 보안 기술이 될 수 있다.

Page 206.

복호화 텍스트

텍스트를 복호화하는 과정은 다음에 보여주는 decrypt 메소드에서 확인한다. 암호화된 바이트는 디코딩 및 암호 Cipher 클래스의 init 메소드는 비밀 키를 사용하여 바이트를 복호화 위해 초기화하는 역 과정을 사용한다.(수정)

<소스>

'대칭 암호화 클라이언트/서버' 절에 설명된 에코 클라이언트/서버 애플리케이션에서 이러한 메소드를 사용한다.

비대칭 암호화 기법

비대칭 암호화는 공개(public) 키와 개인(private) 키를 사용한다. 개인 키는 하나의 엔티티에 의해 열린다.(수정) 공개 키는 모두에게 사용할 수 있다. 데이터는 어느 키를 이용하여 암호화될 수 있다.

-데이터는 개인 키를 사용하여 암호화되면, 이 후 공개 키를 이용하여 복호화될 수 있다.
-데이터가 공개 키를 사용하여 암호화되면, 이 후 개인 키를 이용하여 복호화될 수 있다.

개인 키의 소유자는 개인 키를 사용하여 암호화된 메시지를 전송하는 경우, 이 메시지의 수신자의 공개 키를 복호화할 수 있다. 모든 메시지를 읽을 수 있지만, 단지 개인 키 소유자가 이 메시지를 보낸 것이라는 점을 알고있다.

2016.06.10

Page 207.

다른 사용자가 공개 키를 사용하여 메시지를 암호화하는 경우, 개인 키의 소유자는 그 메시지를 읽을 수 있다.(수정) 그러나 소유자가 실제로 메시지를 전송한 사람을 확신할 수 없다. 사기꾼이 될 수 있다.

두 당사자가 공개/개인 키의 자신의 세트를 가질 경우, 송신자와 수신자가 내용을 볼 수 있도록 보장할 수 있다. 또한 전송자가 그들이 말하는 그 누구가 있음을 보장할 수 있다.

Sue가 Bob에게 메시지를 송신하는 경우를 생각해보자. Sue는 그녀의 개인 키를 사용하여 메시지 M을 암호화한다. 이 메시지 M1를 호출할 수 있다. 그녀는 우리에게 M2를 주는 Bob의 공개 키를 사용하여 M1을 암호화한다. 메시지 M2는 이 후 Bob에 전송된다. 지금, 단지 Bob은 자신의 개인 키를 사용하여 이 메시지를 복호화할 수 있다. M1을 반환한다. Bob은 이제 원래의 메시지 M을 얻기 위한 M1를 복호화하기 위해 Sue의 공개 키를 사용할 수 있다. 그는 단지 Sue의 공개 키가 작동하기 때문에 Sue에서 알고있다.

메시지를 전송하는 과정은 모두 참가자들이 자신의 공개/개인 키를 소유해야 한다. 이것 또한, 대칭 키를 사용하는만큼 효과적이지 않다. 또다른 방법은 참가자들에게 비밀 키를 전송하는 비대칭 키를 사용하는 것이다. 비밀 키는 이 후 실제 메시지 전송을 위해 사용될 수 있다. SSL과 함께 사용되는 기술이다.

여러 비대칭 알고리즘이 있다. 자바는 다음의 암호화 알고리즘을 지원한다. 

-RSA
-Diffie-Hellman
-DSA

다음 선언된 AsymmetricKeyUtility 라고 불리는 클래스를 사용하여 비대칭 암호화/복호화를 살펴볼 것이다. 이 클래스는 생성, 저장, 로드 및 공개 키와 개인 키를 검색하는 메소드를 캡슐화한다. 이러한 메소드가 작업하는 방법과 비대칭 에코 클라이언트/서버 애플리케이션으로 나중에 사용하는 방법을 설명할 것이다.

<소스>

Page 208.

<소스>

2016.06.13

Page 216.

이 명령은 1,024비트의 키 크기와 365일 만료일자를 가진 RSA 알고리즘을 사용하여 serverkeystore.jck 키스토어 파일을 생성한다.

<명령>

이 명령은 클라이언트 애플리케이션에 의해 사용되는 clientkeystore.jck 키스토어를 생성한다.

<명령>

클라이언트의 인증서 파일은 다음에 생성되고 client.crt 파일에 배치된다.

<명령>

서버의 인증서는 여기에서 반출된다.

<명령>

트러스트 저장소(trust store)는 키스토어가 인증 정보를 생산하는 반면에, 인증 정보를 확인하는 데 사용되는 파일입니다.(수정) 인증 정보는 일반적으로 인증서의 형태를 취한다. 트러스트 스토어는 일반적으로 인증서 체인을 형성하기 위해 신뢰하는 서드 파티로부터 인증서를 얻는다.

Page 217.

다음 명령은 클라이언트의 신뢰 저장소인 클라이언트 clienttruststore.jck 파일을 생성한다.

<출력>

Page 218.

이 명령은 다음과 같은 출력을 생성한다. 

<출력>

출력은 다음과 같다.

<출력>

이제 자바에서 유사한 작업을 수행할 수 있는 방법을 살펴본다. 

Page 219.

자바로 키스토어 생성 및 유지

키스토어, 자신의 키 및 인증서는 자바 코드로 직접 생성될 수 있다. 이 절에서는, 비밀 키를 포함하는 키스토어를 생성하는 방법을 보여준다. '대칭 암호화 클라이언트/서버' 절에서 이 클래스를 사용한다.

다음과 같이 SymmetricKeyStoreCreation 클래스가 선언된다. main 메소드는 생성하고 비밀 키를 저장하는 동안 SymmetricKeyStoreCreation 메소드는 키스토어를 생성한다.

<소스>

createKeyStore 메소드에 대하여 설명한다. 키스토어 파일 이름과 암호는 전달된다. JCEKS 키스토어를 지정하면 KeyStore 인스턴스는 생성된다. 키스토어가 이미 존재하는 경우, 그 키스토어를 반환한다.

<소스>

Page 220.

2016.06.14

main 메소드에서, KeyGenerator 인스턴스는 AES 알고리즘을 사용하여 생성된다. 다음과 같이 generateKey 메소드는 SecretKey 인스턴스를 생성한다.

<소스>

KeyStore.SecretKeyEntry 클래스는 키스토어의 엔트리를 나타낸다. 이것과 함께 비밀 키를 저장하기 위해 암호를 나타내는 KeyStore.PasswordProtection 클래스의 인스턴스가 필요하다.

<소스>

다음과 같이 setEntry 메소드는 스트링 별명, 키스토어 엔트리 오브젝트 및 항목을 저장하기 위한 암호를 사용한다.

<소스>

이 엔트리는 키스토어에 기록된다.

<소스>

다른 키스토어 작업은 자바를 사용하여 가능하다. 

Page 221.

대칭 암호화 클라이언트/서버

이 절에서는 클라이언트/서버 애플리케이션에서 대칭 암호화/복호화를 사용하는 방법을 보여준다. 다음의 예제는 특정 클라이언트/서버 문제로 빗나가지 않고 기본 프로세스에 집중할 수 있도록 간단한 에코 클라이언트/서버를 구현한다. 서버는 SymmetricEchoServer 클래스로 SymmetricEchoClient 클래스를 이용하여 클라이언트가 구현된다.

클라이언트는 메시지를 암호화하고 서버로 전송하는 것이다. 서버는 메시지를 복호화하고 평문을 다시 전송한다. 필요한 경우 응답은 쉽게 암호화될 수 있다. 이 단방향 암호화는 기본적인 프로세스를 설명하기에 충분하다.

Windows에서 이 장에서 설명하는 애플리케이션을 실행하면 다음과 같은 대화 상자가 발생할 수 있다. 애플리케이션을 실행할 수 있도록 Allow access 버튼을 선택한다.

<그림>

2016.06.16

Page 224.

대칭 클라이언트 애플리케이션

클라이언트 애플리케이션은 다음에 설명되고, 1장 '네트워크 프로그래밍 시작'에서 개발된 클라이언트 애플리케이션과 매우 유사하다. 이 서버에서 사용되는 것과 동일한 getSecretKey 메소드를 사용한다. 대칭 암호화 기술에서 설명된 encrypt 메소드는 사용자의 메시지를 암호화하기 위해 사용된다. 이러한 메소드는 모두 여기에 복제되지 않는다.

<소스>

main 메소드는 1장, '네트워크 프로그래밍 시작'에서 while 루프의 버전과 다르다. 다음 문장은 사용자 메시지를 암호화한다.

<소스>

Page 225.

main 메소드는 다음과 같다.

<소스>

이제 클라이언트 및 서버가 상호작용하는 방법을 살펴보자.

Page 226.

진행중인 대칭 클라이언트/서버

애플리케이션은 1장, '네트워크 프로그래밍 시작'에서와 같은 방식으로 작동한다. 유일한 차이는 서버로 전송된 메시지가 암호화된다는 것이다. 이 암호화는 클라이언트 측의 암호문의 표시보다 애플리케이션의 출력에 나타나지 않는다. 하나의 가능한 상호작용은 다음과 같다.

<결과>

다음은 클라이언트 애플리케이션 출력이다. 

<결과>

비대칭 키를 사용하여 이 기능을 복제할 것이다.

Page 227.

비대칭 암호화 클라이언트/서버

비대칭 암호화 기술에서 개발한 AsymmetricKeyUtility 클래스는 클라이언트와 서버 애플리케이션을 지원하기 위해 사용된다. encrypt 메소드와 decrypt 메소드를 사용할 것이다. 클라이언트 및 서버 애플리케이션의 구조는 이전 절에서 사용된 것과 유사하다. 클라이언트는 서버에게 암호화된 메시지를 전송하면, 서버는 메시지를 복호화하고, 평문으로 응답한다.

2016.06.17

비대칭 서버 애플리케이션

다음 선언된 AsymmetricEchoServer 클래스는 서버에서 사용된다. main 메소드가 유일한 메소드이다. 클라이언트 요청을 기다리는 accept 메소드에서 블록하는 서버 소켓은 생성된다.

<소스>

클라이언트 연결 IO(client connection IO)의 수용으로, 스트림은 설정되고, inputLine 바이트 배열은 171의 크기로 인스턴스화된다. 이것은 전송되는 메시지의 크기이며, 이 값을 사용하면 다양한 예외를 피할 것이다.

<소스>

Page 228.

<소스>

복호화를 수행하기 위해, 개인 키가 필요하다. getPrivateKey 메소드를 사용하여 얻어진다.

<소스>

while 루프는 클라이언트에서 암호화된 메시지에서 읽는다. decrypt 메소드는 메시지와 개인 키라고 부른다. 복호화 메시지는 표시되고 다시 클라이언트로 전송된다. 메시지가 quit인 경우, 이 후 서버는 종결한다.

<소스>

이제, 클라이언트 애플리케이션을 살펴보자.

비대칭 클라이언트 애플리케이션

다음과 같이, 클라이언트 애플리케이션은 AsymmetricEchoClient 클래스에서 확인된다. 또한 하나의 main 메소드가 있다. 서버 연결이 설정되면, IO 스트림은 확립된다.

<소스>

Page 229.

<소스>

Scanner 클래스는 사용자 입력을 가져오는 데 사용된다. 공개 키는 사용자가 메시지를 암호화하기 위해 사용되고 AsymmetricKeyUtility 클래스의 getPublicKey 메소드를 사용하여 얻어진다.

<소스>

다음 while 루프에서, 사용자는 encrypt 메소드를 사용하여 암호화된 메시지를 입력하라는 메시지가 표시된다. 암호화된 메시지는 서버로 전송된다. 메시지가 quit이면, 프로그램은 종료된다.

<소스>

이제, 이러한 애플리케이션을 함께 사용할 수 있다.

Page 230.

2016.06.20

Page 243.

비 JVM 언어와 인터페이스

다른 언어 코드를 접속하는 일반적인 기법은 JNI API를 통해서이다. 이 API는 C/C++ 코드를 접속하는 방법을 제공한다. 이 방법은 잘 문서화되어, 여기에서는 설명하지 않는다. 그러나,이 API에 대한 좋은 소개는 http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html 에서 찾을 수 있다.

자바에서 .NET 코드를 접속할 수 있게한다. 하나의 기술은 C #을 접속하는 JNI를 사용한다. 관리된 C++, C#코드, C++에 접속하는 방법의 예제는 http://www.codeproject.com/Articles/13093/C-method-calls-within-a-Java-program에서 찾을 수 있다.

Page 244.

간단한 소켓을 이용한 통신

소켓을 사용하는 다른 언어로 작성된 애플리케이션 간에 정보를 전송하는 것은 가능하다. 소켓 개념은 자바에서 고유하지않고 많은 언어로 구현된다. 소켓은 TCP/IP 레벨에서 작동하여, 많은 노력없이 통신할 수 있다.

주요한 상호운용성의 고려사항은 송신되는 데이터에 관한 것이다. 데이터의 내부 표현은 두 언어 간에 크게 다르다면, 호환성 문제가 발생할 수 있다. 데이터 형식은 내부적으로 표현하는 방법에서 리틀 엔디안과 빅 엔디안의 사용에 기인할 수 있으며, 특정 데이터 타입도 다른 언어에서 존재할지도 모른다. 예를 들어, C에서는 Boolean 데이터 타입이 구별되지 않는다. 정수를 이용하여 표현된다.

이 절에서는 자바 서버와 C# 클라이언트를 개발한다. 소켓의 사용을 설명하기 위해, 스트링은 두 애플리케이션 간에 전송된다. 스트링 같은 단순 데이터 타입을 전송하기는 것을 발견하는 것은 보는 것보다 더 어려울 수 있다.(수정)

자바 서버

다음과 같이 서버는 JavaSocket 클래스에 선언됐다. 이 책에서 개발된 에코 서버의 이전 버전과 매우 비슷하다. 클라이언트에 연결된 소켓으로 accept 메소드가 반환될 때까지 서버 소켓은 생성되고 블록한다.

<소스>

Page 245.

Scanner 클래스는 클라이언트에서 전송된 메시지를 읽는 데 사용된다. PrintWriter 인스턴스는 클라이언트에 응답하는 데 사용된다.

<소스>

nextLine 메소드는 메시지를 검색하고 클라이언트로 재 전송되고 보여준다.

<소스>

서버는 종료될 것이다.

이제, C # 애플리케이션을 살펴보자.

C# 클라이언트

CSharpClient 클래스는 다음과 같은 클라이언트를 구현한다. 클래스 라이브러리는 종종 다르지만 C#은 자바와 형식과 구문과 유사하다. 코드의 상세한 설명을 제공하지 않지만, 애플리케이션의 중요한 기능을 포함한다.

using 문은 자바의 import 문에 해당한다. 자바와 비슷하게, 실행하는 첫 번째 메소드는 Main 메소드이다. C#은 일반적으로 자바와 다른 들여쓰기 스타일(indention style)과 이름 규칙(name convention)을 사용한다.

<소스>

Page 246.

IPEndPoint 변수는 인터넷 주소를 나타내고, Socket 클래스는 소켓을 나타내는 것으로 예상될 수 있다. Connect 메소드는 서버에 연결한다.

<소스>

Console 클래스의 Write 메소드는 커맨드 윈도우(command window)에 정보를 표시한다. 여기에서, 사용자에게 서버에 전송할 메시지를 입력하라는 메시지가 표시된다. ReadLine 메서드는 사용자의 입력에서 읽는다.

<소스>

Send 메소드는 데이터를 서버에 전송한다. 그러나, 다음과 같이 바이트 버퍼에 배치되는 데이터를 필요로한다. 메시지와 추가된 캐리지 리턴/라인 피드 캐릭터는 버퍼에서 인코딩되고 삽입된다.(수정) 서버가 올바르게 스트링을 판독하고 스트링이 종료시기를 알 수 있도록 추가 문자가 필요하다.(수정)

<소스>

Receive 메소드는 서버의 응답을 판독한다. Send 메서드와 유사하게, 바이트 버퍼가 필요하다. 이 버퍼는 32 바이트의 크기로 생성됐다. 이것은 메시지의 크기를 제한하지만 곧 이러한 한계를 극복하는 방법을 논의할 것이다.

<소스>

수신 버퍼는 스트링으로 변환되고 표시된다. 시작과 닫는 괄호는 명확하게 버퍼를 묘사하는 데 사용된다.

<소스>

소켓은 닫히고 애플리케이션은 종료된다.

<소스>

Page 247.

활동하는 클라이언트/서버

서버와 다음 클라이언트를 시작한다. 클라이언트의 사용자는 메시지를 입력하라고 표시된다. 메시지를 입력한다. 메시지는 전송되고 응답은 클라이언트 창에 표시된다.

서버 출력은 여기에 표시된다.

<출력>

2016.06.21

Page 248.

미들웨어를 통한 상호운용성

네트워크 기술은 지난 20 년 동안 상당히 진화했다. 로우 레벨 소켓 지원은 이러한 기술의 대부분을 위한 기반을 제공한다. 그러나 소프트웨어의 다중 레이어를 통해 사용자로부터 숨겨져 있다. 이 레이어를 미들웨어(middleware)라고한다.

상호운용성은 JMI, SOAP, 그리고 JAX-WS- 같은 몇 가지를 언급으로, 미들웨어를 통해 달성된다. 자바 EE 에디션은 이러한 미들웨어형 기술 지원을 주로 목표로 한다. 자바 EE는 서블릿과 웹 페이지를 지원하는 데 사용된 자바 애플리케이션으로 시작한다. 그것은 JSP(Java Server Pages)를 포함하여 진화했고 결국 Servlets에 숨어있는 Faclets다.(수정)


 