Page 169.

-서버 용량
-다중 스레드
-네트워크 대역폭(bandwidth)과 레이턴시(latency)
-실행 환경

확장성은 적절한 수의 스레드를 사용하고, 실행 환경의 성능을 개선하고, 병목현상을 제거하기 위한네트워크 대역폭을 증가시켜 서버를 추가에 의해서 성취될 수 있다.

더 많은 서버를 추가하는 것은 서버 간에 로드밸런싱(load balancing)을 활성화하여 도움이 될 것이다. 그러나 네트워크 대역폭이나 대기 시간(latency)에 문제가 있다면, 이것은 훨씬 도움이 되지 않는다. 너무 많이 있는 네트워크 파이프를 통해 푸시할 수 있다.(수정해야함)

스레드는 종종 시스템의 성능을 개선하기 위해 사용된다. 시스템에 대한 적절한 수의 스레드를 사용하면 다른 스레드가 블록되는 동안 일부 스레드가 실행할 수 있다. 블록된 스레드는 IO가 발생하거나 사용자가 응답하는 것을 대기할 수 있다. 블록된 일부는 애플리케이션 처리량을 증가시킬 수 있어서 다른 쓰레드를 허용하면 실행한다.(수정해야함)

Page 170.

실행 환경은 기본적인 하드웨어, 운영체제, JVM, 애플리케이션 그 자체를 포함한다. 이러한 각 영역은 향상을 위한 후보이다. 즉 통제할 수 없기 때문에 하드웨어 환경을 해결하지 않는다. 같은 것은 운영체제의 사실이다. 약간의 성능 향상은 달성할 수 있지만, 이 부분을 해결하지 않는다. 네트워크 성능에 영향을 미치는 JVM 파라미터를 구별한다.

Page 173.

thread-per-request 서버

이 예제에서, 부품의 이름이 주어질 때 서버는 가격에 대한 요청을 받아들일 것이다. 구현은 부품 이름과 가격에 대한 병렬 접속을 지원하는 ConcurrentHashMap 클래스를 사용한다. 멀티스레드 환경에서, ConcurrentHashMap 클래스 같은 병렬 데이터 구조는 데이터 손실에 대한 가능성 없는 동작을 처리한다. 또한, 이 맵은 애플리케이션의 성능을 개선하는데 유용할 수 있는 캐시의 예제이다.

다음과 같은 서버의 선언으로 시작한다. 하나의 인스턴스가 서버에 필요하기 때문에 지도(map)은 정적(static)으로 선언된다. 정적 초기화 블록(static initialization block)은 맵을 초기화한다. main 메소드는 클라이언트의 요청을 수락하기 위해 ServerSocket 클래스를 사용한다. run 메소드로 처리된다. clientSocket 변수는 클라이언트 소켓에 대한 참조를 보유한다.

<소스>

main 메소드는 서버 소켓이 클라이언트 요청을 대기하고 처리하는 스레드를 위한 클라이언트 소켓이 전달하는 새로운 쓰레드를 생성하는 것은 다음과 같다. 메시지는 연결이 수락하는 것을 보여주는 표시이다.

<소스>

Page 174.

<소스>

다음과 같이, run 메소드는 요청을 처리한다. 입력 스트림(input stream)은 클라이언트 소켓으로부터 획득되고, 부품 이름은 읽혀진다. 맵(map)의 get메소드는 가격을 검색하기 위한 이름을 사용한다. 입력 스트림은 클라이언트로 가격을 재전송하고, 작업의 진행 상황은 표시된다.

<소스>

이제, 서버에 대한 클라이언트를 개발하자.

Page 175.

thread-per-request 클라이언트

다음과 같이, 클라이언트 애플리케이션은 서버에 연결하고, 요청을 전송하고 응답을 기다린 후, 가격을 표시한다. 이 예제에서는, 클라이언트와 서버는 동일한 머신에 존재한다.

<소스>

이제, 클라이언트와 서버의 상호작용 방법을 살펴보자. 

실행중인 thread-per-request 애플리케이션

다음과 같은 출력을 표시하는 첫 번째 서버를 시작한다. 

Multi-Threaded Server Started
Listening for a client connection

다음에, 클라이언트 애플리케이션을 시작한다. 다음 출력은 표시된다.

Client Started
Connected to a Server

Page 176.

Axle request sent
Response: 238.5
Client Terminated

서버는 다음과 같은 출력이 표시된다. "Client Thread Started" 출력은 "Listening for a client connection" 출력을 따른다. 스레드를 시작하기 전에 약간의 지연이 존재하기 때문이다.

Connected to a Client
Listening for a client connection
Client Thread Started
Request for Axle and returned a price of $238.50
Client Connection Terminated
Client Thread Terminated

클라이언트 스레드는 시작하여, 요청을 처리하고 종료한다.

<소스>

클라이언트가 실행되면 다음과 같은 출력을 얻을 것이다. 두 번째 스트링에 대한 응답은 null이다. 첫 번째 요청에 대한 응답 후에 서버의 응답 스레드가 종료되기 때문이다.

<결과>

Page 177.

이 방법을 사용하여 여러 요청을 처리하려면 다시 연결하고 별도의 요청을 전송해야한다. 다음 코드는 이 방법을 보여준다. 두 번째 요청을 전송한 코드 세그먼트를 제거한다. 이 시퀀스에서, 소켓은 다시 열리고, IO스트림은 재생성되며, 메시지는 다시 전송된다.

<소스>

클라이언트가 실행되면, 그것은 두 요청 및 응답을 반영한 다음 출력을 생성한다. 

<결과>

서버 측에서, 다음과 같은 출력을 얻을 것이다. 두 개의 스레드는 요청을 처리하기 위해 생성됐다.

<결과>

Page 178.

<결과>

접속의 개방(opening)과 폐쇠(closing)는 값비쌀 수 있다. 다음 섹션에서, 이러한 유형의 문제를 해결한다. 단 하나의 요청이 이루어지는 경우, 다음 thread-per-request은 작동한다.

Thread-per-connection 접근

이 방식에서, 단일 스레드는 모든 클라이언트의 요청을 처리하기 위해 사용된다. 이 방법은 클라이언트가 더 이상 요청이 없는 일종의 통지를 전송할 것을 요구할 것이다. 명시적으로 통지하는 대신에, 타임 아웃은 충분한 시간이 경과 한 후 자동으로 클라이언트의 연결을 해제하도록 설정될 필요가 있다.

thread-per-connection 서버

2016.06.01

Page 180.

스레드 풀

생성된 스레드의 수가 제한될 때 스레드 풀이 유용하다. 풀은 사용하는 것은 많은 스레드를 생성되는 방법을 제어하는 뿐만 아니라, 그것은 또한 종종 비용이 많이 드는 작업에서 반복적으로 스레드를 생성하고 파괴하기 위해 필요를 제거 할 수 있다. 

다음 그림은 스레드 풀을 보여준다. 요청은 풀의 스레드에 할당된다. 가능한 사용하지 않는 스레드가 없는 경우 일부 스레드 풀은 새 스레드를 생성한다. 그 외는 사용 가능한 스레드의 수를 제한한다. 이것은 일부 요청에 블록된 결과가 발생할 수 있다.

Page 181.

<그림>

ThreadPoolExecutor 클래스를 사용하여 스레드 풀을 살펴볼 것이다. 이 클래스는 스레드 실행에 대한 상태 정보를 제공하는 메소드를 제공한다.

ThreadPoolExecutor 클래스는 여러 생성자를 가지고 있지만, Executors 클래스는 ThreadPoolExecutor 클래스의 인스턴스를 생성하는 쉬운 방법을 제공한다. 이 메소드 중에 두 가지를 살펴볼 것이다. 첫째, newCachedThreadPool 메소드를 사용한다. 이 메소드에 의해 생성된 풀은 스레드를 재사용한다. 필요할 때 새로운 스레드가 생성된다. 그러나, 너무 많은 스레드가 생성되는 문제가 발생할 수 있다. 두 번째 메소드인 newFixedThreadPool은 스레드의 고정된 크기의 풀을 생성한다.

ThreadPoolExecutor 클래스 특징

이 클래스의 인스턴스가 생성될 때, 스레드 풀에 전달되는 새로운 작업을 허용한다. 그러나 풀은 자동으로 종료되지 않는다. 유휴(idle)의 경우, 새 작업이 전송될 때까지 기다린다. 풀을 종료하기위해, shutdown 메소드 혹은 shutdownNow 메소드를 호출해야한다. 후자의 메소드는 바로 풀을 종료하고 대기중인 작업을 처리하지 않는다.

ThreadPoolExecutor 클래스는 추가 정보를 제공하는 다수의 메소드를 가진다. 예를 들어, getPoolSize 메소드는 풀의 현재 스레드의 수를 반환한다. getActiveCount 메소드는 활성 스레드 수를 반환한다. getLargestPoolSize 메소드는 한번에 풀에 있는 최대 스레드의 수를 반환한다. 사용가능한 여러 가지 다른 메소드가 있다.

Page 182.

간단한 스레드 풀 서버

부품의 이름을 부여할 때 스레드 풀을 보여주기 위해 사용하는 서버는 부품의 가격을 반환한다. 각 스레드는 부품 정보를 보유하는 ConcurrentHashMap 인스턴스에 접근할 것이다. 그것은 여러 스레드에서 접근할 수 있으므로 해시 맵(hash map)의 병렬 버전(concurrent version)을 사용한다.

ThreadPool 클래스는 다음에 선언된다. main 메소드는 실제 작업을 수행하는 WorkerThread 클래스를 사용한다. main 메소드에서, newCachedThreadPool 메소드는 쓰레드 풀을 생성하기 위해 호출된다.

<소스>

다음으로, try 블록은 발생할 수 있는 예외를 처리하고 캐치(catch)하는 데 사용된다. try 블록에서, 서버 소켓이 생성되고 클라이언트 연결이 요청될 때까지 메소드의 블록을 받아들인다. 다음 코드와 같이, 연결이 설정되면 WorkerThread 인스턴스는 클라이언트 소켓을 사용하여 생성된다.

<소스>

Page 183.

지금, 다음에 표시되는 WorkerThread 클래스를 살펴보자. 스트링은 키로서 사용되는 ConcurrentHashMap 인스턴스를 선언하고 저장되는 오브젝트는 float이다. 해시 맵은 정적 초기화 블록에 초기화된다.

<소스>

다음과 같은 클래스의 생성자는 나중에 사용하기 위해 clientSocket 인스턴스 변수에 클라이언트 소켓을 할당한다.

<소스>

run 메소드는 요청을 처리한다. 입력 스트림은 클라이언트 소켓에서 획득하고 부품 이름을 가져오는 데 사용된다. 이 이름은 해당 가격을 얻을 수 있는 해시 맵의 get 메소드의 인자로 사용된다. 이 가격은 클라이언트로 다시 전송되고, 메시지가 응답을 나타내는 표시된다.

<소스>

Page 184.

<소스>

이제 클라이언트 애플리케이션을 살펴보자.

간단한 스레드 풀 클라이언트

이 애플리케이션은 서버에 대한 연결을 확립하기 위해 Socket 클래스를 사용한다. 입력 및 출력 스트림은 전송하고 응답을 수신하는 데 사용된다. 이 방법은, 1장, '네트워크 프로그래밍 시작하기'에서 살펴봤다. 클라이언트 애플리케이션은 다음과 같다. 연결은 서버에 확립되고, 부품 가격에 대한 요청은 서버로 전송된다. 응답은 획득되고 표시된다.

<소스>

이제 함께 작동하는 방법을 살펴보자.

Page 185.

진행중인 스레드 풀 클라이언트/서버

우선 서버 애플리케이션을 시작한다. 다음과 같은 출력을 확인한다.

Thread Pool Server Started
Listening for a client connection

다음으로, 클라이언트를 시작한다. 차축 가격(axle price)에 대한 요청이 전송되어 다음과 같은 출력을 생성하고 238.5의 응답이 수신된다.

Client Started
Connected to a Server
Axle request sent
Response: 238.5
Client Terminated

서버 측에서는 다음과 유사한 출력이 표시된다. 스레드가 생성되고, 요청 및 응답 데이터가 표시된다. 그 후 스레드는 종료된다. 스레드의 이름이 스트링 "packt"로 시작된다는 점에 유의한다. 애플리케이션 패키지의 이름이다.

Connected to a Client
Task created: packt.WorkerThread@33909752
Listening for a client connection
Worker Thread Started
Request for Axle and returned a price of $238.50
Client Connection Terminated
Worker Thread Terminated

두 번째 클라이언트를 시작하면, 서버는 다음과 유사한 출력을 생성한다. 새 스레드가 각 요청에 대해 생성된다는 점에 유의한다.

Thread Pool Server Started
Listening for a client connection
Connected to a Client
Task created: packt.WorkerThread@33909752

Page 186.

<결과>

Callable와 스레드 풀

Callable와 Future 인터페이스를 사용하는 것은 다중 스레드를 지원하는 또다른 접근 방식을 제공한다. Callable 인터페이스는 결과를 반환할 필요가 있는 스레딩을 지원한다. Runnable 인터페이스 run 메소드는 값을 반환하지 않는다. 어떤 스레드의 경우, 이것은 문제가 될 수 있다. Callable 인터페이스는 값을 반환하고 대신에 Runnable 인터페이스를 사용할 수 있고 하나의 메소드, call를 보유하고 있다.(수정해야함)

Future 인터페이스는 Callable 오브젝트와 함께 사용된다. 아이디어는 call 메소드가 호출되고 현재의 스레드가 다른 작업을 계속 수행하는 것이다. Callable 오브젝트가 완료되면, get메소드는 결과를 검색하기 위해 사용된다. 필요한 경우 이 메소드는 블록될 것이다.

Callable 사용

이전에 생성한 WorkerThread 클래스를 보완하기 위해 Callable 인터페이스를 사용한다. WorkerThread 클래스의 부품 이름 해시 맵을 배치를 대신하여, 가격을 반환하는 call 메소드를 오버라이드하는 WorkerCallable 클래스로 이동한다. 실제로 이 애플리케이션에서 추가 작업이지만, Callable 인터페이스를 사용하는 하나의 방법을 보여준다. Callable 오브젝트에서 값을 반환하는 방법을 보여준다.

2016.06.02

Page 187.

다음 선언된 WorkerCallable 클래스는, 생성과 초기화하는 해시 맵을 위해 동일한 코드를 사용한다. 

<소스>

다음과 같이 생성자는 부품 이름을 초기화한다. 

<소스>

call 메소드는 다음과 같다. 지도는  표시한 후 반환 가격을 얻는다.

<소스>

다음, 다음 문을 제거하여 WorkerThread 클래스를 수정한다.

<소스>

다음 코드로 변환한다. 새로운 WorkerCallable 인스턴스는 클라이언트에서 요청된 부품 이름을 사용하여 생성된다. call 메소드는 바로 호출되고 해당 부품의 가격을 반환한다.

<소스>

Page 188.

WorkerCallable 클래스의 call 메소드가 실행되었음을 나타내는 메시지를 볼 것을 제외하고 애플리케이션은 이전과 동일한 출력을 생성한다. 다른 스레드가 생성되는 동안, call 메소드가 반환될 때까지 블록한다.

이 예제에서는 완전하게 이 방법의 힘을 나타내지 않는다. Future 인터페이스는 이 기술을 향상시킬 수 있다.

Future 사용

Future 인터페이스는 완성된 call 메소드의 결과를 나타낸다. 이 인터페이스를 통해, Callable 오브젝트를 호출하고 반환할 수 없다. 부품 가격을 계산하는 과정은 표에서 보는 것보다 더 복잡하다고 가정한다. 여러 단계는 가각 가격을 계산해야하는 것을 요청되고 완료하는 데 약간의 시간이 걸릴 수 있다는 생각할 수 있다.(수정해야함) 이러한 별도의 단계가 동시에 수행될 수 있다고 가정한다.

다음 코드를 사용하여 이전 예제를 교체한다. 두 단계 가격 결정 과정을 나타내는 두 개의 Callable 오브젝트를 할당하는 새로운 ThreadPoolExecutor 인스턴스를 생성한다. Future 인스턴스를 반환하는 submit 메소드를 사용하여 수행한다. call 메소드의 구현은 간단한 예제를 유지하기 위한 각각 1.0과 2.0을 반환한다.

<소스>

Page 189.

다음으로, 가격의 두 부품을 얻기 위해 get 메소드를 사용하는 다음 try 블록을 추가한다. 부품에 대한 가격을 결정하는 데 사용된다. 상응하는 Callable 오브젝트가 완료되지 않은 경우, get 메소드는 블록된다.

<소스>

이 코드가 실행되면, 부품에 대한 3.0의 가격을 얻을 것이다. Callable과 Future 인터페이스의 결합은 쉽게 값을 반환하는 스레드를 처리하는이 기술을 사용하여 제공한다.

HttpServer 실행기 사용

4장, '클라이언트/서버 개발'에서 HTTPServer 클래스를 살펴봤다. HTTP 서버가 요청을 수신할 때, 기본적으로는 start 메소드가 호출될 때 생성된 스레드를 사용한다. 그러나 다른 스레드를 사용할 수 있다. setExecutor 메소드는 이러한 요청을 스레드에 할당하는 방법을 지정한다.

이 메소드의 인자는 Executor 오브젝트이다. 이 인자에 대해 여러 구현을 사용할 수 있다. 다음과 같은 순서로, 캐시된 스레드 풀을 사용한다.

<소스>

다음과 같이 서버에 의해 사용되는 스레드의 수를 제어하기 위해, 크기 5의 고정 스레드 풀을 사용할 수 있다. 

<소스>

HTTPServer의 start 메소드를 호출하기 전에 이 메소드는 호출되야한다. 모든 요청은 다음 실행기(executor)에 제출된다. 다음은 4장, '클라이언트/서버 개발'에서 개발된 HTTPServer 클래스로부터 중복되고, setExecutor 메소드의 사용을 보여준다.

<소스>

Page 190.

<소스>

이전과 같이 서버는 동일한 방식으로 수행되지만, 대신 캐시 스레드 풀을 사용한다.

selector 사용

selector는 NIO 애플리케이션에서 사용되고 하나의 스레드가 여러 채널을 처리하도록 한다. selector는 여러 채널과 이벤트를 조정한다. 처리를 위한 준비가 된 채널을 식별한다. 채널당 스레드를 사용한다면, 자신이 자주 스레드간에 전환을 찾을 수 있다. 이 전환 과정은 비용이 많이들 수 있다. 다중 채널을 처리하는 하나의 스레드를 사용하여 오버 헤드의 일부를 피한다.

