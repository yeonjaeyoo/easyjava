Page 169.

-서버 용량
-다중 스레드
-네트워크 대역폭(bandwidth)과 레이턴시(latency)
-실행 환경

확장성은 적절한 수의 스레드를 사용하고, 실행 환경의 성능을 개선하고, 병목현상을 제거하기 위한네트워크 대역폭을 증가시켜 서버를 추가에 의해서 성취될 수 있다.

더 많은 서버를 추가하는 것은 서버 간에 로드밸런싱(load balancing)을 활성화하여 도움이 될 것이다. 그러나 네트워크 대역폭이나 대기 시간(latency)에 문제가 있다면, 이것은 훨씬 도움이 되지 않는다. 너무 많이 있는 네트워크 파이프를 통해 푸시할 수 있다.(수정해야함)

스레드는 종종 시스템의 성능을 개선하기 위해 사용된다. 시스템에 대한 적절한 수의 스레드를 사용하면 다른 스레드가 블록되는 동안 일부 스레드가 실행할 수 있다. 블록된 스레드는 IO가 발생하거나 사용자가 응답하는 것을 대기할 수 있다. 블록된 일부는 애플리케이션 처리량을 증가시킬 수 있어서 다른 쓰레드를 허용하면 실행한다.(수정해야함)

Page 170.

실행 환경은 기본적인 하드웨어, 운영체제, JVM, 애플리케이션 그 자체를 포함한다. 이러한 각 영역은 향상을 위한 후보이다. 즉 통제할 수 없기 때문에 하드웨어 환경을 해결하지 않는다. 같은 것은 운영체제의 사실이다. 약간의 성능 향상은 달성할 수 있지만, 이 부분을 해결하지 않는다. 네트워크 성능에 영향을 미치는 JVM 파라미터를 구별한다.

Page 173.

thread-per-request 서버

이 예제에서, 부품의 이름이 주어질 때 서버는 가격에 대한 요청을 받아들일 것이다. 구현은 부품 이름과 가격에 대한 병렬 접속을 지원하는 ConcurrentHashMap 클래스를 사용한다. 멀티스레드 환경에서, ConcurrentHashMap 클래스 같은 병렬 데이터 구조는 데이터 손실에 대한 가능성 없는 동작을 처리한다. 또한, 이 맵은 애플리케이션의 성능을 개선하는데 유용할 수 있는 캐시의 예제이다.

다음과 같은 서버의 선언으로 시작한다. 하나의 인스턴스가 서버에 필요하기 때문에 지도(map)은 정적(static)으로 선언된다. 정적 초기화 블록(static initialization block)은 맵을 초기화한다. main 메소드는 클라이언트의 요청을 수락하기 위해 ServerSocket 클래스를 사용한다. run 메소드로 처리된다. clientSocket 변수는 클라이언트 소켓에 대한 참조를 보유한다.

<소스>

main 메소드는 서버 소켓이 클라이언트 요청을 대기하고 처리하는 스레드를 위한 클라이언트 소켓이 전달하는 새로운 쓰레드를 생성하는 것은 다음과 같다. 메시지는 연결이 수락하는 것을 보여주는 표시이다.

<소스>

Page 174.

<소스>

다음과 같이, run 메소드는 요청을 처리한다. 입력 스트림(input stream)은 클라이언트 소켓으로부터 획득되고, 부품 이름은 읽혀진다. 맵(map)의 get메소드는 가격을 검색하기 위한 이름을 사용한다. 입력 스트림은 클라이언트로 가격을 재전송하고, 작업의 진행 상황은 표시된다.

<소스>

이제, 서버에 대한 클라이언트를 개발하자.

Page 175.

thread-per-request 클라이언트

다음과 같이, 클라이언트 애플리케이션은 서버에 연결하고, 요청을 전송하고 응답을 기다린 후, 가격을 표시한다. 이 예제에서는, 클라이언트와 서버는 동일한 머신에 존재한다.

<소스>

이제, 클라이언트와 서버의 상호작용 방법을 살펴보자. 

실행중인 thread-per-request 애플리케이션

다음과 같은 출력을 표시하는 첫 번째 서버를 시작한다. 

Multi-Threaded Server Started
Listening for a client connection

다음에, 클라이언트 애플리케이션을 시작한다. 다음 출력은 표시된다.

Client Started
Connected to a Server

Page 176.

Axle request sent
Response: 238.5
Client Terminated

서버는 다음과 같은 출력이 표시된다. "Client Thread Started" 출력은 "Listening for a client connection" 출력을 따른다. 스레드를 시작하기 전에 약간의 지연이 존재하기 때문이다.

Connected to a Client
Listening for a client connection
Client Thread Started
Request for Axle and returned a price of $238.50
Client Connection Terminated
Client Thread Terminated

클라이언트 스레드는 시작하여, 요청을 처리하고 종료한다.

<소스>

클라이언트가 실행되면 다음과 같은 출력을 얻을 것이다. 두 번째 스트링에 대한 응답은 null이다. 첫 번째 요청에 대한 응답 후에 서버의 응답 스레드가 종료되기 때문이다.

<결과>

Page 177.

이 방법을 사용하여 여러 요청을 처리하려면 다시 연결하고 별도의 요청을 전송해야한다. 다음 코드는 이 방법을 보여준다. 두 번째 요청을 전송한 코드 세그먼트를 제거한다. 이 시퀀스에서, 소켓은 다시 열리고, IO스트림은 재생성되며, 메시지는 다시 전송된다.

<소스>

클라이언트가 실행되면, 그것은 두 요청 및 응답을 반영한 다음 출력을 생성한다. 

<결과>

서버 측에서, 다음과 같은 출력을 얻을 것이다. 두 개의 스레드는 요청을 처리하기 위해 생성됐다.

<결과>

Page 178.

<결과>

접속의 개방(opening)과 폐쇠(closing)는 값비쌀 수 있다. 다음 섹션에서, 이러한 유형의 문제를 해결한다. 단 하나의 요청이 이루어지는 경우, 다음 thread-per-request은 작동한다.

Thread-per-connection 접근

이 방식에서, 단일 스레드는 모든 클라이언트의 요청을 처리하기 위해 사용된다. 이 방법은 클라이언트가 더 이상 요청이 없는 일종의 통지를 전송할 것을 요구할 것이다. 명시적으로 통지하는 대신에, 타임 아웃은 충분한 시간이 경과 한 후 자동으로 클라이언트의 연결을 해제하도록 설정될 필요가 있다.

thread-per-connection 서버

2016.06.01

Page 180.

스레드 풀

생성된 스레드의 수가 제한될 때 스레드 풀이 유용하다. 풀은 사용하는 것은 많은 스레드를 생성되는 방법을 제어하는 뿐만 아니라, 그것은 또한 종종 비용이 많이 드는 작업에서 반복적으로 스레드를 생성하고 파괴하기 위해 필요를 제거 할 수 있다. 

다음 그림은 스레드 풀을 보여준다. 요청은 풀의 스레드에 할당된다. 가능한 사용하지 않는 스레드가 없는 경우 일부 스레드 풀은 새 스레드를 생성한다. 그 외는 사용 가능한 스레드의 수를 제한한다. 이것은 일부 요청에 블록된 결과가 발생할 수 있다.

Page 181.

<그림>

ThreadPoolExecutor 클래스를 사용하여 스레드 풀을 살펴볼 것이다. 이 클래스는 스레드 실행에 대한 상태 정보를 제공하는 메소드를 제공한다.

ThreadPoolExecutor 클래스는 여러 생성자를 가지고 있지만, Executors 클래스는 ThreadPoolExecutor 클래스의 인스턴스를 생성하는 쉬운 방법을 제공한다. 이 메소드 중에 두 가지를 살펴볼 것이다. 첫째, newCachedThreadPool 메소드를 사용한다. 이 메소드에 의해 생성된 풀은 스레드를 재사용한다. 필요할 때 새로운 스레드가 생성된다. 그러나, 너무 많은 스레드가 생성되는 문제가 발생할 수 있다. 두 번째 메소드인 newFixedThreadPool은 스레드의 고정된 크기의 풀을 생성한다.

ThreadPoolExecutor 클래스 특징

이 클래스의 인스턴스가 생성될 때, 스레드 풀에 전달되는 새로운 작업을 허용한다. 그러나 풀은 자동으로 종료되지 않는다. 유휴(idle)의 경우, 새 작업이 전송될 때까지 기다린다. 풀을 종료하기위해, shutdown 메소드 혹은 shutdownNow 메소드를 호출해야한다. 후자의 메소드는 바로 풀을 종료하고 대기중인 작업을 처리하지 않는다.

ThreadPoolExecutor 클래스는 추가 정보를 제공하는 다수의 메소드를 가진다. 예를 들어, getPoolSize 메소드는 풀의 현재 스레드의 수를 반환한다. getActiveCount 메소드는 활성 스레드 수를 반환한다. getLargestPoolSize 메소드는 한번에 풀에 있는 최대 스레드의 수를 반환한다. 사용가능한 여러 가지 다른 메소드가 있다.

Page 182.

간단한 스레드 풀 서버

부품의 이름을 부여할 때 스레드 풀을 보여주기 위해 사용하는 서버는 부품의 가격을 반환한다. 각 스레드는 부품 정보를 보유하는 ConcurrentHashMap 인스턴스에 접근할 것이다. 그것은 여러 스레드에서 접근할 수 있으므로 해시 맵(hash map)의 병렬 버전(concurrent version)을 사용한다.

ThreadPool 클래스는 다음에 선언된다. main 메소드는 실제 작업을 수행하는 WorkerThread 클래스를 사용한다. main 메소드에서, newCachedThreadPool 메소드는 쓰레드 풀을 생성하기 위해 호출된다.

<소스>

다음으로, try 블록은 발생할 수 있는 예외를 처리하고 캐치(catch)하는 데 사용된다. try 블록에서, 서버 소켓이 생성되고 클라이언트 연결이 요청될 때까지 메소드의 블록을 받아들인다. 다음 코드와 같이, 연결이 설정되면 WorkerThread 인스턴스는 클라이언트 소켓을 사용하여 생성된다.

<소스>

Page 183.

지금, 다음에 표시되는 WorkerThread 클래스를 살펴보자. 스트링은 키로서 사용되는 ConcurrentHashMap 인스턴스를 선언하고 저장되는 오브젝트는 float이다. 해시 맵은 정적 초기화 블록에 초기화된다.

<소스>

다음과 같은 클래스의 생성자는 나중에 사용하기 위해 clientSocket 인스턴스 변수에 클라이언트 소켓을 할당한다.

<소스>

run 메소드는 요청을 처리한다. 입력 스트림은 클라이언트 소켓에서 획득하고 부품 이름을 가져오는 데 사용된다. 이 이름은 해당 가격을 얻을 수 있는 해시 맵의 get 메소드의 인자로 사용된다. 이 가격은 클라이언트로 다시 전송되고, 메시지가 응답을 나타내는 표시된다.

<소스>

Page 184.

<소스>

이제 클라이언트 애플리케이션을 살펴보자.

간단한 스레드 풀 클라이언트

이 애플리케이션은 서버에 대한 연결을 확립하기 위해 Socket 클래스를 사용한다. 입력 및 출력 스트림은 전송하고 응답을 수신하는 데 사용된다. 이 방법은, 1장, '네트워크 프로그래밍 시작하기'에서 살펴봤다. 클라이언트 애플리케이션은 다음과 같다. 연결은 서버에 확립되고, 부품 가격에 대한 요청은 서버로 전송된다. 응답은 획득되고 표시된다.

<소스>

이제 함께 작동하는 방법을 살펴보자.

Page 185. 