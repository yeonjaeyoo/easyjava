Page 169.

-서버 용량
-다중 스레드
-네트워크 대역폭(bandwidth)과 레이턴시(latency)
-실행 환경

확장성은 적절한 수의 스레드를 사용하고, 실행 환경의 성능을 개선하고, 병목현상을 제거하기 위한네트워크 대역폭을 증가시켜 서버를 추가에 의해서 성취될 수 있다.

더 많은 서버를 추가하는 것은 서버 간에 로드밸런싱(load balancing)을 활성화하여 도움이 될 것이다. 그러나 네트워크 대역폭이나 대기 시간(latency)에 문제가 있다면, 이것은 훨씬 도움이 되지 않는다. 너무 많이 있는 네트워크 파이프를 통해 푸시할 수 있다.(수정해야함)

스레드는 종종 시스템의 성능을 개선하기 위해 사용된다. 시스템에 대한 적절한 수의 스레드를 사용하면 다른 스레드가 블록되는 동안 일부 스레드가 실행할 수 있다. 블록된 스레드는 IO가 발생하거나 사용자가 응답하는 것을 대기할 수 있다. 블록된 일부는 애플리케이션 처리량을 증가시킬 수 있어서 다른 쓰레드를 허용하면 실행한다.(수정해야함)

Page 170.

실행 환경은 기본적인 하드웨어, 운영체제, JVM, 애플리케이션 그 자체를 포함한다. 이러한 각 영역은 향상을 위한 후보이다. 즉 통제할 수 없기 때문에 하드웨어 환경을 해결하지 않는다. 같은 것은 운영체제의 사실이다. 약간의 성능 향상은 달성할 수 있지만, 이 부분을 해결하지 않는다. 네트워크 성능에 영향을 미치는 JVM 파라미터를 구별한다.

Page 173.

thread-per-request 서버

이 예제에서, 부품의 이름이 주어질 때 서버는 가격에 대한 요청을 받아들일 것이다. 구현은 부품 이름과 가격에 대한 병렬 접속을 지원하는 ConcurrentHashMap 클래스를 사용한다. 멀티스레드 환경에서, ConcurrentHashMap 클래스 같은 병렬 데이터 구조는 데이터 손실에 대한 가능성 없는 동작을 처리한다. 또한, 이 맵은 애플리케이션의 성능을 개선하는데 유용할 수 있는 캐시의 예제이다.

다음과 같은 서버의 선언으로 시작한다. 하나의 인스턴스가 서버에 필요하기 때문에 지도(map)은 정적(static)으로 선언된다. 정적 초기화 블록(static initialization block)은 맵을 초기화한다. main 메소드는 클라이언트의 요청을 수락하기 위해 ServerSocket 클래스를 사용한다. run 메소드로 처리된다. clientSocket 변수는 클라이언트 소켓에 대한 참조를 보유한다.

<소스>

main 메소드는 서버 소켓이 클라이언트 요청을 대기하고 처리하는 스레드를 위한 클라이언트 소켓이 전달하는 새로운 쓰레드를 생성하는 것은 다음과 같다. 메시지는 연결이 수락하는 것을 보여주는 표시이다.

<소스>

Page 174.

<소스>

다음과 같이, run 메소드는 요청을 처리한다. 입력 스트림(input stream)은 클라이언트 소켓으로부터 획득되고, 부품 이름은 읽혀진다. 맵(map)의 get메소드는 가격을 검색하기 위한 이름을 사용한다. 입력 스트림은 클라이언트로 가격을 재전송하고, 작업의 진행 상황은 표시된다.

<소스>

이제, 서버에 대한 클라이언트를 개발하자.

Page 175.

thread-per-request 클라이언트

다음과 같이, 클라이언트 애플리케이션은 서버에 연결하고, 요청을 전송하고 응답을 기다린 후, 가격을 표시한다. 이 예제에서는, 클라이언트와 서버는 동일한 머신에 존재한다.

<소스>

이제, 클라이언트와 서버의 상호작용 방법을 살펴보자. 

실행중인 thread-per-request 애플리케이션

다음과 같은 출력을 표시하는 첫 번째 서버를 시작한다. 

Multi-Threaded Server Started
Listening for a client connection

다음에, 클라이언트 애플리케이션을 시작한다. 다음 출력은 표시된다.

Client Started
Connected to a Server

Page 176.

Axle request sent
Response: 238.5
Client Terminated

서버는 다음과 같은 출력이 표시된다. "Client Thread Started" 출력은 "Listening for a client connection" 출력을 따른다. 스레드를 시작하기 전에 약간의 지연이 존재하기 때문이다.

Connected to a Client
Listening for a client connection
Client Thread Started
Request for Axle and returned a price of $238.50
Client Connection Terminated
Client Thread Terminated

클라이언트 스레드는 시작하여, 요청을 처리하고 종료한다.

<소스>

클라이언트가 실행되면 다음과 같은 출력을 얻을 것이다. 두 번째 스트링에 대한 응답은 null이다. 첫 번째 요청에 대한 응답 후에 서버의 응답 스레드가 종료되기 때문이다.

<결과>

Page 177.

이 방법을 사용하여 여러 요청을 처리하려면 다시 연결하고 별도의 요청을 전송해야한다. 다음 코드는 이 방법을 보여준다. 두 번째 요청을 전송한 코드 세그먼트를 제거한다. 이 시퀀스에서, 소켓은 다시 열리고, IO스트림은 재생성되며, 메시지는 다시 전송된다.

<소스>

클라이언트가 실행되면, 그것은 두 요청 및 응답을 반영한 다음 출력을 생성한다. 

<결과>

서버 측에서, 다음과 같은 출력을 얻을 것이다. 두 개의 스레드는 요청을 처리하기 위해 생성됐다.

<결과>

Page 178.

<결과>

접속의 개방(opening)과 폐쇠(closing)는 값비쌀 수 있다. 다음 섹션에서, 이러한 유형의 문제를 해결한다. 단 하나의 요청이 이루어지는 경우, 다음 thread-per-request은 작동한다.

Thread-per-connection 접근

이 방식에서, 단일 스레드는 모든 클라이언트의 요청을 처리하기 위해 사용된다. 이 방법은 클라이언트가 더 이상 요청이 없는 일종의 통지를 전송할 것을 요구할 것이다. 명시적으로 통지하는 대신에, 타임 아웃은 충분한 시간이 경과 한 후 자동으로 클라이언트의 연결을 해제하도록 설정될 필요가 있다.

thread-per-connection 서버