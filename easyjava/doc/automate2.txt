5장. 재미있는 Email

E-mail 통신은 지난 수십 년동안 정보 교환의 기본 모드가 됐다. email은 매일 여러 가지 이유로 작업한다. 하지만 파이썬으로 받은 편지함을 조작할 수 있다는 생각은 하지않을까?

5장에서는 다음 주제를 다룬다.

-email 메시지 전송
-email 암호화
-MIME 메시지로 email 메시지 꾸미기
-첨부파일과 email 메시지
-받은편지함 연결
-email 메시지 가져 오기 및 읽기
-email 메시지 표시
-받은편지함의 email 메시지 삭제
-email 응답을 통한 고객 지원 흐름 자동화

소개

안녕, 여러분! 좋은 하루를 희망한다. 5장에서는 email 및 파이썬을 사용한 email로 수행할 수 있는 수많은 작업을 다룬다. 우리는 또한 실제 비즈니스 유스 케이스의 도움을 받아 email로 비즈니스 프로세스를 자동화하는 방법을 이해할 것이다.

그래서 우리는 무엇을 기다리고 있을까? email의 역사와 기술 구현에 대해 조금씩 배우기 시작하자.

Page 140.

전자 메일은 실제로 소개할 필요가 없다. 물론 그들은 컴퓨터 사용자 간에 디지털 메시지를 교환하는 방법이다. 전자 메일은 정보 교환을 위해 인터넷을 통해 사용할 수 있는 컴퓨터 네트워크에서 작동한다. 인기있는 전자 메일 클라이언트에 로그인하여 전자 메일 서버에 저장된 메시지 작업을 시작할 수 있다. 가장 널리 사용되는 웹 클라이언트는 Gmail이다. 

전자 메일은 매우 흥미로운 역사를 가진다. 과거에는 전자 메일을 사용하려면 보낸 사람과 받는 사람이 통신에 성공하려면 온라인 상태여야했다. 그건 별로 의미가 없었어, 그렇지? 점차적으로 시간이 지남에 따라 전자 메일 서버가 지능화되고 점포 및 철학(store-and-forward philosophy)으로 작동했다. 오늘날 전자 메일 메시지는 서버에 비동기적으로 저장되므로 수신자는 나중에 편리하게 볼 수 있다. 따라서 전자 메일 서버는 메시지 수락, 전달 및 표시와 같은 기능을 제공할 수 있다.

전자 메일 메시지는 서식있는 텍스트 및 첨부파일의 MIME(Multipurpose Internet Mail Extensions)에 의해 나중에 확장된 ASCII 전용 문자로 시작됐다. 프로토콜 관점에서 전자 메일은 처음에는 FTP(File Transfer Protocol)를 사용하여 컴퓨터 간에 메시지를 전송하지만 인식할 수 있는 것처럼 SMTP(Simple Mail Transfer Protocol)는 전자 메일 작업에 가장 널리 사용되는 프로토콜이다.

<<중요표시시작>>
전자 메일 서버 설정은 이 책에서 다루지 않는다. 인터넷을 살펴보면 시작하는 데 도움이 되는 더 많은 리소스를 찾을 수 있다. 5장의 범위는 파이썬 프로그램을 사용하여 이메일로 할 수 있는 일을 알려주는 것이다. 구글은 구글 웹 클라이언트에 적용되는 예제를 사용하므로 코드 예제를 신속하게 시도해보고 파이썬을 사용하여 전자 메일 서버를 설정없이 전자 메일 작업을 자동화할 수있는 능력을 높이 평가할 수 있다. 
<<중요표시종료>>

5장에서는 파이썬을 사용하여 전자 메일을 사용하는 방법을 살펴볼 것이다. 밑에 나열된 여러 파이썬 모듈을 사용하여 전자 메일 메시지에 대한 다양한 작업도 수행한다.

<주소>

<<중요표시시작>>
파이썬을 사용하여 전자 메일 작업을 할 때 필요한 것은 메시지를 구성하는 데 도움이 되는 모듈, 전자 메일을 전송할 수 있는 모듈 및 메시지를 검색하고 업데이트하는 데 도움이 되는 모듈이다.
<<중요표시종료>>

Page 141.

2017.05.22

전자 메일 메시지 전송

전자 메일 클라이언트를 통해 달성하고자 하는 가장 중요한 일은 친구 혹은 동료의 전자 메일 주소로 메시지를 전송하는 것이다. 파이썬에서 이것을 어떻게 달성할 수 있는지 살펴보자.

준비하기

전자 메일 메시지를 전송하려면 파이썬 smtplib 모듈이 필요하다. 이름에서 알 수 있듯이 이 라이브러리는 SMTP 프로토콜을 사용하여 전자 메일 메시지를 전송한다. 다음 커맨드로 smtplib을 선호하는 pip 도구로 설치할 수 있다. 하지만 파이썬의 기본 설치는 이미 이 모듈을 가지고 있어야 한다.

<소스>

실행방법

1. 컴퓨터에서 좋아하는 편집기를 열고 다음 코드 조각을 추가한다. 이를 config.py라고 한다. 구성 파일에는 전자 메일 주소, 패스워드 및 전자 메일을 전송할 전자 메일 주소와 같은 로그인 세부 정보가 있다.

<소스>

2. 이제 이 환경 파일을 사용하여 전자 메일을 전송하는 코드를 작성해보자. 

<소스>

3. 앞의 코드를 basic_email.py로 저장하고 다음 커맨드를 사용하여 코드를 실행한다.

<소스>

Page 142.

4. 앞의 코드를 실행하면 SMTPAuthenticationError 예외가 표시되고 종료 코드(exit code) 1로 프로그램이 실패한다. 예외가 어떻게 발생하는지 확인한다.

<그림>

5. 좋아, 그게 나쁘지만 반대로, 좋다! 예외는 서버에 로그인해도 문제가 없었지만 Gmail에서 메시지를 보내지 못하게했다. 이제 Gmail에 로그인하면 안전성이 낮은 앱에서 로그인이 감지되었음을 알리는 이메일이 표시된다. 정말이니? 그래, 파이썬 프로그램에서 Gmail 계정에 액세스하려고 했기 때문이다. 구글 계정에 악의적인 활동이 있는경우 보안 위반 가능성을 제안하는 전자 메일을 구글로부터 수신받는 이유다. 구글의 전자 메일 메시지는 다음 스크린샷에서 확인할 수 있다.

<그림>

Page 143.

6. 그러나 분명히 이것은 구글 계정을 사용하려는 합법적인 시도였으므로 구글에 확인해보자. 구글의 전자 메일 메시지를 열고 ALLOW ACCESS을 클릭한다. Less secure apps 앱 페이지로 이동하여 다음 스크린샷과 같이 이 설정을 사용할 수 있다.

<그림>

7. 이제 구글 웹 클라이언트에서 로그 아웃한 다음 다시 로그인하여 계정에서 설정을 적용한다. 이 과정이 정상적으로 완료되면 Access for less secure apps is turned on 되었다는 이메일이 Google로부터 수신된다. 구글의 확인 이메일은 이 스크린샷과 유사하다.

<그림>

이제 파이썬 프로그램을 다시 실행하면 성공적으로 실행되어야하며 받은 편지함에 전자 메일이 전송된다.

<그림>

Page 144.

2017.05.23

8. 시원해! 메시지 내용은 코드 조각에 추가한 내용과 같다. 또한 from과 to 주소가 동일하기 때문에 전자 메일은 사용자가 보낸 것이지만 제목이 없으므로 훌륭하지 않다. 다음 레시피에서 이 문제에 대해 살펴볼 것이다.

작동원리

앞에서 설명한 것처럼 SMTP는 전자 메일 메시지를 전송하는 데 사용된다. 이 목적으로 파이썬 모듈인 smtplib을 사용한다.

앞의 코드 조각을 살펴보면 smtplib.SMTP() 생성자를 사용하여 Gmail의 SMTP 설정을 구성하고 이메일 서버에 액세스할 수 있다. Gmail의 SMTP 서버는 smtp.gmail.com 및 포트 587에서 실행된다.

서버 객체인 server가 있으면 우리는 server를 사용하여 사용자 이름과 비밀번호로 Gmail에 로그인한다. 앞의 코드에는 server.starttls()라는 또 다른 행이 있다. 5장의 뒷부분에서 다룬다.

테스트 메시지를 생성하여 변수 msg에 저장한 다음 sendmail 메소드('fromaddr', 'toddr', msg)를 사용하여 전송된다.

마지막으로 server.quit()를 사용하여 전자 메일 서버에 대한 연결을 닫는다.

더 알아보기

Gmail에 로그인하고 SMTP 프로토콜과 파이썬의 smptlib 라이브러리를 사용하여 기본 전자 메일을 보내는 방법을 살펴봤다. 이 레시피가 우리를 시작하게 만들었지만, 다음 레시피에서 더 자세히 설명할 것이다. 그것을 살펴보자.

전자 메일 암호화

전자 메일은 정보 유출이 쉽다. 대부분의 전자 메일은 현재 일반 텍스트 형식으로 전송된다. 전자 메일 암호화는 전자 메일의 내용을 암호화하거나 위장하여 의도한 수신자가 내용을 읽을 수 있게 한다. 전자 메일을 다룰 때는 항상 보안이 가장 중요하다는 것을 기억한다. 파이썬으로 전자 메일을 암호화하는 방법을 살펴보자.

Page 145.

준비하기

이전 레서피에서 기본 전자 메일을 전송했지만 starttls() 메소드는 무엇인가? 전자 메일 암호화는 어떻게 작동하나? 이 절에서는 이러한 질문에 대한 답을 얻을 것이다.

실행방법

1. 우선 가장 좋아하는 편집기를 열고 다음 코드 조각을 입력하자.

<소스>

2. 이제, 파이썬 코드를 실행하고 그것이 무엇을 출력하는지 살펴보자. 세 가지 부문으로 결과를 보여준다. 첫 번째는 전자 메일 서버에 ehlo() 메시지를 전송할 때다.

<그림>

Page 146.

3. 두 번째는 서버 객체에서 starttls() 메소드를 호출할 때다. 다음 스크린 샷을 확인한다.

<그림>

4. 세 번째는 ehlo()를 사용하여 전자 메일 서버에 다시 연결할 때다.

<그림>

Page 147.

작동원리

기본부터 시작하자. 전자 메일 암호화란 의도한 당사자가 아닌 다른 사람이 읽는 전자 메일 메시지를 보호하는 것을 의미한다. 전자 메일은 일반적으로 일반 텍스트로 전송되며 서드파티에서 스니핑할 수 있다. 이를 방지하기 위해 프로토콜 레이어에서 전자 메일을 암호화한다. 이것은 인증도 포함될 수 있다.

SMTP 서버는 일반적으로 SSL/TLS 프로토콜을 사용하여 포트 25에서 전자 메일을 전송한다. 그러나 STARTTLS(SMTP 상단 계층)와 메시지 제출을 위한 포트 587의 사용으로 인해 Gmail과 같은 전자 메일 클라이언트는 전자 메일을 보내기 위해 STARTTLS 및 포트 587을 사용한다. Gmail에는 인증이 구현된다. server.login(username, password)을 사용하여 Gmail 서버에 로그인했음을 기억한다.

STARTTLS를 서버와 클라이언트에서 사용하려면 클라이언트가 먼저 서버가 이 프로토콜을 지원하는지 알아야한다. server.ehlo()를 실행하면 프로그램이 SMTP 서버에 EHLO 메시지를 전송하여 통신을 설정한다. 첫 번째 스크린샷에서 볼 수 있듯이 서버는 메시지 및 허용된 확장명으로 응답한다.

이제 코드에서 서버가 server.has_extn('STARTTLS')을 사용하여 STARTTLS 확장자를 지원하는지 확인한다. 첫 번째 스크린샷에서 보았듯이 SMTP 서버는 STARTTLS 확장자로 응답했다. 이것은 gmail이 STARTTLS 프로토콜 레이어를 지원한다는 것을 확인한다.

이제 server.starttls()를 사용하여 서버와 통신한다. 서버는 Ready to start TLS라는 메시지를 전송해서 이에 응답한다. 이렇게하면 세션이 암호화된다. 세 번째 스크린샷을 보면 server.ehlo()를 보낼 때 TLS 세션을 통해 서버를 식별할 수 있다. 또한 서버가 인증 확장(authentication extension)을 구현할 것을 제안한다.

마지막으로 server.quit()을 사용하여 SMTP 세션을 종료하고 세 번째 스크린샷과 같이 서버가 연결을 닫으면 응답한다.

더 알아보기

그래, 매우 자세하게 설명했다. 그것을 이해하기 위해 잠시 시간을 가진다. 간단한 전자 메일 메시지를 보내는 것에서 일어나는 일은 실제로 흥미롭다. 그러나 너무 많이 걱정하지마. 재미있게 시작하고 더 많은 예제를 살펴보자.

Page 148.

MIME을 사용한 전자 메일 메시지 꾸미기

처음 몇 가지 레시피에서는 전자 메일 메시지를 오래된 간단한 평문 텍스트 형식으로 전송했다. MIME 인터넷 표준은 비 ASCII 문자, 다중 메시지 및 이미지로 메시지를 구성하는 데 도움이 된다. 또한 첨부 파일 및 기타 많은 작업에 도움이 된다. 이렇게하면 풍부한 전자 메일 메시지를 구성할 수 있다. 이 레시피에서 MIME 형식이 어떻게 사용되는지 살펴보자.

준비하기

이 레시피에서는 동일한 모듈인 smtplib을 사용하여 전자 메일 메시지를 전송한다. MIME 형식으로 더 나은 전자 메일 메시지를 생성하는 데 도움이 되는 또 다른 모듈인 email을 다룬다. email 모듈은 파이썬 설치와 함께 제공된다. 따라서 새로운 모듈 혹은 설치가 필요하지 않다. 이 절에서는 MIME 속성을 사용하여 보다나은 전자 메일을 전송하는 방법을 살펴본다.

실행방법

1. 필요한 모든 모듈을 임포트하자.

<소스>

2. 이제 MIME 모듈을 사용하여 전자 메일 메시지를 구성하자. 다음 코드는 메시지를 생성한다.

<소스>

Page 149.

3. 이제 전자 메일 메시지를 전송할 사람에 대한 세부 정보를 얻었다. MIME 형식으로도 전자 메일 메시지를 구성했다. 무엇을 기다리고 있을까? 다음 코드를 사용하여 보내자.

<소스>

수신한 전자 메일은 다음과 같다.

<그림>

굉장해! 훌륭하다. 하지만 어떻게 작동 했나?

작동원리

이전 예제에서 SMTP 서버에 로그인하기 위해 fromaddress와 password가 있는 곳의 환경 파일과 이메일 메시지를 보낼 toaddress를 임포트했다.

이제 메시지를 전송하기 전에 새로운 MIME 메시지 객체를 생성한다. 파이썬의 email.mime.multipart 모듈에서 MIMEMultipart() 클래스를 사용한다. 인식하지 못하는 사람들을 위해, MIME multipart 메시지는 단일 전자 메일에서 HTML 및 텍스트 내용을 모두 의미한다. 따라서 이 코드에서는 새로운 multipart MIME 메시지를 생성한 다음 텍스트 내용을 추가한다.

Page 150.

전자 메일의 본문인 텍스트 내용은 email.mime.text 모듈의 MIMEText() 생성자로 생성되고 attach() 메소드를 사용하여 multipart 메시지에 첨부된다.

구성된 MIME 메시지는 content-type이 multipart이고 MIME 버전이 1.0이고 Subject, To 및 From 세부 정보가 예상대로이며 전자 메일 본문에 예상된 텍스트는 다음 스크린샷에 표시된다.

<그림>

메시지와 받는 사람 세부 정보를 받으면 SMTP.sendmail() 메소드를 사용하여 평소대로 전자 메일을 전송한다.

첨부 파일과 전자 메일 메시지

전자 메일에서 가장 많이 사용되는 간단한 사용 사례 중 하나는 첨부 파일을 전자 메일 메시지에 첨부하는 기능이다. 이 절에서는 파이썬으로 전자 메일에 첨부 파일을 추가하는 방법을 다룬다.

준비하기

이 예제에서는 동일한 smtplib 및 email 모듈을 사용한다. 따라서 설치할 모듈에 대해 걱정하지마. 레시피를 사용하자.

Page 151.

실행방법

1. 작은 텍스트 파일을 빠르게 만드는 것으로 시작하자. attach.txt라고하고 그 내용은 다음 스크린샷에 표시된다.

<그림>

2. 전자 메일에 첨부 파일을 추가하는 데 도움이 되는 코드를 살펴보자.

<소스>

Page 152.

3. 앞의 코드를 실행하면 받은 편지함에 전자 메일이 전송되고 다음 스크린 샷과 유사할 것이다.

<그림>

작동원리

이미 MIME 메시지 객체를 생성하는 것에 익숙하다. 따라서 이 코드에서는 multipart 메시지 객체인 msg를 생성한다. 이 후 msg.attach()를 사용하여 텍스트 메시지를 추가한다. 텍스트 본문은 Click to open the attachment를 보여준다.

이 레시피에서는 텍스트 파일을 첨부하는 데 사용될 email 모듈의 다른 새로운 클래스인 MIMEBase를 사용한다. 이미 attach.txt 파일을 생성했으므로 파이썬 open() 메소드를 사용하여 파일을 열고 파일 핸들 첨부 파일을 가져온다. 그런 다음 MIMEBase 객체인 part를 생성하고 파일의 내용을 페이로드로 이 객체에 할당한다.(확인) 파일의 내용은 attachment.read()로 가져오고 페이로드는 set_payload() 메소드로 설정한다.

파일을 첨부하려면 MIMEBase 객체는 base64로 인코딩하고 Content-Disposition 헤더는 part 객체에 추가한다. 이제 part 객체가 있으므로 본문 텍스트와 마찬가지로 attach() 메소드를 사용하여 multipart 객체 msg에 첨부할 수 있다.

Page 153.

멋지다. MIME 메시지와 메시지를 보낼 대상에 대한 세부 정보를 제공한다. 그래서 첨부 파일이 있는 전자 메일을 전송한다. 성취하려는 것이다.

받은 메일함 연결

5장에서 파이썬으로 이메일을 전송하는 것에 대해 이야기했다. 그러나 어떤 시점에서는 받은 편지함을 스캔하여 수신 메시지를 읽을 수도 있다. 그래서, 어떻게 그 일을 할까? 이 레시피에서 이해하고 배우자.

준비하기

이 레시피에서는 받은 편지함에서 메시지를 가져오는 데 도움이 되는 새로운 파이썬 모듈을 사용한다. 파이썬 모듈인 imaplib를 사용하는데, 기본 파이썬 설치에서 사용 가능하다. 좋아, 시작하자.

실행방법

1. 먼저 전자 메일과 패스워드를 저장하기 위해 생성한 환경 파일을 사용하여 서버에 로그인한다. 그런 다음 코드를 추가하여 받은 편지함에서 사용할 핸들 혹은 객체를 생성한다. 이것은 코드가 보이는 방법이다.

<소스>

앞의 코드를 실행하면 결과는 다음과 같다.

<그림>

Page 154.

2. 기본적으로 Gmail에 로그인하면 기본 받은 편지함이 선택되지만, 다른 받은 편지함도 생성된 경우 코드 라인을 조금 추가하여 목록을 가져올 수 있다. 이제는 모든 라벨에서 특히 받은 편지함을 선택하려는 경우에도 이를 달성할 수 있다. 다음 코드 예제를 살펴보자.

<소스>

앞의 코드 조각의 출력은 다음 스크린샷에 표시된다. 많은 라벨을 생성했만 적은 라벨로 스크린 샷을 보여준다.(확인)

<그림>

2017.05.29

작동원리

5장의 시작 부분에서 설명한 것처럼 전자 메일을 사용하는 세 가지 주요 프로토콜이 있다. SMTP를 전자 메일 전송에 많이 사용했지만 전자 메일을 읽는 동안 POP 혹은 IMAP을 사용하여 전자 메일 서버에서 메시지를 검색할 수 있다. 코드를 단계별로 살펴본다.

파이썬 imaplib 라이브러리는 IMAP(Internet Message Access Protocol)을 사용하여 메일박스에 연결할 수 있도록 도와준다. Gmail 서버는 map.gmail.com 및 '993'포트에서 실행되는 IMAP으로 구성된다.

예제 코드에서는 생성자 IMAP4_SSL("imap.gmail.com", 993)을 사용하여 imaplib 유형의 객체를 생성한다. 이 객체를 M이라고 부른다.

암호화와 관련하여 SSL 소켓을 통해 암호화된 통신을 사용하기 때문에 IMAP4_SSL을 사용하여 서버에 연결한다. 내부적으로 일반 텍스트 소켓(clear text sockets)을 사용하는 IMAP4 클래스의 사용을 배제한다.

이제 객체 M을 사용하여 사용자 이름과 패스워드로 Gmail에 로그인하여 받은 편지함에 연결할 수 있다.

Page 155.

M 객체에서 list() 메소드를 호출하면 이미 생성한 모든 라벨이 반환된다. 이제, 제 경우 ACM 라벨(내 작업과 ACM)을 생성했고 따라서 ACM 레이블은 내 레이블 목록에 나타난다.

코드 예제를 살펴보면 select() 메소드를 사용하여 INBOX에 명시적으로 연결할 수 있다. 받은 편지함에 연결되면 받은 편지함에서 전자 메일 메시지를 가져올 수 있다.

마지막으로, M.logout() 메소드를 사용하여 받은 편지함과의 연결을 닫는다. 좋아! 멋지고 쉽다.

더 알아보기

따라서 이 레시피에서 받은 편지함에 연결하는 방법을 배웠지만 메시지를 읽고 표시하고 흥미로운 작업을 수행하고자 할 수도 있다. 다음 레시피에서 메시지 작업을 수행하는 방법을 살펴보자.

전자 메일 메시지 가져 오기 및 읽기

imaplib로 전자 메일 메시지를 검색하는 것도 쉽다. 이 레시피에서는 파이썬 코드를 사용하여 이를 수행하는 방법을 살펴본다. 이 레시피에서는 특정 제목이 있는 전자 메일을 검색하고 미리 정의된 기준과 일치하는 받은 편지함에서 최신 메시지를 가져온다.

준비하기

전자메일 메시지를 읽기 위해 imaplib 모듈을 계속 사용하므로 이 레시피에는 새로 설치할 필요가 없다.

실행방법

1. 환경 파일을 사용하고 fromaddress, password 및 toaddress를 가져 와서 서버에 로그인한다. 일단 로그인하면 기본 받은 편지함을 선택하고 전자 메일 메시지를 가져와서 읽는다. 전체 코드를 살펴보자.

<소스>

Page 156.

<소스>

2. 앞의 파일을 inbox_search.py로 저장하고 다음 커맨드를 사용하여 코드를 실행한다.

<소스>

3. 앞의 코드 조각의 출력은 다음 스크린샷에 표시된다.

<그림>

Page 157.

작동원리

앞의 코드 조각에서 먼저 적절한 IMAP 설정을 사용하여 IMAP_SSL4()의 객체를 생성한다. 이 후 IMAP 객체를 사용하여 환경 파일의 자격 증명(credentials)을 사용하여 클라이언트에 로그인한다. 이 후 검색 작업을 수행할 수 있도록 INBOX를 선택한다.

IMAP 객체에서 호출되는 M.search() 메소드는 Email with an attachment 제목이 포함된 전자 메일을 검색하는 데 도움이 된다. search() 메소드는 검색 기준과 일치하는 메시지 배열을 반환한다.

이제 특정 메시지를 가져와야하고 기준에 맞는 최신 전자 메일 메시지를 읽어야하므로 M.fetch() 메소드를 사용한다. fetch() 메소드에는 주어진 메시지 객체와 가져 오려는 메시지의 일부가 필요하다. 따라서 이 코드 예제에서는 기준과 일치하는 최신 전자 메일 객체를 전달하고 RFC 822 형식의 전자 메일 본문을 필요로 함을 나타내는 RFC822를 전달한다.

fetch()에서 얻은 메시지를 출력할 때 검색과 일치하는 최신 전자 메일의 전자 메일 본문 내용을 가져온다.

이제, 전자 메일의 내용을 본 기억이 있어? 전자 메일 첨부 파일을 보여주는 데 사용한 이전 레시피 중 하나에서 보낸 전자 메일 메시지와 같다.(확인)

더 알아보기

좋다! 이제 메시지를 검색하고 가져올 수 있다. 받은 편지함에서 수행할 메시지를 표시하는 것 같은 더 세분화된 작업이 많이 있다. 다음 레시피에서 살펴보자.

전자 메일 메시지 표시

이전 레시피에서는 메시지를 가져와서 읽는 것을 살펴봤다. 너무 복잡하지 않았나? 검색 혹은 읽기와 같은 간단한 작업을 하면서 많은 세부 사항을 처리해야하나? 이 절에서는 검색 혹은 읽기가 더 쉬울뿐 아니라 전자 메일에서 다양한 작업을 수행할 수 있는 또 다른 라이브러리를 살펴보자.

Page 158.

준비하기

이 절에서는 gmail 모듈을 설치한다. 다음과 같이 pip 명령을 사용하여 터미널을 통해 이 모듈을 설치할 수 있다. 

<소스>

전자 메일을 검색하고 gmail API를 사용하여 전자 메일을 읽는 방법을 살펴보자. gmail 모듈로 시작된다. 다음 코드 조각은 2016년 7월 22일 이후에 수신된 전자 메일을 검색한다. 이 후 최신 메시지를 가져 와서 패치한다.(확인) 메시지를 가져오면 전자 메일의 본문을 읽는다.

<소스>

앞의 코드 출력은 다음 스크린샷에 표시된다. Quora에서 전자 메일 다이제스트를 받은 것 같다.

<그림>

Page 159.

받은 편지함의 스크린샷이다.

<그림>

너무 쉬웠나? 덧붙여 말하자면, gmail 모듈은 imaplib 위에 작성되었지만 더 나은 API를 가지고 있으므로 이 모듈을 활용하고 환상적인 작업을 수행해보자.

Page 160.

실행방법

1. 받은 편지함을 열고 특정 기준과 일치하는 읽지 않은 메시지를 찾고 메시지를 읽음으로 표시한다. 다음 코드는 이것을 쉽게 수행한다.

<소스>

이 프로그램을 실행하기 전에, https://glassdoor.com의 받은 메일함에서 읽지 않은 하나의 전자 메일을 가진다. 내 받은 편지함에서 이렇게 보인다.

<그림>

코드 조각을 실행한 후 이 전자 메일은 noreply@glassdoor.com에서 내 읽지 않은 메시지 기준과 일치하는 것으로 식별하고 읽음으로 내 메시지를 표시했다. 이제 받은 편지함에 다음과 같이 표시된다.

<그림>

좋아.

2. 다른 예제를 살펴보자. 나는 2016년 1월부터 Amazon Now에서 많은 홍보용 이메일을 받았다. 내 메일함이 이렇게 보인다.

<그림>

Page 161.

3. 이제 그것들을 모두 읽음으로 표시하고 하나의 라벨인 AMAZON으로 지정한다. 내가 어떻게 할 수 있니? 다음 코드는 이 작업을 수행한다.

<소스>

4. 이 코드를 실행하면 새로운 라벨이 받은 편지함에 AMAZON이라는 이름으로 나타난다. 이제 받은 편지함에서 AMAZON이라는 라벨이 있는 모든 전자 메일을 검색하면 이러한 모든 전자 메일 메시지가 읽음으로 표시되었음을 알 수 있다. 다음 스크린샷을 보고 AMAZON이라는 라벨이 있는 전자 메일을 검색한다.

<그림>

작동원리

첫 번째 단계에서는 Gmail 서버에 로그인하여 객체 g를 생성했다. 객체를 생성하기 위한 IMAP 설정 혹은 포트와 같은 매개변수를 전달하지 않았다. gmail 모듈이 내부적으로 처리한다.

Page 162.

이제 이 객체를 사용하여 받은 편지함에서 unread 메일을 noreply@glassdoor.in에서 검색하기 시작하고 이 기준과 일치하는 모든 메일 개체는 mails에 저장된다.

나중에 fetch() 메소드를 사용하여 최신 레코드를 가져 와서 이 메일을 read() 메소드와 함께 읽음으로 표시한다.

마찬가지로, 두 번째 레시피에서는 store-news@amazon.in에서 올해 나에게 보낸 모든 unread 전자 메일 메시지를 반복한다.

각 메일은 이 후 read() 메소드로 읽음으로 표시되고 AMAZON이라는 라벨에 추가된다. 바람처럼 잘 작동한다.

더 알아보기

전자 메일 메시지에서 수행할 수 있는 몇 가지 작업을 살펴본다. 더 많은 것이 있다. gmail 모듈을 사용하면 메일을 읽지 않은 메일로 표시하거나 별표와 함께 중요하게 만들 수 있다. 받은 편지함을 정리할 수 있는 예제를 살펴보자.

받은 편지함에서 전자 메일 메시지 삭제

마지막으로, 이 레시피는 받은 편지함에서 전자 메일 메시지를 삭제할 수 있는 단계를 안내한다. 예상대로, 전자 메일을 프로그래밍 방식으로 삭제하는 것은 매우 간단하다.

<<중요정보표시시작>>
전자 메일 클라이언트에서 메시지를 삭제하더라도 전자 메일 서버는 메시지를 저장하도록 선택할 수 있다. 따라서 메시지를 삭제할 때 서버 구현을 기반으로 전자 메일 서버에 계속 머물 수 있을 때 받은 편지함에 숨기도록 표시하는 것이다.
<<중요정보표시끝>>

준비하기

전자 메일 메시지를 삭제하기 위해 imaplib 모듈을 계속 사용하므로 이 레시피에 새로 설치할 필요가 없다.

Page 163.

실행방법

1. 환경 파일을 활용하고 fromaddress, password 및 toaddress를 가져와 서버에 로그인한다.
2. 전체 코드는 다음과 같다.

<소스>

3. 앞의 파일을 inbox_delete.py로 저장하고 다음 커맨드를 사용하여 코드를 실행한다.

<소스>

작동원리

앞의 예제에서 보았던 것과 비슷하지만 먼저 환경 파일의 로그인 자격 증명을 사용하여 Gmail에 로그인한다.

이 후 받은 편지함에 연결하여 junk@xyz.com에서 오는 전자 메일을 검색한다. 이 기준과 일치하는 전자 메일을 찾으면 그것을 삭제해야한다.

그래서 mail 객체를 반복 처리하고 delete() 연산을 수행한다. 받은 편지함에는 이제 정크 메일로 간주하는 모든 메시지에서 자유다.

더 알아보기

좋아! 이제 전자 메일 메시지를 전송하고 첨부 파일을 추가하고 가져오고 읽는 방법을 알았다. 또한 메시지를 읽음으로 표시하고, 적절한 레이블을 추가하고, 필요하다면 이 메시지를 삭제하는 방법을 다뤘다. 이 지식을 가지고, 문제가 있는 켈리(Kelly)에게 무엇을 할 수 있을까?(확인)

Page 164.

전자 메일 응답과 함께 고객 지원 플로우 자동화

고객 지원 담당 이사인 켈리는 현재 문제가 있다. 대부분의 지원 엔지니어는 고객이 웹 사이트에서 이미 사용할 수 있는 정보를 찾고있는 레벨 1 지원 요청에 응답한다. 고객은 스스로 검색을 시도하지 않고 지원을 위해 전자 메일을 보낸다.

이러한 이벤트는 고객 및 지원 엔지니어에게는 비생산적이다. 고객은 단순히 웹 사이트에서 직접 정보를 얻는 대신 정보를 기다리고 기술 지원 엔지니어는 웹 사이트에서 고객에게 FAQ(Frequently Asked Questions) 절에 대한 포인터를 수동으로 보낸다. 켈리는 그것을 그것을 개선 할 기회로보고 이 흐름을 자동화함으로써 지원에 소요되는 시간을 줄이기를 원한다. 그녀를 도울 무엇인가를 할 수 있을까?

준비하기

물론 이것은 더 큰 문제를 해결하는 것이지만 최소한 흐름을 자동화하는 데 도움이되는 것을 할 수 있다. 지원 팀이 전자 메일을 통해 새 티켓을 받으면 티켓 영수증을 확인한 티켓에 자동 응답할 수 있으며 회사 웹 사이트의 FAQ 절에 링크를 보낼 수 있다. 이렇게하면 고객은 FAQ 절에서 필요한 정보를 찾아보고 찾을 수 있다. 또한 자동 응답 전자 메일이 이미 고객 질의를 해결했으므로 지원 엔지니어의 부담을 줄여준다.

이제 실제로 무엇이 필요하나? 지원 받은 메일함을 모니터링하고 새2로운 고객 질의를 보고 템플릿 전자 메일로 자동 응답해야한다. 

실행방법

1. 직접 솔루션으로 넘어가자. 파이썬 파일을 생성하고 코드 조각 다음에 복사한다. 지원 흐름을 자동화하는 데 필요한 것을 정확히 수행한다.

<소스>

Page 165.

<소스>

Page 166.

2. 앞의 코드를 파이썬으로 실행하면 프로그램이 여전히 실행 중임을 알 수 있다. 이 상황에서 지원 엔지니어에 대한 고객의 요청인 새로운 전자 메일을 실제로 기다린다.
3. 고객 지원에 전자 메일을 전송하면 파이썬 프로그램에서 자동 응답을 받는다.

<<중요표시시작>>
이 경우 지원되는 받은 편지함이 내 전자 메일 주소이지만 고객 요청이 이 계정으로 연결되도록 회사의 전자 메일 계정을 쉽게 설정할 수 있다.
<<중요표시끝>>

이것은 자동 응답 이메일이 보이는 방법이다.

<그림>

작동원리

매 1분(60초)마다 실행되는 while 루프부터 시작한다. 모든 반복은 지원 받은 편지함을 읽고 읽지않은 전자 메일을 검색한다.

2017.06.02

while 루프가 읽지 않은 전자 메일을 찾으면 전자 메일을 가져와서 fr 속성을 얻는다. fr 속성은 전자 메일 메시지의 from 필드를 가져온다. from 필드는 지원 엔지니어의 정보를 요청하는 고객의 전자 메일 주소이다.

고객의 전자 메일 주소를 받으면 받은 편지함에서 고객에게 자동 응답을 전송한다. 앞의 스크린샷은 자동응답이 어떻게 표시되는지 정확히 보여준다.
이제 고객이 고객 지원 엔지니어에게 전자 메일을 보내 질문을 하면 Frequently Asked Questions 절에 대한 링크가 있는 자동 전자 메일 응답을 받는다.

Page 167.

이렇게하면 고객은 FAQ 링크에서 필요한 정보를 신속하게 얻을 수 있다. 또한 기술 지원 엔지니어가 평상시의 지원 요청에 수동으로 응답하지 않아도되므로 지원 엔지니어의 부담이 줄어든다.

나는 이 개선에 대해 켈리가 행복하다고 느낄 것이라고 확신한다. 그녀는 고객 지원 흐름이 어느 정도 자동화되어 있으며 곧 생산성 향상을 기대하고 있음을 알고 있다.

더 알아보기

굉장해! 이메일로 할 수 있는 많은 다른 것들이 있다. 이메일 첨부 파일을 다운로드하려고 시도했나? 한번 시도하고 싶나? 너 자신을 위해 그것을 시도하게 할 것이다. 다음 장에서 살펴본다.

2017.06.05

Page 173.

8. 이제 모든 슬라이드에는 몇 가지 모양이 포함된다. 예를 들어 첫 번째 슬라이드에는 두 개의 텍스트 자리 표시자(placeholders)인 제목과 부제가 있다. 두 번째 슬라이드에는 두 개의 placeholder가 있지만 원형도 있다. 다음 코드는 이 정보를 출력한다.

<소스>

앞의 코드 조각의 출력은 다음과 같다. 첫 번째 슬라이드에는 텍스트 프레임이 있지만 두 번째 슬라이드에는 자동 모양이 있음을 확인할 수 있다.

<소스>

Page 174.

9. 이제 슬라이드, 슬라이드 레이아웃 및 슬라이드 모양이 완성됐따. 슬라이드와 모든 모양에서 텍스트 콘텐츠를 가져온다. 다음 코드는 우리가 필요로하는 것을 정확하게 수행한다.

<소스>

코드 예제의 출력은 다음과 같다. 두 슬라이드의 모든 텍스트를 포함한다. python-pptx 세계에서 text runs으로 불린다.

<소스>

작동원리

이 레시피에서는 전체 프레젠테이션을 읽고 두 슬라이드의 내용을 모두 가져온다.

Microsoft PowerPoint 2013을 사용하여 수동으로 PPTX 파일을 생성하고 PPTX 모듈의 Presentation 클래스를 사용하여 myprofilepptx 파일인 prs의 객체를 생성했다. 이 객체를 사용하여 presentation 객체의 prs.slides 메소드를 사용하여 두 슬라이드에 모두 접속할 수 있다.

다음으로, slides 객체를 사용하여 두 슬라이드에서 slides.shapes가 있는 모든 사용 가능한 모양을 얻는다. 이 객체를 반복하면 슬라이드에서 PLACEHOLDER 및 AUTO_SHAPE와 같은 모양을 얻을 수 있다. 6장의 뒷부분에서 슬라이드와 모양에 대해 더 살펴본다.

이 후 shape.has_text_frame 속성을 사용하여 도형에 텍스트 프레임이 있는지 확인하고 가능한 경우 텍스트 프레임에서 paragraphs 객체를 가져온다. paragraph 객체의 실행 속성에는 실제 텍스트 데이터의 목록이 포함되어 있으며 배열 text_runs에 저장된다.

Page 175.

더 알아보기

좋아! 그래서 presentation 객체, 슬라이드, 레이아웃, 도형, 텍스트 프레임 및 단락과 같은 많은 것들을 하나의 레시피에서 다뤘다. 이것으로 우리는 PPTX 파일을 읽을 수 있는 좋은 위치에 있다.

이 모든 것이 훌륭하지만, 새로운 PPTX 파일을 생성하고싶다. 그렇지? 그리고 프레젠테이션 작성을 자동화하겠는가? 파이썬에서 어떻게 달성할 수 있는지 살펴보자.

프리젠테이션 생성 및 수정, 슬라이드 추가

이 절에서는 레시피에 python-pptx 모듈을 계속 사용한다. 따라서 새로운 모듈을 설치할 필요가 없다. 빈 프레젠테이션을 생성하고 프레젠테이션에 슬라이드를 추가하는 방법과 물론 슬라이드에 내용을 추가하는 방법을 살펴본다.

실행방법

1. Yo! Python로 새로운 PPT를 생성하는 아주 간단한 예제부터 시작해보자. 다음 코드는 프레젠테이션을 생성하 데 도움이 된다.

<소스>

Page 176.

2017.06.09

Page 179.

다음에, 기존 PPT 템플릿에서 새 프레젠테이션을 생성했다. 템플릿은 sample_ppt.pptx 파일에 저장되고 이미 빈 레이아웃 슬라이드가 포함된다. 이것이 이 레시피에서 얻은 것이다.

1. PPT 템플릿으로부터 프리젠테이션 객체 prs를 생성했다. 이 후 프리젠테이션 객체를 사용하여 변수 first_slide에 저장된 첫 번째 슬라이드 prs.slides[0]을 참조했다. 
2. first_slide 객체는 제목 텍스트인 첫 번째 도형에 접속하는 데 사용됐다. 제목 텍스트가 컨텐츠 Hello!로 업데이트 됐다.
3. 나중에 레이아웃 1(제목 및 내용)이 있는 새 슬라이드를 추가하고 slide 변수를 참조했다. 새롭게 생성한 슬라이드의 첫 번째 모양은 This is a paragraph 내용이 추가된 텍스트 프레임이다.
4. 결국 새롭게 생성된 프레젠테이션을 new_ppt.pptx라는 이름으로 저장했다.

Page 180.

더 알아보기

좋아! 그래서 처음부터 새로운 프리젠테이션을 생성하고, 기존 템플릿을 업데이트하고, 새로운 컨텐츠를 추가하고 프리젠테이션을 생성하는 방법을 배웠고, 마지막으로 다양한 유형의 레이아웃과 글 머리 데이터(bullet data)로 프리젠테이션을 생성했다.(확인) 다음 레시피에서는 파이썬을 사용하여 프리젠테이션으로 무엇을 할 수 있는지 살펴보자.

레이아웃, 자리 표시자 및 텍스트 상자로 재생

이제 PPT에 대한 흥미로운 작업을 수행해보자. 중요하게, 자주 사용되는 작업을 살펴본다.

준비하기

이 레시피에는 특정 모듈이 필요하지 않다. 이전 레시피를 위해 설치된 python-pptx 모듈을 사용할 것이다. 이 레시피에서는 다양한 슬라이드 레이아웃으로 작업하고 모양과 텍스트로 재생한다.

실행방법

1. 추가로 이동하여 bulleted content 콘텐츠와 함께 다른 유형의 슬라이드 레이아웃을 사용하자. 다음 코드 조각은 우리가 필요로 하는 것을 수행한다.

<소스>

Page 181.

<소스>

위의 파이썬 코드를 실행할 때 글 머리 기호가 추가된 two content 슬라이드가 있는 새로운 PPT를 얻는다. 다음 스크린 샷은 새로 만들어진 프리젠테이션의 출력을 보여준다. 좋아. 그렇지? 글 머리 기호가 있는 콘텐츠(bulleted content)를 슬라이드의 왼쪽에 placeholders에 추가할 수 있다.

<그림>

2. 이제 창의력을 발휘하여 슬라이드에 다른 유형의 도형 즉 텍스트 상자를 추가해보자. 다음 코드 조각은 슬라이드에 텍스트 상자를 추가한다.

<소스>

Page 182.

2017.06.12

Page 183.

2. 이 후 placeholders를 살펴보자. placeholder는 내용을 추가할 수 있는 미리 서식이 지정된 컨테이너이다. Placeholder는 모양의 분류이므로 여러 모양에 placeholders가 있을 수 있다. 예를 들어 autoshape(첫 번째 레시피에서 본 원형)은 placeholder이다. 그림 혹은 그래픽 프레임은 placeholder가 될 수 있다. 두 개의 내용으로된 슬라이드에 두 개의 placeholders, 왼쪽에 하나, 오른쪽에 하나가 있다. shapes.placeholders[1]로 왼쪽 하나를 목표로 하고 shapes.placeholders[1].text_frame을 참조하는 텍스트 프레임을 위해 첫 번째 라인 This is line 1을 추가했다.
3. 이 후 add_paragraph() 메소드로 text_frame에 단락을 추가하고 텍스트 Again a line 2… 를 레벨1에 추가하고 And this is line 3…을 레벨 2에서 추가하여 글 머리 기호 행(bulleted lines)을 추가했다.
4. 기본적으로 모든 도형에 텍스트가 포함되어 있는 것은 아니지만 도형이 텍스트를 지원하는지 확인하는 것은 shape.has_text_frame 속성을 사용하여 수행할 수 있다. 이 레시피에서는 텍스트 내용을 처리할 수 있는 자리표시자(placeholder)가 모양에 포함되어 있음을 알 수 있다. 따라서 text_frame 속성을 사용하여 첫 번째 텍스트 행을 추가했다. 마찬가지로 level 속성을 사용하여 글 머리 기호로 후행을 추가하기 위해 add_paragraph() 메소드를 사용했다.
5. 결국 새로운 프리젠테이션을 two_content.pptx라는 이름으로 저장했다. 스크린샷을 살펴보면 슬라이드의 왼쪽 텍스트 프레임에 추가된 텍스트에 글 머리 기호 모양이 표시된다.

다음으로 프리젠테이션에 텍스트박스를 추가했다. 텍스트박스는 프레젠테이션에서 매우 일반적으로 사용된다. 사람들은 텍스트박스를 사용하여 점을 강조 표시하고 텍스트박스의 리사이즈 및 이동 기능을 사용하여 효과를 낸다. 여기 레시피에서 한 일이 있다.

1. 먼저 레이아웃 6으로 빈 슬라이드를 생성하고 add_slide() 메소드를 사용하여 프레젠테이션에 추가했다.
2. 다음으로 적절한 크기의 텍스트박스를 생성했다. 왼쪽 및 위쪽 좌표에 대해 Inches(2)를 사용한 다음 너비 및 높이를 각각 Inches(5) 및 Inches(1)로 관리했다. 여기서 인치는 1 inch = 2.54 cm인 실제 동일한 엔티티에 매핑된다. 이 텍스트박스를 add_textbox() 메소드로 슬라이드에 추가했다.
3. textbox 객체를 사용하여 text_frame 속성과 함께 텍스트 프레임 객체 tf를 추가했다.
4. 이전 레시피에서도 볼 수 있듯이 텍스트 프레임에 텍스트 Wow! I'm inside a textbox를 추가했다.

Page 184.

5. add_paragraph() 메소드가 있는 단락을 추가하고 이 단락에 Adding a new text 추가 및 텍스트를 굵게, 기울임 꼴로 만들고 글꼴을 30으로 늘리고 추가했다. 
6. 결국 파일을 textBox.pptx로 저장했다.

자리표시자(placeholders) 및 텍스트 프레임을 살펴봤다. 텍스트 프레임과 단락을 사용하여 슬라이드에 텍스트를 추가하는 방법을 다뤘다. 필요한 크기의 텍스트박스를 슬라이드 데크에 추가하는 방법도 살펴봤다.

다른 모양으로 작업과 표 추가

이제 다른 모양, 표 혹은 그림을 추가하여 프레젠테이션을 더욱 재미있게 만들어 보자. 왜 기다리나? 신속하게 행동하자.

준비하기

이 레시피에는 특정 모듈이 필요하지 않다. 이전 레시피에서 설치된 python-pptx 모듈을 사용할 것이다.

실행방법

1. 이 레시피에서는 프레젠테이션에 몇 가지 모양을 추가한다. 모양은 실제 객체를 나타낼 수 있고 관계를 나타낼 수 있으며 청중(프레젠테이션을 듣고 있는 사용자)에게 시각적인 피드백을 제공하므로 프레젠테이션에 매우 유용하다. 이 레시피에서는 Home button을 추가하고 Rectangular Callout을 추가하여 Home button의 위치를 표시한다. Callout 요소에 커스텀 색상도 채운다. 다음 코드는 모양을 프레젠테이션에 추가한다.

<소스>

Page 185.

<소스>

앞의 코드를 실행한 후 다음 스크린 샷과 같은 새로운 스크린샷 shape.pptx를 얻는다. 

<그림>

Page 186.

2. 깔끔하다! 이제 프레젠테이션에 표를 추가할 수 있는지 알아보자. 다시 표는 데이터를 명시하고 정보에 알려진 결정을 내리기 위해 프리젠테이션에서 사용된다. 발표자(프리젠테이션을 담당하는 사람)는 종종 테이블을 통해 특정 프로젝트에 대한 사실을 제기하고 토론이나 의견을 청취한다. 다음 코드를 참조하면 프리젠테이션에 테이블을 추가하는 것은 파이썬에서는 쉽다. 여기에는 3명의 학생에 대한 학생 정보가 포함된 표가 추가된다.

<소스>

Page 187.

이 코드 조각을 실행하면 모든 학생 데이터가 포함된 프레젠테이션에서 생성된 표가 표시된다. 다음 스크린샷을 참조한다.

<그림>

작동원리

첫 번째 코드 조각에서는 다음과 같은 작업을 수행하여 프레젠테이션에 몇 가지 모양을 추가했다.

1. 모양의 유형을 입력으로 사용하는 add_shapes() 메소드 도움으로 모양을 추가했다.
2. 이 코드에서는 MSO_SHAPE 열거(모든 모양이 나열되어 있음)의 도움을 받아 MSO_SHAPE.RECTANGULAR_CALLOUT 및 MSO_SHAPE.ACTION_BUTTON_HOME이라는 두 가지 모양을 선택한다. 텍스트박스와 마찬가지로 add_shapes() 메소드도 Inches() 메소드로 정의된 모양의 크기가 필요하다.
3. SlideShape 클래스의 fill 메소드를 사용하여 callout shape에 대한 사용자 지정 색을 정의할 수 있다. shape.fill.fore_color.rgb 속성은 callout shape의 색상을 설정하는 데 사용된다. 사용된 RGB 색상은 스크린샷에서 볼 수 있듯이 밝은 파란색 색상인 1E90FF이다. shape.fill.fore_color.brightness 속성을 사용하여 색상 밝기를 설정한다.
4. 물론 shape.text 속성을 설정하여 두 가지 모양 모두에 텍스트를 추가했다. 결국 파일을 shapes.pptx로 저장했다.

Page 188.

두 번째 예제에서는 파이썬 코드를 사용하여 멋진 테이블을 프리젠테이션에 추가했다. 이것이 우리가 한 일이다.

2017.06.19

1. Title only 레이아웃으로 프리젠테이션을 생성하고 add_slide() 메소드를 사용하여 단일 슬라이드를 추가했다. 또한 슬라이드의 제목을 Students Data라고 정의했다.
2. 표를 추가하는 것은 도형을 추가하는 것만큼 간단하다. add_table() 메소드를 사용하여 프리젠테이션에 테이블을 추가했다. 예상대로 add_table() 메소드는 다수의 행과 열을 입력으로 기대하며 동시에 테이블의 크기를 예상한다. 이 예제에서는 행을 4로 설정하고 열을 3으로 설정하고 좌표를 Inches(2), Inches(2), Inches(6) 및 Inches(8)로 테이블 크기로 설정했습니다. 왼쪽에서 2 인치, 슬라이드 상단에서 2 인치 아래쪽에 있으며 테이블 너비는 6 인치이고 높이는 1.2 인치 (15.3cm x 3.1cm) 이다.(확인)
3. 테이블을 세 개의 열로 정의했다. 각각의 너비는 2인치로 설정된다. table.columns.width 속성을 사용하여 이를 설정한다. 또한 table.cell(row, column).text 속성을 사용하여 열 머리글의 텍스트를 Sr.No,Student Name 및 Student Id로 설정한다. 여기에서 행 값은 항상 첫 번째 행 혹은 제목 행을 나타내는 0이며 열은 0에서 2까지 다양하며 3 열을 나타낸다.
4. 이 예제에서는 학생 이름과 학생 ID와 같은 정보가 있는 사전 정의된 딕셔너리를 사용했다. 모든 학생 정보를 반복하고 표의 셀을 업데이트하여 스크린샷에 표시된대로 모든 학생 데이터가 있는 테이블을 적절한 정보로 채운다.
5. 결국 프레젠테이션을 table.pptx로 저장했다.

더 알아보기

좋아. 파이썬을 사용한 프리젠테이션으로 우리가 할 수 있는 다른 것들은 무엇인가? 또는 당신 중 일부는 이미 차트나 그림에 대해 그래픽으로 이야기할 것을 기대한다. 그렇지? 예, 그것을 또한 커버할 것이다. 그래픽으로 이야기 해보자.

Page 189.

그림과 차트로 시각적 처리

그래, 이제 이것을 시작할 시간이다. 이 절에서는 그림과 차트를 프레젠테이션에 추가하는 방법을 살펴본다. 그들은 그림이 천 개의 단어를 말하고 진정으로 그림과 그래프가 많은 프레젠테이션을 보았음에 틀림 없다. 그들은 이유가 있다. 한 슬라이드에서 최대한 많은 정보를 전달할 수 있다. 차트와 그림은 모두 이 힘을 가지며, 그들에 대해 알지 못해도 6장은 불완전한 채로 남는다. 그래 뛰어들자.

준비하기

이 레시피에는 특정 모듈이 필요하지 않다. 이전 레시피 용으로 설치된 python-pptx 모듈을 사용한다.

실행방법

이 레시피를 두 부분으로 나눈다. 먼저 슬라이드에 그림을 추가하는 방법을 설명하고 다음은 차트를 다룬다.

1. 다음 코드 조각은 슬라이드에 그림을 추가하는 데 도움이 된다.

<소스>

Page 190.

앞의 프로그램을 실행하면 다음 스크린샷과 같이 두 개의 그림이 있는 슬라이드가 표시된다.

<그림>

2. 이제 슬라이드에 차트를 추가하는 파이썬 코드를 작성할 수 있는지 살펴보자. python-pptx 모듈은 선형 차트, 막대 차트 및 거품 차트와 같은 여러 유형의 차트를 지원하지만 가장 좋아하는 차트는 항상 원형 차트다. 레시피에 하나를 추가하는 것은 어떨까? 예, 다음 코드는 프레젠테이션에 파이 차트를 추가한다.

<소스>

Page 191.

<소스>

앞의 프로그램의 출력은 다음과 같다.

<그림>

Page 192.

작동원리

첫 번째 코드 조각에서 두 개의 이미지를 슬라이드에 추가했다. 그것을 어떻게 했나? 논리적인 것처럼 add_picture() 메소드를 사용했다. 라이브러리가 좋지 않은가? add_textbox()로 텍스트박스를 추가하고 add_slide()로 슬라이드를 추가한 다음 add_picture()로 그림을 추가한다. 레시피의 첫 부분에서 했던 것을 더 자세히 살펴보자.

1. 예상대로 add_picture()는 이미지를 프레젠테이션에 추가해야 하는 위치와 다른 메소드와 마찬가지로 그림의 좌표와 크기를 예상한다. 이 예제에서는 두 개의 그림을 추가했다. 첫 번째 그림은 python.org이며, 왼쪽에서 2 인치, 맨 위에서 2 인치까지 표시되도록 구성했다. 또한 사진의 너비를 3 인치, 높이를 2 인치로 구성했다.
2. 추가한 두 번째 그림은 learn_python.jpeg이다. 왼쪽에서 2인치, 위쪽에서 5인치, 높이 2인치 및 너비가 이미지와 같도록 구성됐다.
3. 이 예제에서는 빈 슬라이드 레이아웃으로 새 슬라이드를 생성하고 두 그림을 추가했으며 결국 파일을 picture.pptx로 저장했다.

두 번째 부분에서는 원형 차트를 슬라이드 데크에 추가했다. 다음과 같은 방법으로 이것을 했다.

1. 슬라이드를 추가하고 Data based on regions에 제목 텍스트를 설정했다.
2. 그런 다음 클래스의 객체인 ChartData()를 생성하고 chart_data라는 이름을 지정했다. chart_data.categories 속성을 사용하여 원형 차트의 범주를 정의하고 이를 ['West', 'East', 'North','South'] 배열로 설정했다. 또한 모든 지역의 데이터로 chart_data 객체를 구성했다. add_series() 메소드로 그렇게 했다.
3. 이 차트를 프레젠테이션 슬라이드에 어떻게 추가했나? 예, 그것을 짐작했다. add_chart() 메소드는 이를 수행한다. add_chart() 메소드는 차트 유형을 인자 중 하나로 간주하며 다른 메소드와 마찬가지로 배열(dimensions)을 필요로한다. 코드에서는 has_legend, number_format 및 데이터 라벨 속성을 설정하여 원형 차트를 멋지게 보인다.

더 알아보기

좋아! 그래서 6장에서 많은 흥미로운 것을 배웠다. 그러나 이 지식을 적용하여 실제 사용 사례를 해결하는 것보다 더 재미있는 것은 무엇인가? Alex가 주간 판매 보고서에 몇 가지 문제가 있다고 들었나?

Page 193.

주별 판매 보고서 자동화

Alex는 노트북 및 비즈니스 소프트웨어를 판매하는 Innova 8 Inc의 판매 매니져다. 그는 상황을 보고하는 여러 판매원이 있다. 그는 부하 직원의 성공 여부를 측정하고 매주 영업부 VP에게 보고한다. Alex의 사장은 비즈니스 계정에서 발생한 수익과 영업 관리자의 성과라는 두 가지 사항을 살펴본다. 알렉스는 매주 직원 회의에서 이 수치를 보고해야 한다. 그는 주 단위로 판매 VP에게 데이터를 대조하고 표현하는 도구로 파워포인트를 사용한다.

그러나 알렉스에게는 몇 가지 문제가 있다. 영업 관리자로부터 얻는 데이터는 종종 Excel 시트에 있다. 또한 데이터가 너무 동적이어서 회의 직전에 고객이 지불했는지 여부에 따라 마지막 순간까지 변경된다. 알렉스가 이 변동성으로 인해 회의를 위해 미리 프리젠테이션을 작성하는 것은 어렵다. 또한 알렉스가 데이터를 분석하고 차트를 작성하는 일은 지루한 일이다. 이것은 완전히 수동 프로세스이다.

6장에서 배운 내용으로 알렉스를 도울 수 있나?

준비하기

문제를 분석하면 알렉스의 전체 프로세스를 자동화할 수 있다. 알렉스의 데이터는 Excel 시트에 있다. 파이썬의 pandas 모듈로 이 데이터를 쉽게 읽을 수 있다. 또한, python-pptx 모듈로 새로운 프리젠테이션을 생성할 수 있다.

다음 단계는 알렉스의 문제를 해결하는 데 도움이 될 수 있다.

1. 엑셀 시트의 내용을 읽고 필요한 데이터를 얻는다.
2. 새 파워포인트 프레젠테이션을 생성하고 두 개의 슬라이드를 추가한다.
3. 첫 번째 슬라이드에서 여러 계정의 수익 수치를 보여주는 원형 차트를 생성하고 비율을 기준으로 비교한다.
4. 두 번째 슬라이드에서는 수익을 기준으로 판매 관리자의 실적을 비교하는 막 대형 차트를 추가한다.

이 레시피를 위해서 pandas 모듈을 설치하자. 가장 좋아하는 유틸리티 Python pip로 그렇게 한다. pandas를 설치하기 위해 다음 명령을 사용한다.

<소스>

Page 194.

2017.06.23

Page 198.

다음으로 레이아웃 6가 적용된 새로운 빈 슬라이드를 새로운 프리젠테이션에 추가했다. 이 슬라이드를 사용하여 계정의 수익 데이터를 추가했다. prs.slides.add_slide() 메소드를 사용하여 이를 달성했다. 그러나 데이터는 엑셀 시트에 있으므로 엑셀 시트의 reader 객체를 사용하여 Sales 워크시트를 읽는다. Sales 워크시트에는 알렉스가 자신의 분석에 사용하는 모든 데이터가 있다. pandas 모듈은 데이터 프레임(매트릭스 형식으로 저장된 데이터) 형태로 Excel 데이터를 읽는다. Excel 시트 스크린 샷을 보면 Price 및 Quantity라는 두 개의 열이 있고 이 열은 판매된 랩톱 또는 소프트웨어 라이선스 수량과 단위당 가격을 나타낸다. 따라서 코드에서 먼저 이러한 값을 곱하여 Excel 레코드의 각 항목에 대한 수익을 얻고 열 이름 total을 사용하여 데이터 프레임에 저장한다. 이제 총 수입 수치가 필요하지 않다. 또한 계정을 기반으로 분류해야 한다. 데이터 프레임을 사용하면 이 정보를 얻는 것이 매우 쉽다. SQL 쿼리를 실행하는 것과 같다. 코드를 살펴보면 Account로 데이터 프레임을 그룹화하고 모든 total 데이터(수량 * 가격)를 합한 다음 데이터 포인트를 사용하여 파이 차트를 작성하여 총 수익의 백분율로 매 계정을 나타내어 알렉스가 쉽게 비교할 수 있도록 했다. 데이터를 그룹화하기 위해 groupby() 메소드를 사용한 다음 sum() 메소드를 사용하여 수익을 합계하고 plot() 메소드를 사용하여 원형 차트를 플로팅 했다. 차트가 PowerPoint가 아닌 pandas에서 사용 가능한 경우 유용하지 않으므로 result.png에서 PNG 파일로 차트를 저장한다. pandas의 savefig() 메소드를 사용하여 이를 수행했다. 결국 add_picture() 메소드를 사용하여 이 그림 파일을 프레젠테이션에 추가하고 그림의 좌표와 크기를 관리하여 시각적으로 훌륭하게 보인다. 

알렉스는 또한 모든 영업 관리자의 성과를 계획해야 한다. 이를 위해 동일한 메소드로 엑셀 시트 데이터를 읽고 데이터 프레임 형식으로 저장했다. 그러나 이 문제의 경우 영업 관리자가 데이터를 그룹화하고 각각에 대한 총 수익을 계산했다. 여기에서도 groupby() 메소드를 사용했지만 Excel 데이터의 Manager 열은 사용했다. 모든 판매 관리자의 이름을 배열 managers에 저장하고 각 판매 관리자에 대한 모든 레코드를 반복하고 각 판매 관리자의 판매 수치를 얻은 다음 이를 목록 sales에 추가했다. 이 후 이 목록을 튜플로 변환하여 나중에 사용할 수 있다. 이전 레시피와 마찬가지로 ChartData() 메소드를 사용하여 차트 데이터 객체를 생성하고 'sales' 튜플이 입력된 클러스터 막대 차트를 만든 다음 add_chart() 메소드를 사용하여 차트를 프레젠테이션의 두 번째 슬라이드에 추가했다.

결국 이 새로 생성된 프레젠테이션을 알렉스의 주간 판매 보고서로 사용되는 sales.pptx로 저장했다. 그게 전부다.

6장의 조리법, 예제 및 논의한 유스 케이스를 즐겁게 사용하기 바란다. 나는 당신의 프리젠테이션을 자동화하기 위해 당신의 손이 가려울 것이라고 확신한다. 책상에 들러 책상에 앉아서 일을 제대로하는 시간은 언제인가?

Page 199.

2017.06.26 

소개

API는 인터넷이 주도하는 세계에서 절대적으로 필요 불가결하게 됐다. 상호 작용해야하는 모든 웹 애플리케이션은 핵심 기능인 Amazon, Google, Twitter를 구현하기 위해 백엔드의 API를 사용한다. 게다가 이러한 모든 애플리케이션은 API에서 번영함을 알 수 있다. 아마존은 지불 거래를 유도하고 구글을 사용하여 멋진 지도를 보여준다. API는 비즈니스에 매우 중요하므로 CEO에서 관리자, 소프트웨어 개발자에게 API라는 단어를 들을 수 있다. 일반적으로 API를 사용하는 것은 서로 다른 소프트웨어가 서로 대화할 수 있게하는 근본적인 방법이다. 운영체제 작동도 API로 수행된다. 그들은 컴퓨팅의 이른 초기부터 절대적으로 비판적이다. 

그러나 API는 무엇이며 어떻게 유용하나? 자신의 API를 어떻게 개발할까? 비즈니스 프로세스 자동화에 대한 방법을 어떻게 찾을까? 7장에서 이 모든 질문에 대한 답을 찾을 수 있다.

Page 200.


 







