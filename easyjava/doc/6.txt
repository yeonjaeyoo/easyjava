6장.UDP와 멀티캐스팅

UDP(User Datagram Protocol)는 IP의 위쪽에 위치하고 TCP에 비교하여 신뢰할 수 없다. UDP는 네트워크에서 두 노드 간의 개별적인 패킷을 전송한다. UDP 패킷은 다른 패킷에 대한 지식을 가지고 있지 않으며, 실제로 패킷이 의도한 목적지에 도착한다는 보장은 하지 않는다. 다수의 패킷이 전송되는 경우, 도착 순위의 보증은 없다. 수신인에서 보낸 인식이 없는 것처럼 UDP 메시지는 단순히 전송한 후 잊어버린다.

UDP는 비연결 프로토콜이다. 패킷 전송을 용이하게 하는 두 노드들 간의 메시지 교환은 없다. 접속에 대한 어떠한 상태 정보도 유지되지 않는다. 

UDP는 전달은 효율적으로 필요한 곳의 서비스에 적합하고, 전달의 보장이 필요하지는 않다. 예를 들어, DNS(Domain Name System)의 서비스, NTP(Network Time Protocol) 서비스, VOIP(Voice Over IP), P2P 네트워크에서 네트워크 통신의 조정과 비디오 스트리밍을 위해 사용된다. 비디오 프레임이 손실되는 경우, 손실이 자주 발생하지 않는다면, 뷰어(viewer)는 알 수 없다.

다음을 포함한 UDP를 사용하는 여러 프로토콜이 있다.

2016.05.18

-RTSP(Real Time Streaming Protocol): 이 프로토콜은 미디어 스트리밍을 제어하기 위해 사용된다.
-RIP(Routing Information Protocol): 이 프로토콜은 패킷을 전송하는 데 사용되는 경로를 결정한다.
-DNS(Domain Name System): 이 프로토콜은 인터넷 도메인 이름을 검색하고 그 IP 주소를 반환한다.
-NTP(Network Time Protocol): 이 프로토콜은 인터넷을 통해 시각을 동기화한다.

Page 140.

UDP 패킷은 목적지를 식별할 수 있는 IP 주소와 포트 번호로 구성된다. UDP 패킷은 고정된 크기를 가지며 65,353 바이트만큼 클 수 있다. 그러나 각 패킷은 65507 바이트의 메시지의 크기를 제한하는 IP 헤더를 위해서는 최소 20 바이트로 사용하고 UDP 헤더는 최소 8 바이트로 사용한다. 메시지가 그것보다 큰 경우, 다수의 패킷이 전송될 필요가 있을 것이다.

UDP 패킷은 또한 멀티캐스트 할 수 있다. 이것은 패킷이 UDP 그룹에 속한 모든 노드로 전송되는 것을 의미한다. 명시적으로 각각의 노드를 대상없이 여러 노드에 정보를 전송하는 효율적인 방법이다. 대신에 패킷은 그 그룹의 패킷을 캡처할 책임이 있는 멤버의 그룹에 전송된다.

6장에서는 UDP 프로토콜을 사용할 수 있는 방법을 설명한다. 

-기존의 클라이언트/서버 모델 지원
-UDP 작업을 수행하는 NIO 채널을 사용
-그룹 멤버들에게 패킷을 멀티캐스트
-클라이언트에게 오디오 혹은 비디오 같은 스트림 미디어

UDP에 대한 자바 지원의 개요로 시작하고 더 많은 UDP 프로토콜 정보를 제공한다.

UDP에 대한 Java 지원

자바는 노드간에 소켓 연결을 형성하는 DatagramSocket 클래스를 사용한다. DatagramPacket 클래스는 데이터 패킷을 나타낸다. 단순한 send 및 receive 메소드는 네트워크를 통해 패킷을 전송할 것이다.

2016.05.19
UDP는 노드를 식별하는 데 IP 주소와 포트 번호를 사용한다. UDP 포트 번호는 0에서 65535까지다. 포트 번호는 세 종류로 분류된다.

-잘 알려진 포트(0 ~ 1023): 상대적으로 공통 서비스에 사용되는 포트 번호이다.
-등록된 포트(1024 ~ 49151): 프로세스를 위해 IANA에서 할당된 포트 번호이다.
-동적/사설 포트(49152 ~ 65535): 연결이 초기화될 때 동적으로 클라이언트에 할당된다. 일반적으로 일시적이며 IANA에 의해 할당할 수 없다.

Page 141.

다음 표는 UDP 특정 포트 할당의 간단한 목록이다. UDP가 강범위하게 많고 다양한 애플리케이션과 서비스를 지원하는 데 사용되는 방법을 예시한다. TCP/UDP 포트 번호의 보다 완전한 목록은 https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers에서 확인한다.

<표>

다음 표는 등록된 포트 및 그 사용 목록을 보여준다.

<표>

Page 142.

TCP 대 UDP

TCP와 UDP 간의 몇 가지 차이가 있다. 이러한 차이는 다음과 같다.

-신뢰성(Reliability): TCP는 UDP보다 더 신뢰할 수 있다.
-순서(Ordering): TCP는 패킷 전송의 순서가 유지되는 것을 보장한다.
-헤더 크기(Header size): UDP 헤더는 TCP 헤더보다 작다.
-속도(Speed): UDP는 TCP보다 빠르다.

패킷이 TCP를 이용하여 전송될 때, 패킷이 도착하는 것을 보장한다. 분실되면, 다시 전송된다. UDP는 이 보장을 제공하지 않는다. 패킷이 도착하지 않는 경우, 다시 전송되지 않는다.

TCP는 패킷의 전송 순서를 보장하지만, UDP는 보장하지 않는다. TCP 패킷들이 전송된 방법과 다른 순서로 목적지에 도달하는 경우, TCP는 원래 순서대로 패킷을 조립할 것이다. UDP의 경우, 이 순서는 유지되지 않는다.

패킷이 생성될 때, 헤더 정보는 패킷의 전달을 지원하기 위해 부착된다. TCP 헤더의 일반적인 크기는 32 바이트이다.

신뢰성을 확보하기 위한 작은 헤더 크기와 오버 헤드의 부족으로, UDP는 TCP보다 더 효율적이다. 또한, 작은 노력으로 연결을 생성할 필요가 있다. 이 효율성은 미디어를 스트리밍하기 위한 더 나은 선택을 만든다.

전통적인 클라이언트/서버 아키텍처를 지원하는 방법을 UDP 예제로 시작하자.

UDP 클라이언트/서버

UDP 클라이언트/서버 애플리케이션은 TCP 클라이언트/서버 애플리케이션에 사용되는 구조와 유사하다. 서버 측면에서, 생성된 UDP 서버 소켓은 클라이언트 요청을 기다린다. 클라이언트는 대응하는 UDP 소켓을 생성하고, 서버에 메시지를 전송하는 데 사용된다. 그러면 서버는 요청을 처리하고 응답을 전송할 수 있다.

UDP 클라이언트/서버는 메시지를 보유하는 DatagramPacket과 소켓을 위한 DatagramSocket 클래스를 사용한다. 메시지의 콘텐츠 타입은 제한이 없다. 예제에서는 텍스트 메시지를 사용할 것이다.

Page 143.

UDP 서버 애플리케이션

2016.05.20

서버는 다음에 정의된다. 생성자는 서버의 작업을 수행한다. 

<소스>

생성자의 try-with-resources 블록에서, DatagramSocket 클래스의 인스턴스를 생성한다. 사용되는 다수의 메소드는 필요한 경우 IOException 예외를 발생시킬 수 있다.

<소스>

다음과 같이, 소켓을 생성하는 또 다른 방법은 bind 메소드를 사용하는 것이다. DatagramSocket 인스턴스는 매개변수로 null을 사용하여 생성된다. 포트는 다음 bind 메소드로 할당된다.

<소스>

두 가지 방법은 포트 9003을 사용하여 DatagramSocket 인스턴스를 생성한다. 

메시지를 전송하는 과정은 다음과 같이 구성한다.

-바이트 배열 생성
-DatagramPacket 인스턴스 생성
-도착 메시지의 대기를 위한 DatagramSocket 인스턴스 사용

Page 144.

다음과 같이, 여러 요청을 처리할 수 있도록, 프로세스는 loop를 닫는다. 수신되는 메시지는 단순히 클라이언트 프로그램으로 에코 백(echoed back) 한다. DatagramPacket 인스턴스는 바이트 배열과 길이를 사용하여 생성된다. DatagramSocket 클래스의 receive 메소드의 인자로 사용된다. 패킷은 이 시간에 어떤 정보도 보유하지 않는다. 요청이 이루어질 때까지 이 메소드는 블록하며, 그 후 패킷은 채워진다.

<소스>

메소드가 반환될 때, 패킷은 스트링으로 변환된다. 다른 데이터 타입은 전송된 경우, 다른 변환이 필요하다. 전송된 메시지는 표시된다.

<소스>

응답을 보내기 위해, 클라이언트의 주소와 포트 번호가 필요하다. 이러한 정보를 보유하는 패킷에 대해 각각 getAddress와 getPort 메소드를 사용하여 얻어진다. 클라이언트를 논의할 때 이것은 표시된다. 또한 필요로하는 것은 getBytes 메소드가 제공하는 바이트의 배열로 표현되는 메시지이다.

<소스>

새로운 DatagramPacket 인스턴스는 메시지, 길이 및 클라이언트의 주소와 포트 번호를 사용하여 생성된다. send 메소드는 클라이언트에 패킷을 전송한다.

<소스>

정의된 서버로 클라이언트를 살펴 보자.

Page 145.

UDP 클라이언트 애플리케이션

클라이언트 애플리케이션은 전송하는 메시지를 사용자에게 표시하며, 그 후 서버에 메시지를 전송한다. 응답을 대기한 후 응답을 표시한다. 그것은 여기에 선언된다.

<소스>

Scanner 클래스는 사용자 입력을 받아 지원한다. try-with-resources 블록은 DatagramSocket 인스턴스를 생성하고 예외를 처리한다.

<소스>

클라이언트의 현재 주소는 getByName 메소드를 사용하여 접속하고, 바이트 배열에 대한 참조가 선언된다. 이 주소는 패킷을 생성하는 데 사용된다.

<소스>

무한 루프는 메시지를 사용자에게 메시지를 표시하는 데 사용된다. 사용자가 "quit"를 입력하면 다음과 같이, 애플리케이션은 종료된다.

<소스>

Page 146.

메시지를 보유한 DatagramPacket 인스턴스를 생성하려면 생성자는 메시지, 길이, 클라이언트의 주소와 포트 번호를 나타내는 바이트의 배열이 필요하다. 다음 코드에서 서버의 포트는 9003이다. send 메소드는 서버에 패킷을 전송할 것이다.

<소스>

응답을 수신할 때, 수신된 패킷을 생성하고 서버에서 처리된 것과 동일한 방법으로 receive 메소드에 사용된다. 서버가 응답할 때까지 이 메소드는 차단하고 다음 메시지가 표시된다.

<소스>

지금, 작업에서 이러한 애플리케이션을 볼 수 있다.

작동중인 UDP 클라이언트/서버

서버는 먼저 시작된다. 다음과 같은 메시지가 표시된다.

UDP Server Started

다음에, 클라이언트 애플리케이션을 시작한다. 다음과 같은 메시지가 표시된다.

UDP Client Started

Enter a message:

다음과 같이, 메시지를 입력한다.

Enter a message: Top of the morning to you

Page 147.

다음과 같이 서버는 메시지를 수신한 것을 표시한다. 출력의 다수 빈 라인을 볼 수 있다. 이것은 메시지를 보유하여 사용하는 1024 바이트 배열의 내용이다. 메시지는 다시 클라이언트에 에코백된다.(echoed back)

Page 150.

그러나 get 메소드는 버퍼의 현재 위치를 수정한다. 다시 클라이언트에게 메시지를 전송하기 전에 원래 상태로 위치를 복원해야 한다. 버퍼의 mark와 reset 메소드는 이러한 목적을 위해 사용된다.

이 모든 것은 다음 코드 시퀀스로 수행된다. mark 메소드는 현재 위치에서 마크(mark)를 설정한다. StringBuilder 인스턴스는 클라이언트에서 전송된 스트링을 되살리는 데 사용된다. 버퍼의 hasRemaining 메소드는 while 루프를 제어한다. 메시지는 표시되고 reset 메소드는 이전에 마크된 값의 위치를 복원한다.

<소스>

마지막 단계는 다시 클라이언트에게 바이트 버퍼를 전송하는 것이다. send 메소드는 이 작업을 수행한다. clear 메소드에 따라서 전송된 메시지를 가리키는 메시지는 보여준다.(수정필요) 버퍼를 통하기 때문에 이 메소드는 사용된다. 그것은 위치를 0으로 설정하고 버퍼 용량의 limit를 설정하고, 마크를 삭제한다.

<소스>

다음과 같이, 서버가 시작되면 이 효과에 메시지가 표시된다. 

UDP Echo Server Started

이제 클라이언트가 구현되는 방식을 확인할 준비가 된 것이다.

UDP 에코 클라이언트 애플리케이션

UDP 에코 클라이언트의 구현은 간단하고 다음 단계를 사용한다. 

-에코 서버에 대한 연결이 설정된다.
-바이트 버퍼는 메시지를 저장하기 위해 생성된다.
-버퍼는 서버로 전송된다.
-메시지는 재전송될 때까지 클라이언트는 블록한다.

Page 151.

클라이언트의 구현 세부 사항은 서버의 유사하다. 다음과 같이 애플리케이션의 선언으로 시작한다.

<소스>

서버에서는 단일 인자 InetSocketAddress 생성자는 현재의 IP 주소와 포트 9000을 연결한다. 클라이언트 내에서는 포트와 함께 서버의 IP 주소를 지정해야한다. 그렇지 않으면 여기서 메시지를 전송하는 것을 결정할 수 없다. 클래스의 2개 인자 생성자를 사용하여 다음과 같은 구문을 수행할 수 있다. 클라이언트와 서버가 동일한 머신에 있다고 가정하면, 주소 127.0.0.1를 사용한다.

<소스>

채널은 open 메소드로 생성되고 connect 메소드로 소켓 주소로 연결된다. 

<소스>

다음 코드 시퀀스에서, 메시지 스트링은 생성되고, 바이트 버퍼가 할당된다. 버퍼의 크기는 스트링의 길이로 설정된다. put 메소드는 이 후 버퍼에 메시지를 할당한다. put 메소드는 바이트의 배열을 기대하고, 메시지 내용에 해당하는 바이트 배열을 얻기 위해 String 클래스의 getBytes 메소드를 사용한다.

<소스>

Page 152.

서버로 버퍼를 전송하기 전에 flip 메소드가 호출된다. 그것은 현재의 위치에 limit을 설정하고 0으로 위치를 설정한다. 따라서, 서버에 의해 수신된 경우에 처리될 수 있다.

<소스>

다음과 같이, 서버에게 메시지를 전송하기 위해, 채널의 write 메소드는 호출된다. 서버에 직접적으로 기본 패킷을 전송할 것이다. 채널의 소켓이 초기에 달성된 접속되는 경우, 이 메소드는 단지 작동한다.

<소스>

다음으로, 버퍼는 버퍼를 재사용 할 수 있도록 지워진다. read 메소드는 버퍼를 수신하고, 버퍼는 서버에서 사용된 동일한 프로세스를 사용하여 표시한다.

<소스>

이제 서버와 함께 클라이언트를 사용하여 준비한다.

작동중인 UDP 에코 클라이언트/서버

서버는 먼저 시작해야한다. 다음과 같이 초기 서버 메시지가 표시된다.

UDP Echo Server Started

다음으로, 클라이언트를 시작한다. 다음 출력은 반환된 메시지를 표시한 후 메시지를 전송하는 클라이언트를 보여주는 것이 표시된다.

UDP Echo Client Started
Sent: [The message]
Received: [The message]
UDP Echo Client Terminated

Page 153.

