6장.UDP와 멀티캐스팅

UDP(User Datagram Protocol)는 IP의 위쪽에 위치하고 TCP에 비교하여 신뢰할 수 없다. UDP는 네트워크에서 두 노드 간의 개별적인 패킷을 전송한다. UDP 패킷은 다른 패킷에 대한 지식을 가지고 있지 않으며, 실제로 패킷이 의도한 목적지에 도착한다는 보장은 하지 않는다. 다수의 패킷이 전송되는 경우, 도착 순위의 보증은 없다. 수신인에서 보낸 인식이 없는 것처럼 UDP 메시지는 단순히 전송한 후 잊어버린다.

UDP는 비연결 프로토콜이다. 패킷 전송을 용이하게 하는 두 노드들 간의 메시지 교환은 없다. 접속에 대한 어떠한 상태 정보도 유지되지 않는다. 

UDP는 전달은 효율적으로 필요한 곳의 서비스에 적합하고, 전달의 보장이 필요하지는 않다. 예를 들어, DNS(Domain Name System)의 서비스, NTP(Network Time Protocol) 서비스, VOIP(Voice Over IP), P2P 네트워크에서 네트워크 통신의 조정과 비디오 스트리밍을 위해 사용된다. 비디오 프레임이 손실되는 경우, 손실이 자주 발생하지 않는다면, 뷰어(viewer)는 알 수 없다.

다음을 포함한 UDP를 사용하는 여러 프로토콜이 있다.

2016.05.18

-RTSP(Real Time Streaming Protocol): 이 프로토콜은 미디어 스트리밍을 제어하기 위해 사용된다.
-RIP(Routing Information Protocol): 이 프로토콜은 패킷을 전송하는 데 사용되는 경로를 결정한다.
-DNS(Domain Name System): 이 프로토콜은 인터넷 도메인 이름을 검색하고 그 IP 주소를 반환한다.
-NTP(Network Time Protocol): 이 프로토콜은 인터넷을 통해 시각을 동기화한다.

Page 140.

UDP 패킷은 목적지를 식별할 수 있는 IP 주소와 포트 번호로 구성된다. UDP 패킷은 고정된 크기를 가지며 65,353 바이트만큼 클 수 있다. 그러나 각 패킷은 65507 바이트의 메시지의 크기를 제한하는 IP 헤더를 위해서는 최소 20 바이트로 사용하고 UDP 헤더는 최소 8 바이트로 사용한다. 메시지가 그것보다 큰 경우, 다수의 패킷이 전송될 필요가 있을 것이다.

UDP 패킷은 또한 멀티캐스트 할 수 있다. 이것은 패킷이 UDP 그룹에 속한 모든 노드로 전송되는 것을 의미한다. 명시적으로 각각의 노드를 대상없이 여러 노드에 정보를 전송하는 효율적인 방법이다. 대신에 패킷은 그 그룹의 패킷을 캡처할 책임이 있는 멤버의 그룹에 전송된다.

6장에서는 UDP 프로토콜을 사용할 수 있는 방법을 설명한다. 

-기존의 클라이언트/서버 모델 지원
-UDP 작업을 수행하는 NIO 채널을 사용
-그룹 멤버들에게 패킷을 멀티캐스트
-클라이언트에게 오디오 혹은 비디오 같은 스트림 미디어

UDP에 대한 자바 지원의 개요로 시작하고 더 많은 UDP 프로토콜 정보를 제공한다.

UDP에 대한 Java 지원

자바는 노드간에 소켓 연결을 형성하는 DatagramSocket 클래스를 사용한다. DatagramPacket 클래스는 데이터 패킷을 나타낸다. 단순한 send 및 receive 메소드는 네트워크를 통해 패킷을 전송할 것이다.

2016.05.19
UDP는 노드를 식별하는 데 IP 주소와 포트 번호를 사용한다. UDP 포트 번호는 0에서 65535까지다. 포트 번호는 세 종류로 분류된다.

-잘 알려진 포트(0 ~ 1023): 상대적으로 공통 서비스에 사용되는 포트 번호이다.
-등록된 포트(1024 ~ 49151): 프로세스를 위해 IANA에서 할당된 포트 번호이다.
-동적/사설 포트(49152 ~ 65535): 연결이 초기화될 때 동적으로 클라이언트에 할당된다. 일반적으로 일시적이며 IANA에 의해 할당할 수 없다.

Page 141.

다음 표는 UDP 특정 포트 할당의 간단한 목록이다. UDP가 강범위하게 많고 다양한 애플리케이션과 서비스를 지원하는 데 사용되는 방법을 예시한다. TCP/UDP 포트 번호의 보다 완전한 목록은 https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers에서 확인한다.

<표>

다음 표는 등록된 포트 및 그 사용 목록을 보여준다.

<표>

Page 142.

TCP 대 UDP

TCP와 UDP 간의 몇 가지 차이가 있다. 이러한 차이는 다음과 같다.

-신뢰성(Reliability): TCP는 UDP보다 더 신뢰할 수 있다.
-순서(Ordering): TCP는 패킷 전송의 순서가 유지되는 것을 보장한다.
-헤더 크기(Header size): UDP 헤더는 TCP 헤더보다 작다.
-속도(Speed): UDP는 TCP보다 빠르다.

패킷이 TCP를 이용하여 전송될 때, 패킷이 도착하는 것을 보장한다. 분실되면, 다시 전송된다. UDP는 이 보장을 제공하지 않는다. 패킷이 도착하지 않는 경우, 다시 전송되지 않는다.

TCP는 패킷의 전송 순서를 보장하지만, UDP는 보장하지 않는다. TCP 패킷들이 전송된 방법과 다른 순서로 목적지에 도달하는 경우, TCP는 원래 순서대로 패킷을 조립할 것이다. UDP의 경우, 이 순서는 유지되지 않는다.

패킷이 생성될 때, 헤더 정보는 패킷의 전달을 지원하기 위해 부착된다. TCP 헤더의 일반적인 크기는 32 바이트이다.

신뢰성을 확보하기 위한 작은 헤더 크기와 오버 헤드의 부족으로, UDP는 TCP보다 더 효율적이다. 또한, 작은 노력으로 연결을 생성할 필요가 있다. 이 효율성은 미디어를 스트리밍하기 위한 더 나은 선택을 만든다.

전통적인 클라이언트/서버 아키텍처를 지원하는 방법을 UDP 예제로 시작하자.

UDP 클라이언트/서버

UDP 클라이언트/서버 애플리케이션은 TCP 클라이언트/서버 애플리케이션에 사용되는 구조와 유사하다. 서버 측면에서, 생성된 UDP 서버 소켓은 클라이언트 요청을 기다린다. 클라이언트는 대응하는 UDP 소켓을 생성하고, 서버에 메시지를 전송하는 데 사용된다. 그러면 서버는 요청을 처리하고 응답을 전송할 수 있다.

UDP 클라이언트/서버는 메시지를 보유하는 DatagramPacket과 소켓을 위한 DatagramSocket 클래스를 사용한다. 메시지의 콘텐츠 타입은 제한이 없다. 예제에서는 텍스트 메시지를 사용할 것이다.

Page 143.

UDP 서버 애플리케이션

2016.05.20

서버는 다음에 정의된다. 생성자는 서버의 작업을 수행한다. 

<소스>

생성자의 try-with-resources 블록에서, DatagramSocket 클래스의 인스턴스를 생성한다. 사용되는 다수의 메소드는 필요한 경우 IOException 예외를 발생시킬 수 있다.

<소스>

다음과 같이, 소켓을 생성하는 또 다른 방법은 bind 메소드를 사용하는 것이다. DatagramSocket 인스턴스는 매개변수로 null을 사용하여 생성된다. 포트는 다음 bind 메소드로 할당된다.

<소스>

두 가지 방법은 포트 9003을 사용하여 DatagramSocket 인스턴스를 생성한다. 

메시지를 전송하는 과정은 다음과 같이 구성한다.

-바이트 배열 생성
-DatagramPacket 인스턴스 생성
-도착 메시지의 대기를 위한 DatagramSocket 인스턴스 사용

Page 144.

다음과 같이, 여러 요청을 처리할 수 있도록, 프로세스는 loop를 닫는다. 수신되는 메시지는 단순히 클라이언트 프로그램으로 에코 백(echoed back) 한다. DatagramPacket 인스턴스는 바이트 배열과 길이를 사용하여 생성된다. DatagramSocket 클래스의 receive 메소드의 인자로 사용된다. 패킷은 이 시간에 어떤 정보도 보유하지 않는다. 요청이 이루어질 때까지 이 메소드는 블록하며, 그 후 패킷은 채워진다.

<소스>

메소드가 반환될 때, 패킷은 스트링으로 변환된다. 다른 데이터 타입은 전송된 경우, 다른 변환이 필요하다. 전송된 메시지는 표시된다.

<소스>

응답을 보내기 위해, 클라이언트의 주소와 포트 번호가 필요하다. 이러한 정보를 보유하는 패킷에 대해 각각 getAddress와 getPort 메소드를 사용하여 얻어진다. 클라이언트를 논의할 때 이것은 표시된다. 또한 필요로하는 것은 getBytes 메소드가 제공하는 바이트의 배열로 표현되는 메시지이다.

<소스>

새로운 DatagramPacket 인스턴스는 메시지, 길이 및 클라이언트의 주소와 포트 번호를 사용하여 생성된다. send 메소드는 클라이언트에 패킷을 전송한다.

<소스>

정의된 서버로 클라이언트를 살펴 보자.

Page 145.

UDP 클라이언트 애플리케이션

클라이언트 애플리케이션은 전송하는 메시지를 사용자에게 표시하며, 그 후 서버에 메시지를 전송한다. 응답을 대기한 후 응답을 표시한다. 그것은 여기에 선언된다.

<소스>

Scanner 클래스는 사용자 입력을 받아 지원한다. try-with-resources 블록은 DatagramSocket 인스턴스를 생성하고 예외를 처리한다.

<소스>

클라이언트의 현재 주소는 getByName 메소드를 사용하여 접속하고, 바이트 배열에 대한 참조가 선언된다. 이 주소는 패킷을 생성하는 데 사용된다.

<소스>

무한 루프는 메시지를 사용자에게 메시지를 표시하는 데 사용된다. 사용자가 "quit"를 입력하면 다음과 같이, 애플리케이션은 종료된다.

<소스>

Page 146.

메시지를 보유한 DatagramPacket 인스턴스를 생성하려면 생성자는 메시지, 길이, 클라이언트의 주소와 포트 번호를 나타내는 바이트의 배열이 필요하다. 다음 코드에서 서버의 포트는 9003이다. send 메소드는 서버에 패킷을 전송할 것이다.

<소스>

응답을 수신할 때, 수신된 패킷을 생성하고 서버에서 처리된 것과 동일한 방법으로 receive 메소드에 사용된다. 서버가 응답할 때까지 이 메소드는 차단하고 다음 메시지가 표시된다.

<소스>

지금, 작업에서 이러한 애플리케이션을 볼 수 있다.

작동중인 UDP 클라이언트/서버

서버는 먼저 시작된다. 다음과 같은 메시지가 표시된다.

UDP Server Started

다음에, 클라이언트 애플리케이션을 시작한다. 다음과 같은 메시지가 표시된다.

UDP Client Started

Enter a message:

다음과 같이, 메시지를 입력한다.

Enter a message: Top of the morning to you

Page 147.

다음과 같이 서버는 메시지를 수신한 것을 표시한다. 출력의 다수 빈 라인을 볼 수 있다. 이것은 메시지를 보유하여 사용하는 1024 바이트 배열의 내용이다. 메시지는 다시 클라이언트에 에코백된다.(echoed back)

Page 150.

그러나 get 메소드는 버퍼의 현재 위치를 수정한다. 다시 클라이언트에게 메시지를 전송하기 전에 원래 상태로 위치를 복원해야 한다. 버퍼의 mark와 reset 메소드는 이러한 목적을 위해 사용된다.

이 모든 것은 다음 코드 시퀀스로 수행된다. mark 메소드는 현재 위치에서 마크(mark)를 설정한다. StringBuilder 인스턴스는 클라이언트에서 전송된 스트링을 되살리는 데 사용된다. 버퍼의 hasRemaining 메소드는 while 루프를 제어한다. 메시지는 표시되고 reset 메소드는 이전에 마크된 값의 위치를 복원한다.

<소스>

마지막 단계는 다시 클라이언트에게 바이트 버퍼를 전송하는 것이다. send 메소드는 이 작업을 수행한다. clear 메소드에 따라서 전송된 메시지를 가리키는 메시지는 보여준다.(수정필요) 버퍼를 통하기 때문에 이 메소드는 사용된다. 그것은 위치를 0으로 설정하고 버퍼 용량의 limit를 설정하고, 마크를 삭제한다.

<소스>

다음과 같이, 서버가 시작되면 이 효과에 메시지가 표시된다. 

UDP Echo Server Started

이제 클라이언트가 구현되는 방식을 확인할 준비가 된 것이다.

UDP 에코 클라이언트 애플리케이션

UDP 에코 클라이언트의 구현은 간단하고 다음 단계를 사용한다. 

-에코 서버에 대한 연결이 설정된다.
-바이트 버퍼는 메시지를 저장하기 위해 생성된다.
-버퍼는 서버로 전송된다.
-메시지는 재전송될 때까지 클라이언트는 블록한다.

Page 151.

클라이언트의 구현 세부 사항은 서버의 유사하다. 다음과 같이 애플리케이션의 선언으로 시작한다.

<소스>

서버에서는 단일 인자 InetSocketAddress 생성자는 현재의 IP 주소와 포트 9000을 연결한다. 클라이언트 내에서는 포트와 함께 서버의 IP 주소를 지정해야한다. 그렇지 않으면 여기서 메시지를 전송하는 것을 결정할 수 없다. 클래스의 2개 인자 생성자를 사용하여 다음과 같은 구문을 수행할 수 있다. 클라이언트와 서버가 동일한 머신에 있다고 가정하면, 주소 127.0.0.1를 사용한다.

<소스>

채널은 open 메소드로 생성되고 connect 메소드로 소켓 주소로 연결된다. 

<소스>

다음 코드 시퀀스에서, 메시지 스트링은 생성되고, 바이트 버퍼가 할당된다. 버퍼의 크기는 스트링의 길이로 설정된다. put 메소드는 이 후 버퍼에 메시지를 할당한다. put 메소드는 바이트의 배열을 기대하고, 메시지 내용에 해당하는 바이트 배열을 얻기 위해 String 클래스의 getBytes 메소드를 사용한다.

<소스>

Page 152.

서버로 버퍼를 전송하기 전에 flip 메소드가 호출된다. 그것은 현재의 위치에 limit을 설정하고 0으로 위치를 설정한다. 따라서, 서버에 의해 수신된 경우에 처리될 수 있다.

<소스>

다음과 같이, 서버에게 메시지를 전송하기 위해, 채널의 write 메소드는 호출된다. 서버에 직접적으로 기본 패킷을 전송할 것이다. 채널의 소켓이 초기에 달성된 접속되는 경우, 이 메소드는 단지 작동한다.

<소스>

다음으로, 버퍼는 버퍼를 재사용 할 수 있도록 지워진다. read 메소드는 버퍼를 수신하고, 버퍼는 서버에서 사용된 동일한 프로세스를 사용하여 표시한다.

<소스>

이제 서버와 함께 클라이언트를 사용하여 준비한다.

작동중인 UDP 에코 클라이언트/서버

서버는 먼저 시작해야한다. 다음과 같이 초기 서버 메시지가 표시된다.

UDP Echo Server Started

다음으로, 클라이언트를 시작한다. 다음 출력은 반환된 메시지를 표시한 후 메시지를 전송하는 클라이언트를 보여주는 것이 표시된다.

UDP Echo Client Started
Sent: [The message]
Received: [The message]
UDP Echo Client Terminated

Page 153.

서버 측면에서, 메시지가 수신된 후 다시 클라이언트로 재 전송되는 것을 볼 수 있다.

Received: [The message]
Sent: [The message]

DatagramChannel 클래스를 사용하는 것은 빠른 UDP 통신을 할 수 있게 한다.

UDP 멀티캐스팅

멀티캐스팅은 동일한 시간에 다수의 클라이언트에게 메시지를 전송하는 프로세스이다. 각 클라이언트는 같은 메시지를 받을 수 있다. 이 프로세스에 참여하기 위해, 클라이언트는 멀티 캐스트 그룹에 가입할 필요가 있다.

2016.05.24

Page 154.

메시지를 전송하기 위해, 메시지 및 패킷을 보유하는 바이트 배열을 필요로한다. 다음과 같이 선언되었다.

<소스>

서버 애플리케이션은 초마다 새로운 날짜 및 시간을 브로드캐스트하는 무한 루프를 사용한다. 스레드는 1초 동안 일시정지 한 다음 새 날짜와 시간은 Data 클래스를 사용하여 생성된다. DatagramPacket 인스턴스는 이 정보를 사용하여 생성된다. 포트 9877은 서버에 할당되고, 클라이언트에 의해 알려질 필요가 있다. send 메소드는 관련 클라이언트에 패킷을 송신한다.

<소스>

클라이언트 애플리케이션은 다음에 설명된다.

UDP 멀티캐스트 클라이언트

주소 228.5.6.7로 정의된 애플리케이션은 멀티캐스트 그룹에 참여한다. 메시지가 수신될 때까지 블록하고 다음 메시지는 표시된다. 다음과 같이 애플리케이션은 정의된다.

<소스>

Page 155.

<소스>

MulticastSocket 클래스의 인스턴스는 포트 번호 9877를 사용하여 생성된다. 이것은 UDP 멀티캐스트 서버에 연결하기 위해 필요하다. InetAddress 인스턴스는 228.5.6.7의 멀티캐스트 주소를 사용하여 생성된다. 클라이언트는 joinGroup 메소드를 사용하여 멀티캐스트 그룹에 참여한다.

<소스>

DatagramPacket 인스턴스는 클라이언트로 전송된 메시지를 수신 할 필요가 있다. 다음과 같이, 바이트 배열을 생성하고, 이 패킷을 인스턴스화하는 데 사용된다.

<소스>

서버가 메시지를 전송할 때까지 receive 메소드로 블록할 때까지 클라이언트 애플리케이션은 그 후 무한 루프로 들어간다. 메시지가 도착되면, 메시지는 표시된다.

<소스>

다음으로, 클라이언트와 서버의 상호작용 방법의 예를 살펴보자.

Page 156.

작동중인 UDP 멀티캐스트 클라이언트/서버

서버를 시작한다. 서버의 출력은 다음 중 하나와 유사 할 것이지만, 날짜와 시간은 다를 것이다.

<결과>

다음으로, 클라이언트 애플리케이션을 시작한다. 그것은 다음과 같은 메시지를 수신하기 시작한다.

<결과>

<<박스시작>>
프로그램이 Mac에서 실행되는 경우는 소켓 예외가 발생할 수 있다. 이러한 경우 -Djava.net.preferIPv4Stack=true JVM 옵션을 사용한다.
<<박스 끝>>

후속 클라이언트를 시작하는 경우, 각 클라이언트는 같은 종류의 서버 메시지를 수신한다.

채널과 UDP 멀티캐스팅

또한 채널과 멀티캐스트 할 수 있다. 이 과정을 보여주기 위해 IPv6를 사용한다. 프로세스는 멀티캐스트 그룹을 사용해야 하는 것을 제외하고는 DatagramChannel 클래스의 이전 사용과 유사하다. 이를 위해, 네트워크 인터페이스를 사용할 수 있는 것을 알아야한다. 멀티캐스트 채널을 사용의 특성에 들어가기 전에, 머신에 대한 네트워크 인터페이스의 목록을 확보하는 방법을 보여준다.

Page 157.

NetworkInterface 클래스는 네트워크 인터페이스를 나타낸다. 이 클래스는 2장 '네트워크 주소'에서 살펴봤다. 다음은 6장에서 설명된 접근 방식의 변형이다. 특정 인터페이스가 멀티캐스트를 지원하는지 여부를 다음과 같이 표시하도록 보강된다.

<소스>

displayNetworkInterfaceInformation 메소드는 다음에 보여준다. 이 방법은 https://docs.oracle.com/javase/tutorial/networking/nifs/listing.html에서 순응시킨다.

<소스>

Page 158.

이 예제를 실행하면 다음과 유사한 출력을 얻을 것이다.

<결과>

클라이언트/서버의 경우, eth0 인터페이스를 사용한다. 당신의 플랫폼에 가장 적합한 하나를 선택해야한다. 예를 들어, Mac에서는 en0 혹은 awdl0 일 수도 있다.

Page 159.

UDP 데이터 채널 멀티캐스트 서버

UDP 데이터 채널 멀티캐스트 서버는 아래와 같다.

-채널 및 멀티캐스트 그룹 설정
-메시지를 포함하는 버퍼 생성
-전송하는 무한 루프를 사용하여 그룹 메시지를 표시

서버의 정의는 다음과 같다.

<소스>

첫 번째 작업은 IPv6를 사용하도록 지정하는 System 클래스의 setProperty 메소드를 사용한다. DatagramChannel 인스턴스는 생성되고 eth0 네트워크 인터페이스는 생성된다.
