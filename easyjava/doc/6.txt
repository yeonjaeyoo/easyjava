6장.UDP와 멀티캐스팅

UDP(User Datagram Protocol)는 IP의 위쪽에 위치하고 TCP에 비교하여 신뢰할 수 없다. UDP는 네트워크에서 두 노드 간의 개별적인 패킷을 전송한다. UDP 패킷은 다른 패킷에 대한 지식을 가지고 있지 않으며, 실제로 패킷이 의도한 목적지에 도착한다는 보장은 하지 않는다. 다수의 패킷이 전송되는 경우, 도착 순위의 보증은 없다. 수신인에서 보낸 인식이 없는 것처럼 UDP 메시지는 단순히 전송한 후 잊어버린다.

UDP는 비연결 프로토콜이다. 패킷 전송을 용이하게 하는 두 노드들 간의 메시지 교환은 없다. 접속에 대한 어떠한 상태 정보도 유지되지 않는다. 

UDP는 전달은 효율적으로 필요한 곳의 서비스에 적합하고, 전달의 보장이 필요하지는 않다. 예를 들어, DNS(Domain Name System)의 서비스, NTP(Network Time Protocol) 서비스, VOIP(Voice Over IP), P2P 네트워크에서 네트워크 통신의 조정과 비디오 스트리밍을 위해 사용된다. 비디오 프레임이 손실되는 경우, 손실이 자주 발생하지 않는다면, 뷰어(viewer)는 알 수 없다.

다음을 포함한 UDP를 사용하는 여러 프로토콜이 있다.

2016.05.18

-RTSP(Real Time Streaming Protocol): 이 프로토콜은 미디어 스트리밍을 제어하기 위해 사용된다.
-RIP(Routing Information Protocol): 이 프로토콜은 패킷을 전송하는 데 사용되는 경로를 결정한다.
-DNS(Domain Name System): 이 프로토콜은 인터넷 도메인 이름을 검색하고 그 IP 주소를 반환한다.
-NTP(Network Time Protocol): 이 프로토콜은 인터넷을 통해 시각을 동기화한다.

Page 140.

UDP 패킷은 목적지를 식별할 수 있는 IP 주소와 포트 번호로 구성된다. UDP 패킷은 고정된 크기를 가지며 65,353 바이트만큼 클 수 있다. 그러나 각 패킷은 65507 바이트의 메시지의 크기를 제한하는 IP 헤더를 위해서는 최소 20 바이트로 사용하고 UDP 헤더는 최소 8 바이트로 사용한다. 메시지가 그것보다 큰 경우, 다수의 패킷이 전송될 필요가 있을 것이다.

UDP 패킷은 또한 멀티캐스트 할 수 있다. 이것은 패킷이 UDP 그룹에 속한 모든 노드로 전송되는 것을 의미한다. 명시적으로 각각의 노드를 대상없이 여러 노드에 정보를 전송하는 효율적인 방법이다. 대신에 패킷은 그 그룹의 패킷을 캡처할 책임이 있는 멤버의 그룹에 전송된다.

6장에서는 UDP 프로토콜을 사용할 수 있는 방법을 설명한다. 

-기존의 클라이언트/서버 모델 지원
-UDP 작업을 수행하는 NIO 채널을 사용
-그룹 멤버들에게 패킷을 멀티캐스트
-클라이언트에게 오디오 혹은 비디오 같은 스트림 미디어

UDP에 대한 자바 지원의 개요로 시작하고 더 많은 UDP 프로토콜 정보를 제공한다.

UDP에 대한 Java 지원

자바는 노드간에 소켓 연결을 형성하는 DatagramSocket 클래스를 사용한다. DatagramPacket 클래스는 데이터 패킷을 나타낸다. 단순한 send 및 receive 메소드는 네트워크를 통해 패킷을 전송할 것이다.

2016.05.19
UDP는 노드를 식별하는 데 IP 주소와 포트 번호를 사용한다. UDP 포트 번호는 0에서 65535까지다. 포트 번호는 세 종류로 분류된다.

-잘 알려진 포트(0 ~ 1023): 상대적으로 공통 서비스에 사용되는 포트 번호이다.
-등록된 포트(1024 ~ 49151): 프로세스를 위해 IANA에서 할당된 포트 번호이다.
-동적/사설 포트(49152 ~ 65535): 연결이 초기화될 때 동적으로 클라이언트에 할당된다. 일반적으로 일시적이며 IANA에 의해 할당할 수 없다.

Page 141.

다음 표는 UDP 특정 포트 할당의 간단한 목록이다. UDP가 강범위하게 많고 다양한 애플리케이션과 서비스를 지원하는 데 사용되는 방법을 예시한다. TCP/UDP 포트 번호의 보다 완전한 목록은 https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers에서 확인한다.

<표>

다음 표는 등록된 포트 및 그 사용 목록을 보여준다.

<표>

Page 142.

TCP 대 UDP

TCP와 UDP 간의 몇 가지 차이가 있다. 이러한 차이는 다음과 같다.

-신뢰성(Reliability): TCP는 UDP보다 더 신뢰할 수 있다.
-순서(Ordering): TCP는 패킷 전송의 순서가 유지되는 것을 보장한다.
-헤더 크기(Header size): UDP 헤더는 TCP 헤더보다 작다.
-속도(Speed): UDP는 TCP보다 빠르다.

패킷이 TCP를 이용하여 전송될 때, 패킷이 도착하는 것을 보장한다. 분실되면, 다시 전송된다. UDP는 이 보장을 제공하지 않는다. 패킷이 도착하지 않는 경우, 다시 전송되지 않는다.

TCP는 패킷의 전송 순서를 보장하지만, UDP는 보장하지 않는다. TCP 패킷들이 전송된 방법과 다른 순서로 목적지에 도달하는 경우, TCP는 원래 순서대로 패킷을 조립할 것이다. UDP의 경우, 이 순서는 유지되지 않는다.

패킷이 생성될 때, 헤더 정보는 패킷의 전달을 지원하기 위해 부착된다. TCP 헤더의 일반적인 크기는 32 바이트이다.

신뢰성을 확보하기 위한 작은 헤더 크기와 오버 헤드의 부족으로, UDP는 TCP보다 더 효율적이다. 또한, 작은 노력으로 연결을 생성할 필요가 있다. 이 효율성은 미디어를 스트리밍하기 위한 더 나은 선택을 만든다.

전통적인 클라이언트/서버 아키텍처를 지원하는 방법을 UDP 예제로 시작하자.

UDP 클라이언트/서버

UDP 클라이언트/서버 애플리케이션은 TCP 클라이언트/서버 애플리케이션에 사용되는 구조와 유사하다. 서버 측면에서, 생성된 UDP 서버 소켓은 클라이언트 요청을 기다린다. 클라이언트는 대응하는 UDP 소켓을 생성하고, 서버에 메시지를 전송하는 데 사용된다. 그러면 서버는 요청을 처리하고 응답을 전송할 수 있다.

UDP 클라이언트/서버는 메시지를 보유하는 DatagramPacket과 소켓을 위한 DatagramSocket 클래스를 사용한다. 메시지의 콘텐츠 타입은 제한이 없다. 예제에서는 텍스트 메시지를 사용할 것이다.

Page 143.

UDP 서버 애플리케이션

2016.05.20

서버는 다음에 정의된다. 생성자는 서버의 작업을 수행한다. 

<소스>

생성자의 try-with-resources 블록에서, DatagramSocket 클래스의 인스턴스를 생성한다. 사용되는 다수의 메소드는 필요한 경우 IOException 예외를 발생시킬 수 있다.

<소스>

다음과 같이, 소켓을 생성하는 또 다른 방법은 bind 메소드를 사용하는 것이다. DatagramSocket 인스턴스는 매개변수로 null을 사용하여 생성된다. 포트는 다음 bind 메소드로 할당된다.

<소스>

두 가지 방법은 포트 9003을 사용하여 DatagramSocket 인스턴스를 생성한다. 

메시지를 전송하는 과정은 다음과 같이 구성한다.

-바이트 배열 생성
-DatagramPacket 인스턴스 생성
-도착 메시지의 대기를 위한 DatagramSocket 인스턴스 사용

Page 144.

다음과 같이, 여러 요청을 처리할 수 있도록, 프로세스는 loop를 닫는다. 수신되는 메시지는 단순히 클라이언트 프로그램으로 에코 백(echoed back) 한다. DatagramPacket 인스턴스는 바이트 배열과 길이를 사용하여 생성된다. DatagramSocket 클래스의 receive 메소드의 인자로 사용된다. 패킷은 이 시간에 어떤 정보도 보유하지 않는다. 요청이 이루어질 때까지 이 메소드는 블록하며, 그 후 패킷은 채워진다.

<소스>

메소드가 반환될 때, 패킷은 스트링으로 변환된다. 다른 데이터 타입은 전송된 경우, 다른 변환이 필요하다. 전송된 메시지는 표시된다.

<소스>

응답을 보내기 위해, 클라이언트의 주소와 포트 번호가 필요하다. 이러한 정보를 보유하는 패킷에 대해 각각 getAddress와 getPort 메소드를 사용하여 얻어진다. 클라이언트를 논의할 때 이것은 표시된다. 또한 필요로하는 것은 getBytes 메소드가 제공하는 바이트의 배열로 표현되는 메시지이다.

<소스>

새로운 DatagramPacket 인스턴스는 메시지, 길이 및 클라이언트의 주소와 포트 번호를 사용하여 생성된다. send 메소드는 클라이언트에 패킷을 전송한다.

<소스>

정의된 서버로 클라이언트를 살펴 보자.

Page 145.

UDP 클라이언트 애플리케이션

클라이언트 애플리케이션은 전송하는 메시지를 사용자에게 표시하며, 그 후 서버에 메시지를 전송한다. 응답을 대기한 후 응답을 표시한다. 그것은 여기에 선언된다.

<소스>

Scanner 클래스는 사용자 입력을 받아 지원한다. try-with-resources 블록은 DatagramSocket 인스턴스를 생성하고 예외를 처리한다.

<소스>

클라이언트의 현재 주소는 getByName 메소드를 사용하여 접속하고, 바이트 배열에 대한 참조가 선언된다. 이 주소는 패킷을 생성하는 데 사용된다.

<소스>

무한 루프는 메시지를 사용자에게 메시지를 표시하는 데 사용된다. 사용자가 "quit"를 입력하면 다음과 같이, 애플리케이션은 종료된다.

<소스>

Page 146.

메시지를 보유한 DatagramPacket 인스턴스를 생성하려면 생성자는 메시지, 길이, 클라이언트의 주소와 포트 번호를 나타내는 바이트의 배열이 필요하다. 다음 코드에서 서버의 포트는 9003이다. send 메소드는 서버에 패킷을 전송할 것이다.

<소스>

응답을 수신할 때, 수신된 패킷을 생성하고 서버에서 처리된 것과 동일한 방법으로 receive 메소드에 사용된다. 서버가 응답할 때까지 이 메소드는 차단하고 다음 메시지가 표시된다.

<소스>

지금, 작업에서 이러한 애플리케이션을 볼 수 있다.

작동중인 UDP 클라이언트/서버

서버는 먼저 시작된다. 다음과 같은 메시지가 표시된다.

UDP Server Started

다음에, 클라이언트 애플리케이션을 시작한다. 다음과 같은 메시지가 표시된다.

UDP Client Started

Enter a message:

다음과 같이, 메시지를 입력한다.

Enter a message: Top of the morning to you

Page 147.

다음과 같이 서버는 메시지를 수신한 것을 표시한다. 출력의 다수 빈 라인을 볼 수 있다. 이것은 메시지를 보유하여 사용하는 1024 바이트 배열의 내용이다. 메시지는 다시 클라이언트에 에코백된다.(echoed back)

