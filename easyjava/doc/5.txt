5. P2P 네트워크

P2P(peer-to-peer) 컴퓨터 네트워크는 자주 서버와 클라이언트 모두의 기능하는 노드의 아키텍처를 지칭한다. P2P 시스템의 주요 목적은 시스템을 관리하는 별도의 서버에 대한 독립성을 제거하는 것이다. P2P 네트워크 구성은 예측하지 못하는 상황에서 네트워크를 참여하고 떠나는 노드로 동적으로 변화한다. 노드는 처리 속도, 대역폭 지원 및 저장 용량과 같은 요인의 측면에서 달라질 수 있다. 피어라는 용어(peer)는 노드 간의 평등의 수준을 의미한다.

다양한 정의와 P2P 네트워크의 해석이 있다. 분산되고, 끊임없이 변화, 자기 조절 아키텍처를 특징으로 할 수 있다. 클라이언트가 요청을 하면 서버가 서비스를 제공하는 경향이 있다. P2P 노드는 일반적으로 그렇게한다. 순수 P2P 네트워크는 클라이언트 혹은 서버로 지정된 노드를 보유하지 않는다. 실제로, 이러한 네트워크는 드물다. 대부분 P2P 네트워크는 지원을 위해, DNS 서버와 같은 중앙 설비에 의존한다.

특정 네트워크는 클라이언트/서버 아키텍처와 "마스터"서버로 작동하는 특정 노드가 결코 아닌 더 순수 P2P 아키텍처 간에서 하이브리드(hybrid) 될 수 있다. 예를 들어, 파일 공유 P2P는 서버에서 추가 지원 정보를 제공할 수 있지만, 파일을 다운로드하기 위하여 네트워크의 노드를 이용할 수 있다. 

P2P는 여러 가지 방법으로 분류될 수 있다. P2P 네트워크의 본질을 이해하는 데 유용한 일반적인 분류 범주의 몇 가지를 사용한다. 하나의 분류는 인덱싱 방법, 노드를 찾는 과정이 수행되는 데 기초한다.

2016.05.11

-중앙집중식: 중앙 서버는 데이터가 피어들 사이의 위치를 추적 할 때이다.
-로컬: 각 피어가 자신의 데이터를 추적 할 때이다.
-분산: 데이터 참조가 여러 피어에 의해 유지되는 때이다.

Page 120.

하이브리드 P2P 네트워크는 중앙 인덱싱 스키마를 사용한다. 순수 P2P 네트워크는 로컬 혹은 분산 인덱스를 사용한다. 

알고리즘은 시스템에서 정보의 위치를 결정하기 위해 사용된다. 시스템은 알고리즘을 실행하는 서버를 오버라이드하지 않고 분산되어 있다. 이 알고리즘은 노드 추가 및 제거할 때 동적으로 스스로를 구성하는 자기 조직화 시스템을 지원한다. 게다가, 이러한 시스템은 이상적으로 네트워크 구성원 변경으로 인한 부하 및 자원을 균형을 맞출 것이다.

4장에서 학습할 내용은 다음과 같다.

-P2P 개념 및 용어
-P2P 네트워크에 대한 Java 지원
-분산 해시 테이블의 특성
-FreePastry가 P2P 애플리케이션을 지원하는 방법

<박스 시작>
P2P 애플리케이션은 기존의 클라이언트/서버 아키텍처에서 유연한 대안을 제공한다.
<박스 끝>

P2P 기능/특성

P2P 네트워크를 이해하는 하나의 방법은 그 특성을 조사하는 것이다. 

-Nodes that contribute resources to the system, including.   
-데이터 스토리지
-전산 자원

-일련의 서비스에 대한 지원을 제공한다.
-매우 품질에 기복이 없고 및 폴트 톨러런트(fault tolerant)가 있다.
-리소스의 로드 밸런싱(load balancing)을 지원한다.
-제한된 익명을 지원할 수 있다.

P2P 시스템의 특성은 사용자가 서비스 혹은 자원을 사용하는 특정 노드에 접속할 수 없을 수도 있다는 것이다. 노드가 가입하고 무작위로 시스템을 떠날 때, 특정 노드는 사용할 수 없다. 알고리즘은 시스템이 요청에 응답하는 방법을 결정한다.

Page 121.

P2P 시스템의 기본 기능은 다음과 같다. 

-네트워크의 피어 등록
-피어 발견-피어를 결정하는 과정은 관심의 정보를 갖는다.
-피어 간의 메시지 전송

모든 피어는 이러한 모든 기능을 수행하지 않는다.

P2P 시스템의 리소스는 일반적으로 DHT 컴포넌트에서 검사하는 보안 해시 함수를 사용하여 생성되는 GUID(Globally Unique Identifier)를 사용하여 식별된다. GUID는 사람이 읽을 수 없다. 충돌을 위한 작은 기회를 제공하여 임의로 생성된 값이다.

2016.05.12

P2P의 노드는 라우팅 오버레이(routing overlay)를 사용하여 구성된다. 해당 노드에 요청된 경로를 정하는 미들웨어의 타입이다. 오버레이는 IP 주소를 사용하여 리소스로 식별된 물리적 네트워크의 상부에있는 네트워크를 의미한다. IP 기반 노드들의 시리즈로 구성된 네트워크를 상상할 수 있다. 그러나 오버레이는 일반적으로 단일 작업에 중점이 되는 노드의 하위 서브셋이다.

라우팅 오버레이는 요청을 수행해야하는 노드를 결정하기 위해, 사용자 및 자원, 연결의 대역폭 간의 노드의 수를 같은 요인을 고려한다. 자주, 리소스는 중복될 수 있거나 혹은 심지어 여러 노드로 분할된다. 라우팅 오버레이는 리소스에 대한 최적의 경로를 제공하려고 한다.

노드가 참여하고 시스템을 떠날 때, 라우팅 오버레이는 이러한 변화를 설명할 필요가 있다. 노드가 시스템에 참여하면, 일부 책임을 수행하도록 요청받을 수 있다. 노드가 떠날 때, 시스템의 다른 부분은 노드 책임의 일부를 가져와야 할 수 있다.

5장에서는 종종 시스템의 일부로서 포함되는 다양한 개념을 설명한다. 잠시 이 아키텍처에 대한 자바 지원에 대한 논의에 따른 다른 P2P 애플리케이션 개요일 것이다. 분산 해시 테이블의 사용은 입증되고, FreePastry의 심도있는 검사는 많은 P2P 프레임워크 작업의 방법에 통찰력을 제공한다.

해당하는 경우, 이러한 개념의 몇 가지를 수동으로 구현할 수 있는 방법을 설명할 것이다. 이러한 구현은 시스템을 사용할 필요가 없지만, 이러한 기본 개념에서 보다 깊은 이해를 제공할 것이다.

Page 122.

애플리케이션 기반 P2P 네트워크

P2P 네트워크를 기반으로 하는 많은 애플리케이션이 있다. 다음에서 사용할 수 있다.

-콘텐츠 분배: 파일 공유이다.(파일, 음악, 비디오, 이미지)
-분산 컴퓨팅: 문제는 작은 작업으로 분할하고, 병렬 방식으로 실행될 때다.
-병합: 사용자가 공통적인 문제를 해결하기 위해 함께 작동 할 때다.
-플랫폼: JXTA 및 Pastry 같은 P2P 애플리케이션이 구축되는 시스템이다.

분산 컴퓨팅은 작업을 수행하기 위해 다수의 작은 컴퓨터의 능력을 활용한다. 이 방법의 의무적인 문제는 작은 단위로 세분화하고 여러 머신에서 동시에 실행해야 한다. 이러한 작은 작업의 결과는 최종 결과를 생성하기 위해 결합될 필요가있다. 

P2P 네트워크는 다음과 같은 다수의 애플리케이션을 지원한다.

-Skype: 화상 회의 애플리케이션이다.
-Freecast: P2P 스트리밍 오디오 프로그램이다.
-BitTorrent: 인기있는 P2P 파일 공유 시스템이다.
-Tor: 이 프로그램은 사용자의 신원을 보호한다.
-Haihaisoft: 사전 레코드된 TV 프로그램의 배포에 사용된다.
-WoW: 게임 업데이트를 위한 P2P를 사용한다.
-YaCy: 검색 엔진(search engine)과 웹 크롤러(web crawler)이다.
-Octoshape: 라이브 TV를 지원한다.

P2P 애플리케이션의 좋은 개요는 http://p2peducation.pbworks.com/w/page/8897427/FrontPage에서 확인한다.

Page 123.

로우 레벨 소켓 지원 이외의 Java 지원은 다양한 프레임 워크로 구성된 이전 장에서 상세히 나와있다. JXTA, 작은 제한-기능 프로토콜 같은 잘 알려진 프레임워크에 이르기까지 다양하다. 이 프레임워크는 보다 전문화된  애플리케이션을 위한 기초를 제공한다.

다음 표는 이러한 프레임워크의 몇 가지를 나열한다.

<표>

이 프레임워크는 피어 간에 메시지를 라우팅하는 알고리즘을 사용한다. 다음의 논의와 같이 해시 테이블은 자주 이러한 프레임 워크의 기초를 형성한다.

분산 해시 테이블

DHT(Distributed Hash Table)는 네트워크에서 리소스의 위치를 지정하는 한 쌍의 키/값을 사용한다. 이 맵핑 기능은 분산되는 피어를 통해 확산된다. 이 아키텍처는 P2P 네트워크가 다수의 노드로 용이하게 확장 및 랜덤 네트워크를 참여하고 떠나 피어를 처리할 수 있다. DHT는 코어 P2P 서비스를 지원하기위한 기초이다. 많은 애플리케이션은 비트토런트(BitTorrent), 프리넷 (Freenet) 및 YaCy를 포함한 DHT를 사용한다.

다음 그림은 값에 키를 매핑을 보여준다. 키는 책 이름같은 빈번하게 리소스의 식별 정보를 포함하는 스트링이다. 그리고 값은 리소스를 나타내는 생성된 수이다. 수는 네트워크에서의 리소스의 위치를 찾을 수 있고, 노드의 식별자에 응답할 수 있다.

<그림>

Page 124.

P2P 네트워크는 잠시 동안 사용됐다. 이러한 네트워크의 진화는 냅스터(Napster), 그누텔라(Gnutella)와 프리넷(Freenet)에 의해서 대표되는 것으로 리소스를 매핑하는 방법에 반영된다.

-냅스터(https://en.wikipedia.org/wiki/Napster)는 스케일이 큰 P2P 콘텐츠 전달 시스템이다. 네트워크의 노드를 추적하는 서버를 사용한다. 노드는 실제 데이터를 보존한다. 클라이언트가 이 데이터를 필요로하는 경우, 서버는 데이터를 보유하고 노드들의 현재의 세트를 검색하고, 이 노드의 위치를 클라이언트에게 전송한다. 클라이언트는 데이터를 유지하는 노드에 접속된다. 이것은 공격을 쉽게 한다. 그것에 대항하여 출시되기 위해 결국 소송을 통해 소멸을 이끈다.

2016.05.13

-그누텔라(https://web.archive.org/web/20080525005017, http://www.gnutella.com/)는 네트워크의 모든 노드에 브로드 캐스트하지만, 중앙 서버에서 사용하지 않는다. 메시지와 함께 침수되는 네트워크에서 이 결과 및 접근 방식은 이후 버전에서 수정됐다.
-프리넷(https://freenetproject.org/)은 휴리스틱(heuristic) 키 기반 라우팅 스키마를 사용하고 검열과 익명성 문제를 살펴본다. 그러나 DHS는 다음의 결과로 더 구조화된 키 기반 라우팅 방식을 사용한다.

-분산
-폴트 토레란스
-확장성
-효율성(Efficiency)

그러나 DHT는 정확한 일치 검색을 지원하지 않는다. 이러한 유형의 검색이 필요하면, 그것은 추가되어야 한다.

DHT 컴포넌트

키스페이스(keyspace)는 요소를 식별하는 데 사용되는 160비트 스트링(키)의 집합이다. 키스페이스 분할(Keyspace partitioning)은 네트워크의 노드들 간에 키스페이스를 분할하는 처리이다. 오버레이 네트워크는 노드를 연결한다.

일반적으로 사용되는 해싱 알고리즘은 보안 해시 알고리즘(Secure Hash Algorithm)(SHA-1)이다.(https://en.wikipedia.org/wiki/SHA-1) SHA-1은 NSA에 의해 설계되고 메시지 다이제스트라고 알려진 160비트의 해시 값을 생성한다. 대부분 P2P는 명시적으로 해싱 기능을 수행하기 위해 개발자를 요청하지 않는다. 그러나, 수행하는 방법을 보는 것은 교육적이다. 다음은 다이제스트를 생성하는 자바를 사용한 예이다.

Page 125.

MessageDigest 클래스의 getInstance 메소드는 특정 스트링을 사용하는 알고리즘을 수락하고 MessageDigest 인스턴스를 반환한다. update 메소드는 해시에 키를 포함하는 바이트의 배열을 필요로 한다. 이 예제에서는 스트링이 사용된다. digest 메소드는 해쉬 값을 유지하는 바이트 배열을 반환한다. 바이트 배열은 16 진수로 표시된다.

<소스>

이 시퀀스를 실행하면 다음과 같은 결과를 보여준다.

Hex format : 434d902b6098ac050e4ed79b83ad93155b161d72

파일 같은 데이터를 저장하려면, 키를 생성하는 파일 이름을 사용할 수 있다. 풋(put) 타입 함수는 데이터를 저장하기 위해 사용된다.

put(key, data) 

키에 대응하는 데이터를 검색하기위해, get 타입 함수가 사용된다.

data = get(key)

오버레이의 모든 노드는 키에 의해 표시되는 데이터를 포함하거나, 노드에 가까운 데이터를 포함하는 노드이다. 라우팅 알고리즘은 데이터를 포함한 노드 중에서 도중에 방문할 다음 노드를 결정한다.

Page 126.

DHT 구현

다음 표에 나와있는 목록을 보면, DHT의 여러 가지 자바 구현이있다.

<표>

DHT의 사용을 설명하기 위해 자바 분산 해시 테이블(Java Distributed Hash Table)(JDHT)를 사용한다.

JDHT 사용

JDHT를 사용하려면 다음 표에 나와있는 JAR 파일이 필요하다. dks.jar 파일은 사용되는 메인 jar 파일이다. 그러나 다른 두 개의 JAR 파일은 JDHT에 의해 사용된다. 다음과 같이 dks.jar 파일의 대체 소스는 나열된다.

<표>

다음의 예제는 하나의 웹 사이트에서 적용된다. 첫째, JDHT 인스턴스를 생성한다. JDHT는 기본적으로 포트 4440을 사용한다. 이 인스턴스로, 테이블에 한 쌍의 키/값을 추가하는 put 메소드을 사용할 수 있다.

<소스>

Page 127.

이 인스턴스에 연결하는 클라이언트를 위해서, 이 노드에 대한 참조를 얻을 수 있다. 다음과 같이 달성된다.

System.out.println(((JDHT) DHTExample).getReference());

사용자는 종료될 때까지 다음 코드는 프로그램 실행을 유지한다. 그 후 close 메소드는 테이블을 닫기위해 사용된다.

Scanner scanner = new Scanner(System.in);
System.out.println("Press Enter to terminate application: ");
scanner.next();
DHTExample.close();

프로그램을 실행하면 다음과 유사한 출력을 얻을 것이다.

dksref://192.168.1.9:4440/0/2179157225/0/1952355557247862269

Press Enter to terminate application:

다음과 같은 클라이언트 애플리케이션을 설명한다. 새로운 JDHT 인스턴스는 다른 포트를 사용하여 생성된다. 두 번째 인자는 첫 번째 애플리케이션에 대한 참조다. 참조를 복사하고 클라이언트에게 붙여넣기 해야한다. 다른 참조는 첫번째 애플리케이션이 실행될 때마다 생성될 것이다.

<소스>

다음으로, 키와 관련된 값을 검색하기 위해 get 메소드를 사용한다. 값은 다음에 표시되고 애플리케이션은 닫힌다.

<소스>

출력은 다음과 같다.

http://docs.oracle.com/javase/8/docs/api/

이 간단한 예제는 분산 해시 테이블의 기초을 보여분다.

Page 128.

FreePastry 사용

Pastry(http://www.freepastry.org/)는 P2P 라우팅 오버레이 시스템이다. FreePastry(http://www.freepastry.org/FreePastry/)는 Pastry의 오픈 소스 구현이며, P2P 시스템의 다양한 기능을 설명하기 위해 사용하기에 충분할만큼 간단하다. Pastry는 O(log n) 단계에서 n 개의 노드의 네트워크로 메시지를 라우팅한다. 그것이 필요하다면, 기껏해야, 노드에 도달하기 위해 n단계의 log 베이스 2는 노드들의 네트워크를 설명한다. 이것은 효율적인 라우팅 방법이다. 그러나 그것은 단지 리소스에 도착하는 3개의 노드를 통과가 필요할 수 있지만, 그것은 IP홉의 상당수는 도착하는 홉이 필요할 수 있습니다.(확인필요) 

Pastry는 라우팅 처리에서 잎 세트(leaf sets)의 개념을 이용한다. 각 노드는 잎 세트가 있다. 잎 세트는 수치적으로 이 노드에 가장 가까운 노드의 GUIDS 및 IP 주소의 모음이다. 다음과 같이, 노드는 논리적으로 원형으로 배열된다.

다음 그림에서, 각 점은 식별자와 노드를 나타낸다. 여기에 사용되는 주소는 0 ~ FFFFFF 이다. 실제 주소는 0 ~ 2128 이다. 요청을 나타내는 메시지가 주소 9341A2에서 시작하고 E24C12을 주소로 전송해야하는 경우, 화살표로 도시된 바와 같이, 그 후, 오버레이 라우터를 중간 노드를 통하여 메시지를 숫자 주소에 기초한다.

Page 129.

그 외 애플리케이션은 다음을 포함한 FreePastry의 상단에 내장된다.

-SCRIBE: 이것은 출판사/구독자 패러다임을 지원하는 그룹 통신 및 이벤트 통지 시스템이다.
-PAST: 기록 보관 유틸리티 시스템(archival storage utility system)이다.
-SplitStream: 이 프로그램은 콘텐츠 스트리밍 및 배포를 지원한다.
-Pastiche: 백업 시스템이다.

이러한 각 애플리케이션은 사용을 지원하는 API를 사용한다.

FreePastry 데모

FreePastry가 P2P 애플리케이션을 지원하는 방법을 설명하기위해, https://trac.freepastry.org/wiki/FreePastryTutorial에서 확인되는 FreePastry 튜토리얼(tutorial)을 기반으로 하는 애플리케이션을 만든다. 이 데모에서, 두 개의 노드를 생성하고 메시지를 전송하고 수신하는 방법을 보여준다. 데모는 3개의 클래스를 사용한다.

-FreePastryExample: 네트워크를 부트스트랩하는 데 사용된다.
-FreePastryApplication: 노드의 기능을 수행한다.
-PastryMessage: 노드 간에 전송되는 메시지이다.

부트스트랩 애플리케이션과  함께 시작하자.

FreePastryExample 클래스의 이해

FreePastry 애플리케이션과 함께 사용되는 몇 가지 컴포넌트가 있다. 다음을 포함한다.

-환경(Environment): 애플리케이션의 환경을 나타낸다.
-바인드 포트(Bind port): 애플리케이션이 결합하는 로컬 포트를 나타낸다.
-부트 포트(Boot port): 노드의 InetAddress 클래스에서 사용되는 부트 포트이다.
-부트 주소(Boot address): 부트 노드의 IP 주소이다.

FreePastryExample 클래스는 다음과 같이 정의된다. FreePastryExample 클래스는 main 메소드 및 생성자를 포함한다.

<소스>

Page 130.

main 메소드로 시작한다. Environment 클래스의 인스턴스는 먼저 생성된다. 이 클래스는 노드를 위한 매개변수 설정(parameter settings)을 보유하고 있다. 다음으로, NAT 검색 정책은 어려움없이 로컬 LAN에서 프로그램을 사용할 수 있도록 하고 결코 설정되지 않는다.

<소스>

포트 및 InetSocketAddress 인스턴스는 초기화된다. 이 시간에 같은 번호로 두 포트를 설정한다. InetAddress 오브젝트를 인스턴스화하기 위해 IP 주소 192.168.1.14를 사용한다. 대신 머신의 주소를 사용해야한다. 로컬 LAN 주소다. 제대로 작동하지 않기 때문에 127.0.0.1을 사용하면 안된다. bootPort 값과 함께 InetAddress 오브젝트는 InetSocketAddress 인스턴스를 생성하는 데 사용된다. 이 모두는 예외 처리를 위한 try 블록에 배치된다.

<소스>

마지막 작업은 생성자를 호출에 의해서 FreePastryExample 인스턴스를 생성하는 것이다. 

<소스>

생성자는 노드의 애플리케이션을 생성하고 실행한다. 이를 달성하기 위해, PastryNode 인스턴스를 생성하고 애플리케이션을 연결해야 한다. 노드를 생성하려면, 팩토리(factory)를 사용한다.

Page 131.

모든 노드는 고유한 ID가 필요하다. RandomNodeIdFactory 클래스는 현재 환경에 따라 ID를 생성한다. 포트와 환경을 바인딩하는 오브젝트를 사용하여, SocketPastryNodeFactory 인스턴스는 생성된다. 이 팩토리의 newNode 메소드는 PastryNode 인스턴스를 생성하기 위해 호출된다.

<소스>

다음에, FreePastryApplication 클래스의 인스턴스가 생성되고, 노드는 boot 메소드를 사용하여 개시된다. 

<소스>

다음 코드 시퀀스에서 보여주는 것과 같이, 그 후 노드 ID는 표시된다. 네트워크에서 다수의 노드가 있는 바와 같이, 다른 노드를 시작하도록 10초 동안 정지한다. 이 지연을 적용하려면 FreePastry 타이머(timer)를 사용했다. 임의의 노드 ID가 생성되고, 애플리케이션의 routeMessage 메시지는 그 노드에 메시지를 전송하기 위해 호출된다.

<소스>

프로그램을 실행하기 전에, 애플리케이션 클래스를 개발할 필요가 있다.

FreePastryApplication 클래스의 이해

FreePastryApplication 클래스는 애플리케이션 인터페이스를 구현하고 노드의 기능을 실행한다. 생성자는 Endpoint 인스턴스를 생성하고 등록하고 메시지를 초기화한다. Endpoint 인스턴스는 메시지를 보낼 노드에 의해 사용된다. 클래스와 생성자는 여기에 표시된다.

<소스>

Page 132.  
 

