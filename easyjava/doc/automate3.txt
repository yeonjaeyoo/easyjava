Page 273.

9장. 이미지 상상

거의 매일 기본적으로 이미지로 작업한다. 페이스북 프로필 페이지로 이미지를 업로드하거나 모바일 혹은 웹 애플리케이션을 개발하는 동안 이미지를 조작한다. 풍부한 유스 케이스가 있다. 컴퓨터 비전 분야에서 많은 진보와 함께 이미징은 중요한 분야가 됐다. 이미지 작업은 파이썬에서는 하찮은 작업이다.

9장에서는 다음과 같은 레시피를 다룰 것이다.

-이미지 전환
-리사이징, 자르기 및 썸네일 생성
-복사-붙여 넣기 및 이미지 워터 마킹
-이미지 차이와 비교
-얼굴 감지
-비즈니스 프로세스로 이미지 생성

소개

전자 세계의 이미지는 0과 1로 구성된 비트이다. 그것들은 장면이나 문서의 전자 스냅샷이다. 그림 혹은 사진조차도 디지털화하여 이미지를 형성할 수 있다. 이미지를 더 깊이 이해하고 이미지가 어떻게 구성되어 있는지 살펴보자.

모든 이미지는 샘플링되며 픽셀(pixels)이라는 점 격자로 표시된다. 이 픽셀은 화면에 표시된 그림의 최소 제어 가능 요소를 나타낸다. 이미지에서 사용할 수 있는 픽셀 수가 많을수록 장치 화면에서는 이미지가 더 정확하게 표시된다.

Page 274.

각 픽셀의 강도(intensity)는 가변적이다. 디지털 세계에서 이미지의 색상은 gred, green 및 blue(RGB) 또는 Cyan, Magenta, Yellow 및 Black(CMYK)의 세 가지 혹은 네 가지 강도로 표현된다. 컴퓨터 프로그램은 종종 RGBA 형식의 색상을 나타내며, 여기서 A는 알파(또는 색상의 투명도)를 나타낸다. 각 픽셀은 RGBA 형식의 이진 표현으로 표현되며 시퀀스로 컴퓨터에 의해 저장된다. 컴퓨터는 디스플레이를 위해 이 순서를 읽고 경우에 따라 인쇄용 아날로그 버전으로 변환한다. 특정 이미지 속성을 자세히 살펴보자.

이미지 속성

이미지 속성의 일부를 살펴보자.

-이미지 크기: 앞서 배웠듯이 컴퓨터 이미지는 0과 1로 저장되며 픽셀(직사각형 점) 단위로 측정된다. 이미지의 파일 크기는 포함된 픽셀 수와 저장된 색상 정보의 양에 따라 계산된다. 실제로 파일 크기는 컴퓨터 하드 드라이브의 이미지가 차지하는 공간이다.
-비트 심도(Bit depth): 단일 픽셀의 색상을 나타내는 데 사용되는 비트 수이다. 이 개념은 픽셀을 설명하는 데 사용되는 비트 수를 나타내는 픽셀 당 비트 수로 정의할 수 있다. 이미지의 비트 심도가 클수록 저장할 수 있는 색의 숫자는 커진다. 1 비트 이미지에는 0과 1의 2개(2 ^ 1)의 색만 저장할 수 있으므로 흰색과 흑백으로 표시된다. 그것과 비교할 때, 8 비트 이미지는 256(2^8) 색상을 저장할 수 있다.
-이미지 해상도: 해상도는 이미지의 픽셀 수를 나타낸다. 해상도는 때때로 이미지의 폭(width)과 높이(height)로 식별된다. 예를 들어 1,920 x 1,024 픽셀 해상도의 이미지는 1,966,080 픽셀을 포함하거나 1.9-메가픽셀 이미지이다.
-화질: 이미지가 저장하는 정보에 따라 변경할 수 있다. 모든 이미지가 이미지를 나타내기 위해 모든 픽셀을 저장해야 하는 것은 아니다. 예를 들어, 사진의 푸른 바다의 연속 블록은 모든 픽셀을 가질 필요는 없으며 이미지는 이미지 품질을 손상시키지 않으면서 이미지의 디스크 공간을 줄이기 위해 압축될 수 있다. 이러한 디스크 공간의 축소를 압축이라한다. 높은 압축은 눈에 띄는 세부 묘사를 의미한다. 오늘날의 세계에서 사용되는 일반적인 압축 유형은 JPG 압축이며, 크기 및 이미지 품질을 희생한다.

Page 275.

-이미지 형식: 이미지는 다른 확장명을 가진 컴퓨터에 저장된다. BMP 혹은 TIF와 같은 형식은 전혀 압축되지 않는다. 따라서 더 많은 디스크 공간을 차지한다. JPG와 같은 파일은 압축할 수 있으며 압축 수준을 선택할 수도 있다. 따라서 TIF 이미지는 무손실이고 JPG 압축은 손실 압축(lossy compressions)이라고 한다. 손실 압축은 사람의 음영 차이를 차별화하지 못하는 것을 사용한다는 점이 흥미롭다. 다수의 손실이 있는 변환은 이미지 품질 저하를 초래하지만 여러 번의 무손실 변환은 이미지 품질을 보존한다. 그러나 일반적으로 압축과 관련하여 이미지 저하와 크기 사이의 절충점이다.

좋아, 좋은 시작이다. 9장에서는 이미지에 대한 더 많은 개념을 살펴보고 파이썬으로 이미지에서 수행할 수 있는 다양한 작업을 다룬다. 이미지를 조작하는 데 도움이 되는 여러 모듈을 살펴볼 것이다. 9장의 마지막 부분에서는 9장에서 다룬 레시피를 활용한 지식으로 자동화할 수 있는 일반적인 비즈니스 프로세스에 대해서도 다룰 것이다.

9장에서는 다음 파이썬 모듈을 사용한다.

-Pillow(https://pypi.python.org/pypi/Pillow)
-scipy(https://www.scipy.org/)
-opencv(https://pypi.python.org/pypi/opencv-python)

이미지 변환하기

간단한 예제를 들어 이미지 여행을 시작하자. 그러나 계속하기 전에 가상 환경을 구축하자.

1. virtualenv 커맨드를 사용하여 가상 환경을 구축하고 활성화한다.

<소스>

2. 좋아! 이제 9장에 대한 레시피로 작업할 독립적인 환경을 구성했다. 첫 번째 예제에서는 파이썬의 Pillow 모듈을 사용한다. 레시피로 가기 전에 먼저 이 모듈을 설치하자. Pillow 모듈을 설치하기 위해 가장 좋아하는 python-pip를 사용할 것이다.

<소스>

이제 환경이 생겼고 Pillow 모듈도 설치됐다. 이제 레시피 작업 준비가 끝났다.

실행방법

이 절에서는 이미지를 다른 형식으로 변환하는 방법을 다룰 것이다.

1. 먼저 모든 작업을 수행하기 위해 샘플 이미지로 사용할 수 있는 이미지를 다운로드하자. 나는 일몰을 좋아한다. 그래서 9장의 대부분의 레시피에 일몰 이미지를 사용했다. 이것이 보이는 방법이다. 내 노트북에 저장하고 beach_sunset.png라고 이름을 지었다.

Page 277.

<그림>

2. 이제 이 이미지를 JPEG 형식으로 변환하는 파이썬 코드를 작성해보자. 다음 코드는 우리가 필요로 하는 것을 정확하게 수행한다. convert.py라는 파일의 파이썬 코드를 저장한다.

<소스>

이 프로그램을 파이썬의 convert.py 커맨드로 실행하면 원래 PNG 이미지가 JPG 형식으로 변환되고 asbeach-susnset-conv.jpg에 저장된다.

Page 278.

3. 좋아! 이제 이 이미지에 대해 한 번 더 연산을 수행하고 그레이스케일(흑백 형식)으로 변환해보자. 사람들이 이미지를 흑백 형식으로 변환하여 향수를 부여하는 것이 일반적이다. 이것은 다음 커맨드 라인을 사용하여 쉽게 수행할 수 있다.

<소스>

이제 이 프로그램을 실행하면 disk-sunset-gray.png라는 이름의 디스크에 다른 이미지가 생성된다. 이 이미지는 다음과 같다.

<사진>

Page 279.

4. 좋아, 더 나아가 이미지 회전 및 뒤집기와 같은 몇 가지 작업을 수행해보자. 이러한 작업은 재미있는 웹 사이트에서 자주 사용되며 이미지가 있는 곳에서 간단히 재생할 수 있다. 다음 코드는 이미지를 180도 회전시키는 데 도움이될 것이다.

<소스>

기본 이미지로 이 코드를 실행하면 여기에 표시된 것처럼 180도 회전된 이미지, 즉 이미지가 거꾸로 보인다.

<그림>

Page 280.

5. 회전하는 이미지가 좋지만 이미지를 뒤집을 수 있다면 정말 재미있을 것이다. PIL은 실망스럽지 않으며 이미지를 수평 및 수직으로 뒤집을 수 있는 옵션을 제공한다. 다음 코드는 뒤집기 작업을 수행하는 데 도움이 된다.

<소스>

이제 이 코드를 실행하면 두 개의 이미지가 생성된다. 다음 이미지는 원본 이미지와 동일하지만 가로로 뒤집힌다(미러가 이미지의 오른쪽에 있는 것처럼). 산이 이미지의 오른쪽으로 어떻게 움직였는지 살펴본다.

Page 281.

다음 스크린샷은 원본 이미지의 대칭 이미지로, 수직으로 뒤집는다. 공지사항에 따르면, 산은 여전히 이미지의 왼쪽에 있지만 거꾸로 되어있다. 비슷한 것은 석양의 운명이다. 일출처럼 보이나?

<그림>

작동원리

이 절에서는 PNG와 JPEG의 두 가지 이미지 형식을 다룬다. PNG(Portable Network Graphics) 파일은 품질을 저하시키지 않으면서 사진 이미지를 압축하는 비손실 파일dlek다. 인터넷 그래픽을 위한 훌륭한 파일 형식이다. 여러 배경과 함께 사용할 수 있으며 투명도를 지원한다. 첫 번째 코드 예제인 beach_sunset.png에 사용된 이미지의 경우 파일 크기는 550KB이다.

JPEG (Joint Photographic Experts Group)는 손실 압축 기술을 사용하여 이미지를 압축한다. JPG는 이미지 섹션을 픽셀 혹은 타일로 축소하여 이미지를 압축한다. JPG 이미지는 설정에 따라 N:1의 비율로 압축될 수 있다. 이미지가 쉽게 압축되고 인터넷상의 이미지에 액세스하기 위한 인터넷 대역폭을 줄일 수 있기 때문에 JPG는 인터넷 상의 이미지 표준이됐다. 변환된 이미지는 파일 크기가 450KB로 PNG 파일보다 거의 20 % 더 작음을 알 수 있다.

Page 282.

이제 파이썬 코드를 살펴보자. Image 클래스는 PIL 모듈에서 가져온다. Image 클래스는 이미지를 디스크에 저장하는 것과 같은 다른 작업과 마찬가지로 이미지의 열기, 로드 및 변환을 담당한다. 이 예제에서는 open() 메소드를 사용하여 PNG 이미지를 열고 save() 메소드를 사용하여 이미지를 JPEG 형식으로 저장한다.

두 번째 예제에서는 이미지를 흑백 형식으로 변환한다. RGB 및 CMYK 형식과 마찬가지로 흑백을 나타내는 L 형식도 있다. 이미지를 L 형식으로 변환하는 동안 ITU-R luma 형식(L = R * 299 / 1000 + G * 587 / 1000 + B * 114 / 1000)을 사용한다.

파이썬 코드에 관해서도 다시 Image 클래스를 사용하여 파일을 opne() 메소드를 사용하고 convert() 메소드를 사용하여 인수 L로 이미지를 흑백으로 변환한다. 마지막으로 save() 메소드를 사용하여 디스크에 파일을 저장한다. 여기서 파일 형식을 PNG로 유지한다.

세 번째 예제에서는 동일한 Image 클래스와 open() 이미지를 사용하여 img 객체를 가져온다. 이 객체는 회전 각도를 인수로 사용하여 rotate() 메소드를 호출하는 데 사용된다. 이 예제에서는 이미지를 180도 회전하고 마지막으로 save()를 호출하여 회전된 이미지를 sunset180deg.jpg라는 이름의 디스크에 저장한다.

마지막 예제에서는 PIL 모듈의 transpose() 메소드를 사용하고 Image.FLIP_LEFT_RIGHT 및 Image.FLIP_TOP_BOTTOM 속성을 사용하여 이미지를 왼쪽에서 오른쪽 및 위에서 아래로 두 방향 회전한 sunset_horizontal_flip.png 및 sunset_vertical_flip.png라는 이름으로 저장한다.

더 알아보기

Pillow 모듈에는 리사이징, 붙여 넣기, 자르기와 같이 이미지에서 보다 복잡한 작업을 수행하는 데 도움이 되는 더 많은 메소드가 있다. 9장의 다음 레시피에서 살펴볼 것이다.

리사이징, 자르기 및 썸네일 생성

이미지 크기를 조정하고 이미지를 자르는 것과 같은 작업은 매우 일반적이지만 프로그래밍 방식으로 시도하면 이러한 작업이 지루할 수 있다. 이러한 작업을 어떻게 수행할 수 있는지 살펴보자.

Page 283.

준비하기

이 레시피에서는 Pillow 라이브러리를 사용하여 이미지의 크기를 조정하고 자른다. 이미 Pillow 모듈을 설치했으므로 설치에 대해 걱정할 필요가 없다. 목표에 집중하자.

실행방법

1. 먼저 주어진 크기로 이미지 크기를 조정하는 방법을 살펴보자. 파이썬 파일 resize.py를 생성하고 다음 코드 조각을 붙여넣는다.

<소스>

2. 또한 인터넷에서 이미지를 다운로드하고 sunset.jpg라고 이름을 지정한다. 내 이미지는 이렇게 보인다.

<그림>

Page 284.

3. 이제 python resize.py 커맨드로 파이썬 코드를 실행하고 디스크의 sunset-resize.jpg 이미지를 살펴본다. 이미지의 크기가 조정되고 다음 스크린샷과 유사하게 보인다.

<그림>

이미지는 예상대로 256x256 픽셀이다.

<그림>

Page 285.

4. 프로그래밍에서 종종 필요로하는 또 다른 작업은 이미지에 대한 썸네일을 생성하는 것이다. 썸네일은 원본 이미지의 미리보기로 사용되며 일반적으로 영화 리뷰 웹사이트 혹은 서적 출판 웹사이트에서 사용된다. Pillow 모듈을 사용하여 썸네일을 쉽게 생성할 수 있는지 살펴보자. 파이썬 파일을 생성하고 이 코드를 추가한다.

<소스>

이제 이 코드를 실행하면 원본 이미지의 썸네일인 sunset.thumbnail.jpg 이미지가 생성되며 아래 스크린샷과 같이 표시된다. 이미지의 크기를 보면 128x128(128x80 픽셀)이 아니다. 이것에 대한 이유를 약간 다룰 것이다.

좋아! 따라서 이미지를 위해 생성된 썸네일을 가지고 프로필 썸네일 혹은 혹은 미리보기 이미지로 웹사이트에서 사용될 수 있다.

<그림>

5. 이 레시피에서 다룰 다른 작업은 이미지 자르기이다. 다음 코드는 우리가 필요로 하는 것을 정확하게 수행한다.

<소스>

Page 286.

위의 파이썬 조각을 실행하면 디스크에 생성된 원본 일몰 이미지에서 자른 이미지 sunset-crop.jpg가 표시된다. 이것은 다음과 같다.

<사진>

Pillow가 있는 이미지에서 여러 작업을 매우 쉽고 직관적으로 수행할 수 있는 방법을 살펴보면 좋다. 그러나 이러한 작업은 어떻게 작동하나? 사용된 메소드는 무엇인가? 그것들을 살펴보자.

작동원리

이 레시피에서는 필로우의 Image 클래스를 사용하여 이미지의 크기를 조정하고 이미지를 자르고 원본 이미지에서 썸네일을 생성했다.

첫 번째 코드 조각에서 open() 메소드로 sunset.jpg 이미지를 열었다. 그런 다음 크기 조정된 이미지의 너비와 높이가 나열된 튜플 인자(argument)와 함께 resize() 메소드를 사용했다. 그런 다음 파일 이름이 sunset-esize.jpg이고 JPEG 파일 형식인 save() 메소드를 사용하여 디스크에 파일을 저장했다.

Page 287.

두 번째 조각에서는 open() 메소드를 사용하여 이미지를 열고 이미지 객체를 가져왔다. 그런 다음 이미지 객체에 있는 Image 클래스의 thumbnail() 메소드를 사용하여 썸네일을 생성했다. thumbnail() 메소드는 이미지 크기(128 x 128)를 사용하고 BICUBIC 이미지 필터링 메커니즘을 사용한다. 마지막으로, 대상 파일 이름이 sunset.thumbnail.jpg로 설정된 save() 메소드로 이미지를 저장했다. 썸네일의 크기를 살펴본 결과 정확히 128x128 크기가 아니라는 것을 알았다. 실제로는 128 x 80이다. PIL은 이미지 너비를 128 픽셀로 유지한 다음 높이를 다시 계산하여 이미지의 비율을 유지한다.

그리고 세 번째 예제에서, Pillow 모듈의 Image 클래스의 crop() 메소드로 이미지를 잘라냈다. crop() 메소드는 원본 이미지에서 이미지를 조각낼 필요가 있는 네 개의 좌표를 모두 가져온다. 이 예제에서는 원본 이미지를 자르기 위해 좌표를 left = 965, top = 700, right = 1265, bottom = 960으로 지정했으므로 예제에서 보았듯이 얻은 결과는 태양의 이미지이다.

더 알아보기

썸네일 생성 예제에서, 더 명확하게 하기위해 이미지에 적용된 필터에 대해 간단히 언급했다. 9장에서 자세히 다루지는 않겠지만 관심이 있다면 http://pillow.readthedocs.io/en/3.0.x/releasenotes/2.7.0.html#default-filter-for-thumbnails에서 자세히 살펴본다.

복사-붙여넣기 및 워터마킹 이미지

이 레시피에서는 이미지를 워터 마킹하는 디자이너와 마케팅 담당자가 많이 사용하는 한 가지 작업에 대해 다룬다. 또한 이미지를 서로 복사-붙여넣기 하는 재미있는 방법을 살펴볼 것이다. 계속 살펴보자.

Page 288.

준비하기

이 레시피에서는 이미지를 복사-붙여넣기를 위해 Pillow를 계속 사용하지만 워터마킹을 위해 다른 파이썬 모듈인 wand를 사용한다. 따라서 정상적인 연습처럼 코드 작성을 시작하기 전에 먼저 wand 모듈을 설치하자. 우리가 가장 좋아하는 도구인 파이썬의 pip로 wand를 설치한다.

<소스>

모듈을 이미 설치했나? OK, 이제 들어가자.

실행방법

1. 먼저 Pillow로 복사-붙여넣기 작업을 수행하는 방법을 살펴보자. 이전 절에서는 원본 이미지, sunset.jpg 및 원래 이미지에서 자른 태양 이미지인 sunset-crop.jpg의 두 가지 이미지가 있음을 기억한다. 다음 파이썬 코드에서 이 이미지들을 사용할 것이다.

<소스>

Page 289.

2. 파일의 코드를 copy_paste.py라는 이름으로 저장하고 파이썬 커맨드인 copy_paste.py를 사용하여 코드를 실행해보자. 코드를 실행하면 다음 스크린샷과 같은 pasted.jpg라는 새 파일이 생성된다.

<그림>

우리는 자른 이미지를 복사하여 원본 이미지에 붙여넣고 붙여넣은 이미지를 pasted.jpg로 저장하는 것이다. 멋지지 않니?

Page 290.

이제 상업적으로 사용되는 흥미로운 예제를 살펴보자. 이 예제에서는 기존 이미지에 워터마크를 추가하고 다른 이름으로 저장한다. 그러나 파이썬 코드에 들어가기 전에 워터마크 이미지가 어떻게 보이는지 살펴보자.

<그림>

다음 파이썬 코드는 이전의 워터마크를 원래의 sunset.jpg 이미지 파일에 추가하는 데 도움이 된다.

<소스>

3. 이 코드를 실행하면 프로젝트에서 result.jpg 파일이 생성된다. 다음 스크린샷과 비슷하게 보인다. 상단에 저작권 이미지 텍스트가 있는 이미지의 워터마크 처리 방법을 살펴본다.

Page 291.

<그림>

첫 번째 코드 조각의 경우 PIL 모듈과 Image 클래스를 사용하여 open()으로 자른 이미지와 원본 이미지를 두 파일 img 및 pasteImg의 파일 핸들을 가져왔다.

이름에서 알 수 있듯이 자른 이미지 img를 열고 파일 핸들을 사용하여 pasteImg에 붙여넣는다.

이미지를 붙여넣기 위해 Pillow의 paste() 모듈을 사용하고 img 파일 핸들을 소스 이미지로 전달했다. 또한 자른 이미지가 원본 이미지에 붙여 넣을 좌표를 전달했습니다. 좌표를 (0, 0)으로 선택했으므로 자른 이미지는 원본 이미지의 왼쪽 위 모서리에 붙여 넣어진다. 마지막으로, 이 이미지를 pasted.jpg로 저장했다.

두 번째 예제에서는 원본 이미지 sunset.jpg와 워터마크 이미지 watermark.jpg를 열고 파일 핸들, 배경 및 워터마크를 각각 생성했다. 그런 다음 wand 모듈의 watermark() 메서드를 사용하여 원본 이미지에 워터 마크를 추가했다.

Page 292.

watermark() 메소드는 배경이미지 객체(이 경우 백그라운드, 원래 이미지 객체)에서 작동한다. 이미지를 키워드 인자로 사용하여 워터마크 이미지의 객체를 나타낸다. 워터마크 이미지의 투명도를 설정할 수도 있다. 여기서 0은 워터마크가 완전히 보이고 1은 보이지 않음을 나타낸다. watermark() 메소드로 얻을 수 있는 또 다른 유용한 점은 원본 이미지에서 워터마크 위치를 선택할 수 있다는 것이다. 이 예제에서는 좌표가 왼쪽에서 560, 위쪽에서 300이 되도록 선택했다.

좋아. 그것은 이 조리법에 있다. 9장의 레시피에서 남은 것을 저장하고 있는지 살펴보자. 

이미지 차이 및 비교

텍스트 기반 검색을 사용하거나 구현해야 한다. 그러나 이미지 기반 검색을 수행할 수도 있을까?. 당연히, 구글은 그것을 매우 좋게한다. 어떻게 생각하니? 직접 구현해야 하는 경우 두 이미지를 비교하는 방법을 잘 알고있어야한다. 사용 사례에 따라 diff 혹은 두 이미지 간의 차이를 가져올 수도 있다. 이 레시피에서는 두 가지 유스 케이스를 다룰 것이다.

- 두 이미지의 차이를 얻고 그 차이를 이미지로 저장하는 방법
- 객관적으로 과학적 메소드로 두 이미지를 비교하는 방법

준비하기

이 레시피에서는 계속 Pillow를 사용하여 이미지를 비교한다. Image 클래스와 함께 ImageChops 클래스를 사용하여 두 이미지의 차이를 가져온다. 픽셀 단위로 이미지를 비교하기 위해 scipy 모듈을 사용한다.

1. 이미 Pillow 모듈을 설치했으므로 파이썬 pip를 사용하여 scipy 모듈을 설치해보자. Mac OS X 머신에서는 scipy 모듈을 설치하기위한 컴파일러가 필요하다. Mac의 brew 커맨드로 Mac에 GCC 컴파일러를 설치한다.

<소스>

Page 293.

<소스>

2. 이제 GCC가 설치되었으므로 python-pip로 scipy를 설치한다. 시스템에 설치 로그가 나타나는 방법이다.

<소스>

Page 294.

이제 GCC가 설치되었으므로 python-pip로 scipy를 설치하자. 이것이 시스템에 설치 로그가 나타나는 방식이다.

<소스>

Page 295.

<그림>

원본 이미지의 기본이 동일하기 때문에 차이점은 태양의 자른 이미지 일뿐이다. 좋아! 검은 색 영역은 무엇을 나타내는가? 작동원리 절에서 설명할 것이다.

2. 이제 객관적인 방식으로 이미지 간의 차이를 계산해보자. 이를 위해 scipy 모듈을 사용한다. 다음 코드 예제는 우리에게 필요한 것을 도와준다.

<소스>

Page 296.

위의 파이썬 코드를 실행하면, 두 이미지 간의 픽셀 차이가 발생한다. 예제의 출력은 다음과 같다.

<소스>

작동원리

이 절의 첫 번째 코드 조각에서는 Pillow 라이브러리의 ImageChops 클래스를 사용하여 두 이미지 간의 차이점을 계산했다. 보통, open() 메소드로 두 이미지를 모두 열고 이미지 객체 image_one과 image_two를 각각 가져왔다.

이 후 ImageChops 클래스의 difference() 메소드를 사용하고 이 메소드에 인자로 이미지 객체를 전달했다. difference() 메서드는 diff 객체를 반환하며, 기본적으로 두 이미지 간의 차이를 나타내는 객체이다.

마지막으로 차이점을 diff.jpg라는 이름으로 디스크에 이미지로 저장했다. 또한 이미지에서 0이 아닌 영역의 경계 상자를 계산하는 diff 객체에 getbbox() 메소드를 사용했다. 여기서 0이 아닌 영역은 sunset.jpg와 pasted.jpg의 차이가 0인 픽셀을 나타낸다.

이제, diff.jpg를 살펴보면 거대한 검은색 영역이 있다. 차이가 0인 픽셀이므로 색상이 검정이다. 동일한 이미지의 경우, getbbox() 메소드는 None을 리턴한다.

두 번째 예제에서는 0이 아닌 픽셀 수를 나타내는 0 표준을 기준으로 두 이미지를 비교했다. 즉, 두 이미지 간에 얼마나 많은 픽셀이 다른지 나타낸다. 이미지를 비교하기 위해 먼저 scipy 모듈의 imread() 메소드를 사용하여 두 이미지를 모두 읽는다. 이미지 객체는 모두 img1과 img2이다.

이 후 diff = img1 - img2를 사용하여 두 이미지 간의 차이를 계산했다. 이 차이는 scipy의 ndarray 유형에서 반환됐다. 이 차이를 norm() 메소드에 전달하면 이미지 간에 다른 픽셀 수가 반환된다.

더 알아보기

이미지를 비교하는 방법은 여러 가지가 있습니다.이 장에서는이 장에서 다루지 않았습니다. 나는 당신이 정말로 관심이 있다면 당신이 더 깊은 독서를 할 것을 제안합니다. 그러나 모든 실제적인 목적을 위해, 9장은 충분하다고 생각한다.

Page 297.

안면 검출

이전 절에서 이미지 작업을 다뤘다. 이 레시피에서는 이미지를 더 깊이 파고 안면 검출과 같은 고급 작업을 다룰 것이다.

준비하기

이 레시피에서는 파이썬 opencv 모듈을 사용할 것이므로 필요한 모듈을 설치해보자.

1. opencv 파이썬 바인딩을 사용하려면 먼저 컴퓨터에 opencv를 설치해야 한다. 내 Mac OS X 컴퓨터에서는 brew 유틸리티를 사용하여 opencv를 이 방법으로 설치한다.

<소스>

2. 컴퓨터에 opencv를 설치하는 것만으로는 도움이 되지 않는다. 또한 다음 커맨드를 사용하여 cv2.so(.so는 공유 객체 혹은 라이브러리를 나타냄)가 가상 환경에 연결되도록 지정해야 한다.

<소스>

좋아! 그래서 이제 이 레시피의 예제에 필요한 opencv를 설치했다.

Page 298.

실행방법

1. 가장 좋아하는 편집기로 이동하여 파이썬 파일을 생성하고 이름을 face_detection.py로 지정한다. 이제 다음 코드를 파이썬 파일에 복사한다.

<소스>

2. 이제 haarcascade.xml이라는 이름으로 XML 파일을 생성하고 이 책의 코드 저장소에서 내용을 복사한다. 나의 예제에서, 나는 사진 중 하나인 Chetan.jpeg를 사용하고 있지만, 이 예제에서는 사진을 사용할 수 있다. Chetan.jpeg은 다음과 같다.

<그림>

Page 299.

3. 이제 파이썬 코드를 실행하고 코드가 이미지에서 내 얼굴을 인식할 수 있는지 살펴본다. pythonface_detection.py 커맨드로 코드를 실행하고 다음과 같은 Chetan_face.jpg 이미지를 생성한다. 실제로, 그것은 내 얼굴을 감지했다.

<그림>

작동원리

레시피에서는 우선 haarcascade.xml 파일을 사용하여 cascade classifier 객체를 생성하기 위해 opencv 모듈을 사용했다. 이 객체를 face_cascade라고 불렀다.

Haar의 특징 기반 cascade classifiers를 이용한 물체(Object) 감지는 2001년 Paul Viola와 Michael Jones에 의해 제안된 효과적인 물체 감지 방법(method)이다. 이것은 계단식 함수(cascade function)가 많은 양수 및 음수 이미지로부터 훈련된 기계 학습 기반 방식이다. 그런 다음 다른 이미지의 객체를 감지하는 데 사용된다.

Haar 기능은 코드 예제에서 사용한 표준 XML 파일로 제공된다. 실제로는 원하는 객체를 탐지하기 위해 분류자를 훈련시킬 수 있다. 예를 들어, 안구 감지(eye detection)는 다른 분류자를 사용한다.

Page 300.

다음으로 opencv 모듈의 imread() 메소드를 사용하여 원본 기본 이미지인 Chetan.jpeg를 읽고 가장 작은 창을 탐지하도록 정의한다.

사실 Haar 캐스케이드 분류기(cascade classifier)는 슬라이딩 윈도우 접근 방식에서 작동하므로 탐지를 위해 가장 작은 창을 필요로 한다. 분류기는 구성된 minNeighbors도 필요하다.

이와 같은 설정 캐스케이드 객체의 detectMultiScale() 메소드에서 구성된다. minSize=(30,30) 및 minNeighbors=3으로 설정했다.

마지막으로 감지된 이미지를 디스크에 저장했으며 원본 이미지는 녹색 사각형을 이미지의 얼굴 인식 표시로 사용한다.

더 알아보기

opencv로 얼굴 인식의 아주 간단한 예제를 살펴보고 분류기에 대해 조금 다뤘다. opencv는 배울 것이 더 많은 것들이 있다.

여기에 재미있는 리소스를 찾을 수 있는 링크(http://docs.opencv.org/trunk/index.html)가 있다.

비즈니스 프로세스의 이미징

Peter는 대기업인 MBI Inc의 IT 관리자이다. 그의 회사는 계약 금융 문서, 표준 운영 절차 및 공급망 문서의 대부분을 종이 기반으로 사용할 수 있을만큼 오래동안 존재해 왔다. 페터는 자신의 회사를 종이없는 회사로 만드는 엄청난 책임이 있다.

즉, 그는 서류 기록을 관리하는 번거로움과 비용을 없앨 책임이 있음을 의미한다. 9장에서는 지금까지 수집한 이미징 지식(그리고 더 많이 배우게 될 것이다)을 통해 우리가 페터를 도울 수 있는지 살펴보자.

신중하게 분석한다면 페터는 두 가지 중요한 작업을 수행해야한다.

- 종이를 스캔하고 이미지를 전자 형식으로 저장한다.
- 쉽게 색인을 생성할 수 있도록 이러한 문서에서 텍스트 파일을 생성한다.

Page 301.

준비하기

이 연습에서는 필요한 모듈을 설치하는 것으로 시작하자. 다음 모듈이 필요하다.

<주소>

모듈 설치를 시작하자.

1. 먼저 scikit-image로 시작하자.

<소스>

Page 302.

<소스>

2. 다음으로 pyimagesearch를 설치해보자. 이것은 Adrian Rosebrock이 개발한 훌륭한 라이브러리 모음이다. 그는 자신의 작업을 http://github.com/jrosebr1에서 오픈소스로 제작했다. 사실, 우리는 이 코드 레시피에서 pyimagesearch의 스캐너 예제를 활용한다.
3. 마지막으로, tesseract와 pytesseract를 설치하자. OCR(Optical Character Reader) 모듈인 tesseract와 OCR 모듈을 사용하기 위한 파이썬 모듈인 pytesseract를 설치해야 한다.

<소스>

Page 303.

<소스>

그래, 좋아! 이제 실행방법 절의 코드를 살펴보자.

실행방법

가장 좋아하는 편집기로 이동하여 파이썬 파일을 생성하고 이름을 scanner.py로 지정한다. 페터의 경우, 이미지 형식의 재무 문서에 관한 것이지만, 이 예제를 살펴보면, 나와 함께 편리하게 사용할 수 있는 이미지가 될 것이다. 내 이미지의 모습은 다음과 같다. Andy Murray에 대한 신문 기사의 그림이고 그것을 디지털화하려고 한다.

<그림>

Page 304.

2. 이제 scanner.py에 다음 코드를 복사하고 python scanner.py 커맨드로 코드를 실행한다.

<소스>

Page 305.

파이썬 코드를 실행하면 하드 디스크에 세 개의 이미지가 생성된다. 첫 번째는 가장자리로 감지된 이미지이고 제 경우에는 다음과 같다. scan_edge.jpg로 저장된다.

<그림>

3. 다음으로, 텍스트가 있는 이미지의 전체 영역을 감지하는 다른 이미지를 얻는다. 이를 윤곽 이미지라고하며 scan_contours.jpg로 생성된다. 텍스트가 있는 이미지의 부분을 강조하는 방법을 살펴본다.

<그림>

Page 306.

4. 마지막으로 앤디 머레이(Andy Murray)의 뉴스 기사를 스캔하여 얻은 다음 scanned.jpg 파일로 저장한다. 다음 스크린샷에서 뉴스 기사가 얼마나 잘 스캔되었는지 살펴본다.

<그림>

처음 시작했을 때 성취하고 싶었던 바로 그것이지? 이걸 페터에게 주면 그는 매우 행복해할 것이다. 페터는 비용이 많이 드는 컨설팅 회사 혹은 스캐너를 생각하고 있을 수도 있지만, 신속하고 무료로 컨설팅을 수행할 수 있다.

5. 이것이 충분하지 않은 것처럼 여기서 페터를 위해 더 많은 일을 했다. 프로그램을 실행하면 전체 기사의 텍스트를 제공하는 텍스트 출력도 표시된다. 이 텍스트를 사용하여 페터는 문서를 분류하고 그에 따라 색인을 생성할 수 있다.

<소스>

Page 307.

<소스>

굉장해! 프로그램의 내부를 "작동 원리" 절에서 살펴보자.

작동원리

레시피에서 신문 기사의 사진을 찍기 시작했다. 이것을 murray.jpg라고 명명했다. 나는 이 이미지를 찍기 위해 간단한 카메라 폰을 사용했다. 그런 다음 opencv 모듈의 imread() 메소드를 사용하여 이미지를 읽는다.

또한 원래 높이와 새 높이의 비율을 계산하고 원본 이미지를 복제한 다음, 크기를 조정했다. copy() 메소드를 사용하여 이미지를 복제했으며 resize() 메소드를 사용하여 크기를 새로운 높이로 조정했다.

그런 다음 이미지를 cvtColor() 메소드로 그레이스케일 형식으로 변환한 다음 가우시안(Gaussian) 필터를 적용하여 이미지를 흐리게 표현했다.

흐리게 처리된 이미지(blurred image)를 Canny() 메소드를 사용하여 텍스트의 가장자리를 감지하도록 처리했으며 마지막으로 가장자리 감지 이미지를 scan_edge.jpg로 저장했다.

다음으로 findContours() 메소드를 사용하여 이미지의 윤곽을 찾고 이미지의 윤곽을 scan_contours.jpg로 저장했다.

이 후 이미지에 몇 가지 변형을 가했다. 4점 변환을 사용하면 원본 이미지를 탑-다운 뷰로 볼 수 있다. 이를 위해 four_point_transform() 메소드를 사용했다.

또한 이미지를 회색조로 변환한 다음 검정과 백지 스타일 느낌을 주기 위해 임계값을 설정했다. cvtColor() 메소드는 이미지를 회색조로 변환하고 threshold_adaptive() 메소드는 적절한 임계값을 적용한다. 그리고 우리는 끝났다. 이미지는 이제 준비가 완료되고 이미 스캔되어 scanned.jpg로 저장된다.

Page 308.

그러나 이전 절에서 보았듯이 신문 칼럼의 텍스트도 인쇄했다. 이미지 객체에서 image_to_string() 메소드를 사용하여 Pillow의 Image 클래스와 pytessaract 모듈을 사용하여 스캔한 이미지를 먼저 읽음으로써 이를 해결할 수 있다.

좋아, 종이 기반 문서를 전자 형식으로 변환하는 업무 프로세스를 자동화하고 파일 색인을 생성하여 회사의 ERP 프로세스에 쉽게 반영할 수 있는 기능을 추가했다. 피터는 너와 행복하다! 축하해!

더 알아보기

OCR에서 스캔한 이미지에서 텍스트 데이터를 추출하는 방법을 살펴봤지만 지능형 문자 인식(손으로 쓴 텍스트 추출) 및 바코드 인식(다양한 유형의 바코드 인식)과 같은 많은 기능을 제공한다. 또한 9장에서는 이미지 필터링을 많이 다루지 않았다. 여러분이 정말로 관심이 있다면 9장의 범위를 벗어난 이 주제에 대한 많은 읽을 거리를 얻을 수 있다.

Page 309.

10장. 데이터 분석 및 시각화

10장에서는 다음을 살펴볼 것이다.

-시각화로 데이터 읽기, 선택 및 해석
-데이터 필터링 및 집계를 통한 통찰력 생성
-비즈니스를 위한 소셜 미디어 분석 자동화

소개

우리는 하나님을 신뢰한다. 다른 모든 사람들은 데이터를 가져와야한다.- Edwards Deming, Statistician

오늘날 기업은 고객이 필요로 하는 정보, 구매할 채널 등을 파악하기 위해 데이터에 크게 의존한다. 이렇게하면 기업은 신제품을 출시하거나 새로운 제안을 내는 것에 대해 정보에 근거한 결정을 내릴 수 있다. 그러나 기업들은 어떻게 이것을 달성하나? 의사 결정은 실제로 무엇을 포함하나?

2017.09.11

Page 310.

데이터 기반 의사결정은 데이터 검사, 데이터 변환 제거 혹은 정리, 통찰력 생성, 유용한 정보 발견 및 결론 도출의 목적을 위한 데이터 위에 모델을 생성하는 프로세스를 의미한다. 예를 들어 상거래 회사는 이 프로세스를 사용하여 소비자 구매 패턴을 분석하고 특정 제품 그룹에 대한 프로모션 코드를 제안하기 위한 적절한 시간대를 제안한다. 실제로 기업은 추세 생성, 예측 모델 구축 혹은 단순한 원시 데이터에서 구조화된 정보 추출과 같은 여러 목적을 위해 정적 혹은 실시간 데이터를 분석한다. 데이터 분석에는 다양한 패싯(facets)과 접근 방식이 있으며 비즈니스 인텔리전스, 예측 분석 및 텍스트 마이닝으로 간단히 분류할 수 있다.

비즈니스 인텔리전스(BI, Business intelligence)는 대용량의 구조화된 데이터와 비정형 데이터를 처리할 수 있으므로 이러한 대량의 데이터를 쉽게 해석할 수 있다. 데이터에 대한 통찰력을 기반으로 새로운 기회를 파악하면 기업에서는 경쟁 우위와 안정성을 제공할 수 있다.

예측 분석(Predictive analytics)은 미래 혹은 알려지지 않은 사건에 대한 예측을 하기 위해 과거 데이터 및 현재 경향을 분석하기 위한 기계 학습과 같은 다양한 통계 모델의 적용을 포함한다. 여기에는 위험 평가 및 의사 결정을 위해 모델을 생성하고 데이터 기능 간의 관계를 캡처하는 작업이 포함된다.

텍스트 분석(Text analytics)은 구조화된 혹은 비정형화된 텍스트 데이터에서 품질 정보를 유도하는 프로세스이다. 텍스트 분석은 비즈니스를 위한 정보를 추출하고 분류하는 언어적, 통계적 및 문맥적 기법을 포함한다.

그러나 데이터 기반 의사결정은 쉽지 않으며 쉽게 수행할 수 없다. 데이터 기반 의사결정은 여러 작업을 포함하는 단계별 프로세스이다. 다음 절에서 전체 프로세스를 자세히 살펴보자.

데이터 기반 의사결정 단계

높은 수준에서 프로세스는 다음 단계로 분류할 수 있다. 물론, 목표에 맞게 프로세스를 사용자정의 할 수 있다.

-가설 및 데이터 요구 사항 정의: 프로세스를 시작하기 전에 구체적(Specific), 측정 가능(Measurable), 수용 가능(Acceptable), 관련성(Relevant) 및 시기 적절한(Timely)(SMART)으로 비즈니스 목표를 명확히 파악해야 한다. 문제를 해결하지 않고도 데이터 수집을 시작하고 싶지는 않다. 가능한 한 "지난 3분기 동안 소비자 공간에서 모바일 판매의 추세는 무엇인가?" 혹은 "이번 겨울에 150 %의 이익으로 전자 제품을 판매할 수 있게 될 것인가?"와 같은 명확한 문제 설명을 제시한다. 당신의 회사에 이런 성명서를 내놓을 수 있는가?

Page 311.

-데이터 소스: 데이터 소스에 대해서도 분명히 밝혀야한다. 데이터 분석을 수행하기 위해 회사 데이터베이스에 의존하고 있나? 또한 분석을 기반으로하는 서드파티 시장 조사 혹은 동향에 의존하고 있나? 서드파티 데이터를 사용하는 경우 소스(가능하면 API를 통해)에서 데이터를 추출하고 데이터 저장소에 저장하려면 어떻게 계획하나?
-데이터 수집: 이제 통찰력을 얻으려는 점에 대해 분명히했으므로 다음 단계는 필요한 형식으로 데이터를 수집하는 것이다. 예를 들어 모바일 판매 경향에 대한 데이터를 원할 경우 신제품 출시(제품), 제공(가격), 지불 옵션 및 구매 날짜/시간, 다른 관련 요인들 중과 같은 모바일 판매에 영향을 미치는 요인에 대한 데이터를 수집해야한다. 또한 데이터를 저장하는 데 동의하거나 표준적인 방법을 사용해야한다. 예를 들어, 단위당 모바일 매출을 EUR이 아닌 USD로 저장할 수 있다. 그렇지 않으면 매출을 일 단위가 아닌 시간 단위로 저장할 수 있다. 이러한 경우에는 대표 샘플을 확인하는 것이 매우 유용하다. 대표 샘플은 전체 인구를 정확하게 반영하고 분석에 확실히 도움이된다.
-데이터 변환: 이제는 데이터를 어디에서 가져올 것인지, 어떤 형식으로 데이터를 수집해야하는지 알게되었으므로 데이터를 로드할 위치를 결정해야한다. 그것은 평범한 오래된 CSV 혹은 SQL 데이터베이스일 수 있다. 가장 좋은 방법으로 데이터를 구성하고 분석할 수 있도록 사전에 알아야한다. 이 단계는 원본 데이터 시스템에서 대상 데이터 시스템으로 데이터를 추출하기 때문에 변환이라고 할 수 있다. 큰 규모의 데이터는 데이터웨어하우스 시스템에 저장된다.
-데이터 정리: 일단 데이터가 처리 및 구성되면 데이터 온전성을 살펴볼 차례이다. 변환된 데이터는 호환되지 않거나 중복되거나 적어도 측정, 샘플링 및 데이터 입력 오류를 포함할 수 있다. 데이터 정리에는 부정확한 데이터 제거, 누락된 데이터에 대한 기본값 추가, 특이 제거 및 기타 데이터 불일치 문제 해결이 포함된다. outliers를 버리는 동안 조심해야한다. 레코드를 간단히 삭제하거나 다른 관찰의 평균/모드를 사용하여 레코드를 삭제하는 것인가? 삭제하려는 방식을 결정해야 한다. 이 경우 최고의 의사 결정자이다.
-데이터 분석: 일단 데이터를 정리하고 사용할 준비가 되면 더 깊이 분석할 시간이다. 로지스틱 회귀와 같은 통계 기법을 사용하여 비즈니스 인텔리전스에 대한 데이터를 분석하거나 예측 모델을 생성할 수 있다. 또한 통찰력을 생성하고 의사 결정에 이르기 위해 텍스트 분석을 수행할 수 있다.

Page 312.

-데이터 시각화: 일단 분석이 완료되면 분석을 효과적으로 청중에게 전달할 수 있도록 다양한 형식으로 보고할 수 있다. 데이터 시각화는 테이블 및 차트와 같은 정보 표시를 사용하여 데이터에 포함된 주요 메시지를 전달하는 데 도움을 준다. 또한 시각화는 사용자가 분석을 통해 가정을 해석하고 의미있는 정보를 생성하는 데 도움이 된다.
-데이터 해석 및 피드백: 이 단계는 세 가지 주요 질문에 답하는 데 도움이 된다. 분석이 당신이 시작한 질문에 대한 답변을 제공하나? 가설을 수락하거나 거절하는 것을 검증하는 데 도움이 되나? 모델 혹은 결론을 향상시키기 위해 더 많은 데이터가 필요하나? 결론이 시스템에 다시 전달되지 않으면 완료되지 않는다. 피드백 루프는 예측 모델이 미래의 사용을 위해 풍부 해지고 잘 훈련되도록 한다.

좋아, 좋은 출발이야! 통찰력을 얻으려는 데이터 수집은 완전한 프로세스에 대한 올바른 생각을 가지고 있어야 한다. 목표 설정, 데이터 수집 및 데이터 변환과 같은 몇 가지 단계는 시장 상황 및 해결해야 할 문제에 대한 관습이다.

10장에서는 실시간 데이터 수집, 데이터 읽기, 데이터 분석 수행 및 데이터 시각화와 같은 몇 가지 일반적인 측면에 중점을 둘 것이다. 데이터를 효율적으로 읽고 통찰력을 생성하기 위해 데이터를 분석하는 데 도움이 되는 인기있는 파이썬 모듈을 살펴볼 것이다. 또한 데이터를 해석하고 시각화(차트)를 생성하는 데 도움이 되는 파이썬 모듈을 살펴볼 것이다.

10장의 마지막 부분에서는 10장에서 다룬 레시피로 작성한 지식으로 자동화할 수 있는 일반적인 비즈니스 프로세스에 대해서도 살펴볼 것이다. 10장은 데이터 과학자로서의 여정을 시작하는 데 도움이되지만 통계 기법 혹은 예측 모델링과 같은 광범위한 주제는 다루지 않는다.

10장의 과정에서 다음과 같은 파이썬 모듈을 사용할 것이다.

<주소>

Page 313.

시각화를 사용한 데이터 읽기, 선택 및 해석

이 레시피에서는 알려진 데이터셋의 도움을 받는다. 1,460개의 회사 자금 지원 목록이 포함된 TechCrunch의 Continental USA CSV 파일을 사용한다. 이것은 보이는 것이다. 여기에는 회사 이름, 직원 수, 기금 날짜, 발생 금액, 기금 유형(시리즈 A 혹은 천사 자금)과 같은 데이터 요소가 포함된다.

<그림>

Page 314.

1. 이제 이 CSV 파일에서 데이터를 읽고 선택하는 데 사용할 모듈을 설치해보자. 그렇게하기 전에 가상 환경을 설정하고 활성화할 것이다.

<소스>

2. 그래 좋아! 이제, pandas를 설치하자. CSV 파일을 읽고 분석할 데이터를 선택하기 위해 pandas를 사용한다. 가장 좋아하는 유틸리티인 python-pip로 pandas를 설치한다. 다음은 Mac OSX의 pandas의 설치 로그이다.

<소스>

<<중요표시시작>>
pandas 모듈을 설치하는 것은 나를 위해 numpy 모듈도 설치된다. 사실, 나는 이 모듈을 내 머신에 일찍 설치했다. 따라서 많은 모듈이 캐시에서 선택된다. 컴퓨터에서 설치 로그가 다를 수 있다.
<<중요표시종료>>

3. 다음으로 matplotlib와 seaborn을 설치하자. 시각화를 위해 사용할 라이브러리다. 다음은 matplotlib에 대한 첫번째 내 머신의 설치 로그이다.

<소스>

Page 315.

<소스>

보시다시피 이러한 모듈은 내 머신에 설치되므로 설치 로그는 컴퓨터에 처음 모듈을 설치할 때 다를 수 있다. 여기에 seaborn에 대한 로그가 있다.

<소스>

실행방법

1. 먼저, https://support.spatialkey.com/spatialkey-sample-csv-data/에서 CSV 파일을 다운로드하자. TechCrunch 파일의 직접 다운로드 링크는 http://samplecsvs.s3.amazonaws.com/TechCrunchcontinentalUSA.csv이다. 다음과 같이 wget 커맨드를 사용하여 이 파일을 다운로드할 수 있다.

<소스>

Page 316.

2. 이제, CSV 파일을 읽는 첫 번째 파이썬 코드를 작성해보자. CSV 파일을 읽고 처음 다섯 행을 인쇄한다.

<소스>

앞의 코드 예제에서는 CSV 파일의 처음 다섯 레코드를 읽는다.

<그림>

3. pandas 모듈은 파일의 내용을 읽고 행과 열의 데이터 프레임으로 변환한다. 이제, 앞의 코드 결과를 살펴보면, 인덱스 열이 파일 내용에 추가된다는 것을 알 수 있다. pandas를 사용하면 날짜를 파싱하고 CSV 파일의 날짜에 첫 번째 일 혹은 첫 번째 월(영국 혹은 미국 형식)이 있는지 쉽게알 수 있으며 날짜 열을 인덱스 열로 지정할 수 있다.

<소스>

Page 317.

앞의 코드 조각을 실행하면 다음 스크린샷과 같이 인덱스 열인 fundedDate를 볼 수 있다.

<그림>

4. 좋아! 이제, 데이터를 읽을 수 있지만 그 위에 몇 가지 분석을 수행하기 위해 일부 데이터를 선택한다. 회사(raisedAmt 열)에서 제기한 자금의 양을 묘사하는 열을 선택하자.

<소스>

다음 스크린샷에는 자금을 모집하는 회사의 상위 5 개 레코드가 인쇄됐다.

<그림>

Page 318.

5. 그래, 좋아! 따라서 선택한 컬럼을 선택하고 분석을 위한 데이터를 얻을 수 있다. 멋진 시각화를 생성할 수 있는지 살펴보자. 다음 레시피는 양(y 축)을 기준으로 모든 연도(x 축)에 대해 보고된 자금 조달 라운드에 대한 선형 차트(line chart)를 생성한다.

<소스>

다음 스크린샷에서 자금 조달 비율(혹은 보고 비율)이 어떻게 증가했는지 확인하고, 인상된 금액도 꾸준히 증가한 것을 확인한다.

Page 319.

<그림>

환상적이다! 이미 여기서 하고 있는 것을 좋아하기 시작한 것을 알고있다. 앞으로 나아가 CSV 파일에서 여러 열을 선택할 수 있는지 살펴보자. 다음 예제에서는 열 이름이 company, category 및 fundedDate인 50 개의 행에 대한 데이터를 얻는다.

<소스>

Page 320.

앞의 코드 조각의 출력은 다음과 같다.

Page 321.

7. 좋아! 이제 이 열 중 하나를 선택하고 그 위에 몇 가지 분석을 수행해보자. 다음 코드 예제에서는 보고된 모든 자금 조달 라운드의 범주를 제공하는 category 열을 선택한다. 그런 다음 선택한 열을 처리하여 가장 많이 펀딩을 받는 회사의 카테고리를 얻는다.

<소스>

앞의 코드 조각의 출력은 다음과 같다.

8. 데이터와 숫자는 많은 정보를 제공하지만, 실제로 시각화를 통해서만 영향을 볼 수 있다. 위의 데이터를 수평 막대 차트로 그릴 수 있는지 살펴보자. 다음의 레시피는 우리를 위해 일한다.

<소스>

Page 322.

<소스>

y 축에는 펀딩된 회사의 범주가 있고 x 축은 주어진 범주에 속한 회사의 총 수이다. 또한 플롯트 차트를 categoriesFunded.pdf라는 PDF 파일에 저장한다.

<그림>

우와! 이렇게 많은 웹 회사는 자금을 조달했는가? 굉장해! 나도 웹 회사를 시작해야한다. 자금을 얻을 확률이 높아진다.

Page 323.

